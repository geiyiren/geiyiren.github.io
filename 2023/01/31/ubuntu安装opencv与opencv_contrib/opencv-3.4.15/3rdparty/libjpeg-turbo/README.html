<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>libjpeg-turbo is a JPEG image codec that uses SIMD instructions to accelerate<br>baseline JPEG compression and decompression on x86, x86-64, Arm, PowerPC, and<br>MIPS systems, as well as progressive JPEG compression on x86, x86-64, and Arm<br>systems.  On such systems, libjpeg-turbo is generally 2-6x as fast as libjpeg,<br>all else being equal.  On other types of systems, libjpeg-turbo can still<br>outperform libjpeg by a significant amount, by virtue of its highly-optimized<br>Huffman coding routines.  In many cases, the performance of libjpeg-turbo<br>rivals that of proprietary high-speed JPEG codecs.</p>
<p>libjpeg-turbo implements both the traditional libjpeg API as well as the less<br>powerful but more straightforward TurboJPEG API.  libjpeg-turbo also features<br>colorspace extensions that allow it to compress from&#x2F;decompress to 32-bit and<br>big-endian pixel buffers (RGBX, XBGR, etc.), as well as a full-featured Java<br>interface.</p>
<p>libjpeg-turbo was originally based on libjpeg&#x2F;SIMD, an MMX-accelerated<br>derivative of libjpeg v6b developed by Miyasaka Masaru.  The TigerVNC and<br>VirtualGL projects made numerous enhancements to the codec in 2009, and in<br>early 2010, libjpeg-turbo spun off into an independent project, with the goal<br>of making high-speed JPEG compression&#x2F;decompression technology available to a<br>broader range of users and developers.</p>
<h1 id="License"><a href="#License" class="headerlink" title="License"></a>License</h1><p>libjpeg-turbo is covered by three compatible BSD-style open source licenses.<br>Refer to <a href="LICENSE.md">LICENSE.md</a> for a roll-up of license terms.</p>
<h1 id="Building-libjpeg-turbo"><a href="#Building-libjpeg-turbo" class="headerlink" title="Building libjpeg-turbo"></a>Building libjpeg-turbo</h1><p>Refer to <a href="BUILDING.md">BUILDING.md</a> for complete instructions.</p>
<h1 id="Using-libjpeg-turbo"><a href="#Using-libjpeg-turbo" class="headerlink" title="Using libjpeg-turbo"></a>Using libjpeg-turbo</h1><p>libjpeg-turbo includes two APIs that can be used to compress and decompress<br>JPEG images:</p>
<ul>
<li><p><strong>TurboJPEG API</strong><br><br>This API provides an easy-to-use interface for compressing and decompressing<br>JPEG images in memory.  It also provides some functionality that would not be<br>straightforward to achieve using the underlying libjpeg API, such as<br>generating planar YUV images and performing multiple simultaneous lossless<br>transforms on an image.  The Java interface for libjpeg-turbo is written on<br>top of the TurboJPEG API.  The TurboJPEG API is recommended for first-time<br>users of libjpeg-turbo.  Refer to <a href="tjexample.c">tjexample.c</a> and<br><a href="java/TJExample.java">TJExample.java</a> for examples of its usage and to<br><a href="http://libjpeg-turbo.org/Documentation/Documentation">http://libjpeg-turbo.org/Documentation/Documentation</a> for API documentation.</p>
</li>
<li><p><strong>libjpeg API</strong><br><br>This is the de facto industry-standard API for compressing and decompressing<br>JPEG images.  It is more difficult to use than the TurboJPEG API but also<br>more powerful.  The libjpeg API implementation in libjpeg-turbo is both<br>API&#x2F;ABI-compatible and mathematically compatible with libjpeg v6b.  It can<br>also optionally be configured to be API&#x2F;ABI-compatible with libjpeg v7 and v8<br>(see below.)  Refer to <a href="cjpeg.c">cjpeg.c</a> and <a href="djpeg.c">djpeg.c</a> for examples<br>of its usage and to <a href="libjpeg.txt">libjpeg.txt</a> for API documentation.</p>
</li>
</ul>
<p>There is no significant performance advantage to either API when both are used<br>to perform similar operations.</p>
<h2 id="Colorspace-Extensions"><a href="#Colorspace-Extensions" class="headerlink" title="Colorspace Extensions"></a>Colorspace Extensions</h2><p>libjpeg-turbo includes extensions that allow JPEG images to be compressed<br>directly from (and decompressed directly to) buffers that use BGR, BGRX,<br>RGBX, XBGR, and XRGB pixel ordering.  This is implemented with ten new<br>colorspace constants:</p>
<pre><code>JCS_EXT_RGB   /* red/green/blue */
JCS_EXT_RGBX  /* red/green/blue/x */
JCS_EXT_BGR   /* blue/green/red */
JCS_EXT_BGRX  /* blue/green/red/x */
JCS_EXT_XBGR  /* x/blue/green/red */
JCS_EXT_XRGB  /* x/red/green/blue */
JCS_EXT_RGBA  /* red/green/blue/alpha */
JCS_EXT_BGRA  /* blue/green/red/alpha */
JCS_EXT_ABGR  /* alpha/blue/green/red */
JCS_EXT_ARGB  /* alpha/red/green/blue */
</code></pre>
<p>Setting <code>cinfo.in_color_space</code> (compression) or <code>cinfo.out_color_space</code><br>(decompression) to one of these values will cause libjpeg-turbo to read the<br>red, green, and blue values from (or write them to) the appropriate position in<br>the pixel when compressing from&#x2F;decompressing to an RGB buffer.</p>
<p>Your application can check for the existence of these extensions at compile<br>time with:</p>
<pre><code>#ifdef JCS_EXTENSIONS
</code></pre>
<p>At run time, attempting to use these extensions with a libjpeg implementation<br>that does not support them will result in a “Bogus input colorspace” error.<br>Applications can trap this error in order to test whether run-time support is<br>available for the colorspace extensions.</p>
<p>When using the RGBX, BGRX, XBGR, and XRGB colorspaces during decompression, the<br>X byte is undefined, and in order to ensure the best performance, libjpeg-turbo<br>can set that byte to whatever value it wishes.  If an application expects the X<br>byte to be used as an alpha channel, then it should specify <code>JCS_EXT_RGBA</code>,<br><code>JCS_EXT_BGRA</code>, <code>JCS_EXT_ABGR</code>, or <code>JCS_EXT_ARGB</code>.  When these colorspace<br>constants are used, the X byte is guaranteed to be 0xFF, which is interpreted<br>as opaque.</p>
<p>Your application can check for the existence of the alpha channel colorspace<br>extensions at compile time with:</p>
<pre><code>#ifdef JCS_ALPHA_EXTENSIONS
</code></pre>
<p><a href="jcstest.c">jcstest.c</a>, located in the libjpeg-turbo source tree, demonstrates<br>how to check for the existence of the colorspace extensions at compile time and<br>run time.</p>
<h2 id="libjpeg-v7-and-v8-API-x2F-ABI-Emulation"><a href="#libjpeg-v7-and-v8-API-x2F-ABI-Emulation" class="headerlink" title="libjpeg v7 and v8 API&#x2F;ABI Emulation"></a>libjpeg v7 and v8 API&#x2F;ABI Emulation</h2><p>With libjpeg v7 and v8, new features were added that necessitated extending the<br>compression and decompression structures.  Unfortunately, due to the exposed<br>nature of those structures, extending them also necessitated breaking backward<br>ABI compatibility with previous libjpeg releases.  Thus, programs that were<br>built to use libjpeg v7 or v8 did not work with libjpeg-turbo, since it is<br>based on the libjpeg v6b code base.  Although libjpeg v7 and v8 are not<br>as widely used as v6b, enough programs (including a few Linux distros) made<br>the switch that there was a demand to emulate the libjpeg v7 and v8 ABIs<br>in libjpeg-turbo.  It should be noted, however, that this feature was added<br>primarily so that applications that had already been compiled to use libjpeg<br>v7+ could take advantage of accelerated baseline JPEG encoding&#x2F;decoding<br>without recompiling.  libjpeg-turbo does not claim to support all of the<br>libjpeg v7+ features, nor to produce identical output to libjpeg v7+ in all<br>cases (see below.)</p>
<p>By passing an argument of <code>-DWITH_JPEG7=1</code> or <code>-DWITH_JPEG8=1</code> to <code>cmake</code>, you<br>can build a version of libjpeg-turbo that emulates the libjpeg v7 or v8 ABI, so<br>that programs that are built against libjpeg v7 or v8 can be run with<br>libjpeg-turbo.  The following section describes which libjpeg v7+ features are<br>supported and which aren’t.</p>
<h3 id="Support-for-libjpeg-v7-and-v8-Features"><a href="#Support-for-libjpeg-v7-and-v8-Features" class="headerlink" title="Support for libjpeg v7 and v8 Features"></a>Support for libjpeg v7 and v8 Features</h3><h4 id="Fully-supported"><a href="#Fully-supported" class="headerlink" title="Fully supported"></a>Fully supported</h4><ul>
<li><p><strong>libjpeg API: IDCT scaling extensions in decompressor</strong><br><br>libjpeg-turbo supports IDCT scaling with scaling factors of 1&#x2F;8, 1&#x2F;4, 3&#x2F;8,<br>1&#x2F;2, 5&#x2F;8, 3&#x2F;4, 7&#x2F;8, 9&#x2F;8, 5&#x2F;4, 11&#x2F;8, 3&#x2F;2, 13&#x2F;8, 7&#x2F;4, 15&#x2F;8, and 2&#x2F;1 (only 1&#x2F;4<br>and 1&#x2F;2 are SIMD-accelerated.)</p>
</li>
<li><p><strong>libjpeg API: Arithmetic coding</strong></p>
</li>
<li><p><strong>libjpeg API: In-memory source and destination managers</strong><br><br>See notes below.</p>
</li>
<li><p><strong>cjpeg: Separate quality settings for luminance and chrominance</strong><br><br>Note that the libpjeg v7+ API was extended to accommodate this feature only<br>for convenience purposes.  It has always been possible to implement this<br>feature with libjpeg v6b (see rdswitch.c for an example.)</p>
</li>
<li><p><strong>cjpeg: 32-bit BMP support</strong></p>
</li>
<li><p><strong>cjpeg: <code>-rgb</code> option</strong></p>
</li>
<li><p><strong>jpegtran: Lossless cropping</strong></p>
</li>
<li><p><strong>jpegtran: <code>-perfect</code> option</strong></p>
</li>
<li><p><strong>jpegtran: Forcing width&#x2F;height when performing lossless crop</strong></p>
</li>
<li><p><strong>rdjpgcom: <code>-raw</code> option</strong></p>
</li>
<li><p><strong>rdjpgcom: Locale awareness</strong></p>
</li>
</ul>
<h4 id="Not-supported"><a href="#Not-supported" class="headerlink" title="Not supported"></a>Not supported</h4><p>NOTE:  As of this writing, extensive research has been conducted into the<br>usefulness of DCT scaling as a means of data reduction and SmartScale as a<br>means of quality improvement.  Readers are invited to peruse the research at<br><a href="http://www.libjpeg-turbo.org/About/SmartScale">http://www.libjpeg-turbo.org/About/SmartScale</a> and draw their own conclusions,<br>but it is the general belief of our project that these features have not<br>demonstrated sufficient usefulness to justify inclusion in libjpeg-turbo.</p>
<ul>
<li><p><strong>libjpeg API: DCT scaling in compressor</strong><br><br><code>cinfo.scale_num</code> and <code>cinfo.scale_denom</code> are silently ignored.<br>There is no technical reason why DCT scaling could not be supported when<br>emulating the libjpeg v7+ API&#x2F;ABI, but without the SmartScale extension (see<br>below), only scaling factors of 1&#x2F;2, 8&#x2F;15, 4&#x2F;7, 8&#x2F;13, 2&#x2F;3, 8&#x2F;11, 4&#x2F;5, and<br>8&#x2F;9 would be available, which is of limited usefulness.</p>
</li>
<li><p><strong>libjpeg API: SmartScale</strong><br><br><code>cinfo.block_size</code> is silently ignored.<br>SmartScale is an extension to the JPEG format that allows for DCT block<br>sizes other than 8x8.  Providing support for this new format would be<br>feasible (particularly without full acceleration.)  However, until&#x2F;unless<br>the format becomes either an official industry standard or, at minimum, an<br>accepted solution in the community, we are hesitant to implement it, as<br>there is no sense of whether or how it might change in the future.  It is<br>our belief that SmartScale has not demonstrated sufficient usefulness as a<br>lossless format nor as a means of quality enhancement, and thus our primary<br>interest in providing this feature would be as a means of supporting<br>additional DCT scaling factors.</p>
</li>
<li><p><strong>libjpeg API: Fancy downsampling in compressor</strong><br><br><code>cinfo.do_fancy_downsampling</code> is silently ignored.<br>This requires the DCT scaling feature, which is not supported.</p>
</li>
<li><p><strong>jpegtran: Scaling</strong><br><br>This requires both the DCT scaling and SmartScale features, which are not<br>supported.</p>
</li>
<li><p><strong>Lossless RGB JPEG files</strong><br><br>This requires the SmartScale feature, which is not supported.</p>
</li>
</ul>
<h3 id="What-About-libjpeg-v9"><a href="#What-About-libjpeg-v9" class="headerlink" title="What About libjpeg v9?"></a>What About libjpeg v9?</h3><p>libjpeg v9 introduced yet another field to the JPEG compression structure<br>(<code>color_transform</code>), thus making the ABI backward incompatible with that of<br>libjpeg v8.  This new field was introduced solely for the purpose of supporting<br>lossless SmartScale encoding.  Furthermore, there was actually no reason to<br>extend the API in this manner, as the color transform could have just as easily<br>been activated by way of a new JPEG colorspace constant, thus preserving<br>backward ABI compatibility.</p>
<p>Our research (see link above) has shown that lossless SmartScale does not<br>generally accomplish anything that can’t already be accomplished better with<br>existing, standard lossless formats.  Therefore, at this time it is our belief<br>that there is not sufficient technical justification for software projects to<br>upgrade from libjpeg v8 to libjpeg v9, and thus there is not sufficient<br>technical justification for us to emulate the libjpeg v9 ABI.</p>
<h2 id="In-Memory-Source-x2F-Destination-Managers"><a href="#In-Memory-Source-x2F-Destination-Managers" class="headerlink" title="In-Memory Source&#x2F;Destination Managers"></a>In-Memory Source&#x2F;Destination Managers</h2><p>By default, libjpeg-turbo 1.3 and later includes the <code>jpeg_mem_src()</code> and<br><code>jpeg_mem_dest()</code> functions, even when not emulating the libjpeg v8 API&#x2F;ABI.<br>Previously, it was necessary to build libjpeg-turbo from source with libjpeg v8<br>API&#x2F;ABI emulation in order to use the in-memory source&#x2F;destination managers,<br>but several projects requested that those functions be included when emulating<br>the libjpeg v6b API&#x2F;ABI as well.  This allows the use of those functions by<br>programs that need them, without breaking ABI compatibility for programs that<br>don’t, and it allows those functions to be provided in the “official”<br>libjpeg-turbo binaries.</p>
<p>Those who are concerned about maintaining strict conformance with the libjpeg<br>v6b or v7 API can pass an argument of <code>-DWITH_MEM_SRCDST=0</code> to <code>cmake</code> prior to<br>building libjpeg-turbo.  This will restore the pre-1.3 behavior, in which<br><code>jpeg_mem_src()</code> and <code>jpeg_mem_dest()</code> are only included when emulating the<br>libjpeg v8 API&#x2F;ABI.</p>
<p>On Un*x systems, including the in-memory source&#x2F;destination managers changes<br>the dynamic library version from 62.2.0 to 62.3.0 if using libjpeg v6b API&#x2F;ABI<br>emulation and from 7.2.0 to 7.3.0 if using libjpeg v7 API&#x2F;ABI emulation.</p>
<p>Note that, on most Un*x systems, the dynamic linker will not look for a<br>function in a library until that function is actually used.  Thus, if a program<br>is built against libjpeg-turbo 1.3+ and uses <code>jpeg_mem_src()</code> or<br><code>jpeg_mem_dest()</code>, that program will not fail if run against an older version<br>of libjpeg-turbo or against libjpeg v7- until the program actually tries to<br>call <code>jpeg_mem_src()</code> or <code>jpeg_mem_dest()</code>.  Such is not the case on Windows.<br>If a program is built against the libjpeg-turbo 1.3+ DLL and uses<br><code>jpeg_mem_src()</code> or <code>jpeg_mem_dest()</code>, then it must use the libjpeg-turbo 1.3+<br>DLL at run time.</p>
<p>Both cjpeg and djpeg have been extended to allow testing the in-memory<br>source&#x2F;destination manager functions.  See their respective man pages for more<br>details.</p>
<h1 id="Mathematical-Compatibility"><a href="#Mathematical-Compatibility" class="headerlink" title="Mathematical Compatibility"></a>Mathematical Compatibility</h1><p>For the most part, libjpeg-turbo should produce identical output to libjpeg<br>v6b.  The one exception to this is when using the floating point DCT&#x2F;IDCT, in<br>which case the outputs of libjpeg v6b and libjpeg-turbo can differ for the<br>following reasons:</p>
<ul>
<li><p>The SSE&#x2F;SSE2 floating point DCT implementation in libjpeg-turbo is ever so<br>slightly more accurate than the implementation in libjpeg v6b, but not by<br>any amount perceptible to human vision (generally in the range of 0.01 to<br>0.08 dB gain in PNSR.)</p>
</li>
<li><p>When not using the SIMD extensions, libjpeg-turbo uses the more accurate<br>(and slightly faster) floating point IDCT algorithm introduced in libjpeg<br>v8a as opposed to the algorithm used in libjpeg v6b.  It should be noted,<br>however, that this algorithm basically brings the accuracy of the floating<br>point IDCT in line with the accuracy of the accurate integer IDCT.  The<br>floating point DCT&#x2F;IDCT algorithms are mainly a legacy feature, and they do<br>not produce significantly more accuracy than the accurate integer algorithms<br>(to put numbers on this, the typical difference in PNSR between the two<br>algorithms is less than 0.10 dB, whereas changing the quality level by 1 in<br>the upper range of the quality scale is typically more like a 1.0 dB<br>difference.)</p>
</li>
<li><p>If the floating point algorithms in libjpeg-turbo are not implemented using<br>SIMD instructions on a particular platform, then the accuracy of the<br>floating point DCT&#x2F;IDCT can depend on the compiler settings.</p>
</li>
</ul>
<p>While libjpeg-turbo does emulate the libjpeg v8 API&#x2F;ABI, under the hood it is<br>still using the same algorithms as libjpeg v6b, so there are several specific<br>cases in which libjpeg-turbo cannot be expected to produce the same output as<br>libjpeg v8:</p>
<ul>
<li><p>When decompressing using scaling factors of 1&#x2F;2 and 1&#x2F;4, because libjpeg v8<br>implements those scaling algorithms differently than libjpeg v6b does, and<br>libjpeg-turbo’s SIMD extensions are based on the libjpeg v6b behavior.</p>
</li>
<li><p>When using chrominance subsampling, because libjpeg v8 implements this<br>with its DCT&#x2F;IDCT scaling algorithms rather than with a separate<br>downsampling&#x2F;upsampling algorithm.  In our testing, the subsampled&#x2F;upsampled<br>output of libjpeg v8 is less accurate than that of libjpeg v6b for this<br>reason.</p>
</li>
<li><p>When decompressing using a scaling factor &gt; 1 and merged (AKA “non-fancy” or<br>“non-smooth”) chrominance upsampling, because libjpeg v8 does not support<br>merged upsampling with scaling factors &gt; 1.</p>
</li>
</ul>
<h1 id="Performance-Pitfalls"><a href="#Performance-Pitfalls" class="headerlink" title="Performance Pitfalls"></a>Performance Pitfalls</h1><h2 id="Restart-Markers"><a href="#Restart-Markers" class="headerlink" title="Restart Markers"></a>Restart Markers</h2><p>The optimized Huffman decoder in libjpeg-turbo does not handle restart markers<br>in a way that makes the rest of the libjpeg infrastructure happy, so it is<br>necessary to use the slow Huffman decoder when decompressing a JPEG image that<br>has restart markers.  This can cause the decompression performance to drop by<br>as much as 20%, but the performance will still be much greater than that of<br>libjpeg.  Many consumer packages, such as Photoshop, use restart markers when<br>generating JPEG images, so images generated by those programs will experience<br>this issue.</p>
<h2 id="Fast-Integer-Forward-DCT-at-High-Quality-Levels"><a href="#Fast-Integer-Forward-DCT-at-High-Quality-Levels" class="headerlink" title="Fast Integer Forward DCT at High Quality Levels"></a>Fast Integer Forward DCT at High Quality Levels</h2><p>The algorithm used by the SIMD-accelerated quantization function cannot produce<br>correct results whenever the fast integer forward DCT is used along with a JPEG<br>quality of 98-100.  Thus, libjpeg-turbo must use the non-SIMD quantization<br>function in those cases.  This causes performance to drop by as much as 40%.<br>It is therefore strongly advised that you use the accurate integer forward DCT<br>whenever encoding images with a JPEG quality of 98 or higher.</p>
<h1 id="Memory-Debugger-Pitfalls"><a href="#Memory-Debugger-Pitfalls" class="headerlink" title="Memory Debugger Pitfalls"></a>Memory Debugger Pitfalls</h1><p>Valgrind and Memory Sanitizer (MSan) can generate false positives<br>(specifically, incorrect reports of uninitialized memory accesses) when used<br>with libjpeg-turbo’s SIMD extensions.  It is generally recommended that the<br>SIMD extensions be disabled, either by passing an argument of <code>-DWITH_SIMD=0</code><br>to <code>cmake</code> when configuring the build or by setting the environment variable<br><code>JSIMD_FORCENONE</code> to <code>1</code> at run time, when testing libjpeg-turbo with Valgrind,<br>MSan, or other memory debuggers.</p>
