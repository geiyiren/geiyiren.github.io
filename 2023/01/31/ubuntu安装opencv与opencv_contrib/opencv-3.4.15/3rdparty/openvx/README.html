<h1 id="C-wrappers-for-OpenVX-1-x-C-API"><a href="#C-wrappers-for-OpenVX-1-x-C-API" class="headerlink" title="C++ wrappers for OpenVX-1.x C API"></a>C++ wrappers for OpenVX-1.x C API</h1><h2 id="Core-ideas"><a href="#Core-ideas" class="headerlink" title="Core ideas:"></a>Core ideas:</h2><ul>
<li>lightweight - minimal overhead vs standard C API</li>
<li>automatic references counting</li>
<li>exceptions instead of return codes</li>
<li>object-oriented design</li>
<li>(NYI) helpers for user-defined kernels &amp; nodes</li>
<li>C++ 11 friendly</li>
</ul>
<h2 id="Quick-start-sample"><a href="#Quick-start-sample" class="headerlink" title="Quick start sample"></a>Quick start sample</h2><p>The following short sample gives basic knowledges on the wrappers usage:</p>
<pre><code class="cpp">#include &quot;ivx.hpp&quot;
#include &quot;ivx_lib_debug.hpp&quot; // ivx::debug::*

int main()
{
    vx_uint32 width = 640, height = 480;
    try
    {
        ivx::Context context = ivx::Context::create();
        ivx::Graph graph = ivx::Graph::create(context);
        ivx::Image
            gray = ivx::Image::create(context, width, height, VX_DF_IMAGE_U8),
            gb   = ivx::Image::createVirtual(graph),
            res  = ivx::Image::create(context, width, height, VX_DF_IMAGE_U8);

        context.loadKernels(&quot;openvx-debug&quot;);  // ivx::debug::*

        ivx::debug::fReadImage(context, inputPath, gray);

        ivx::Node::create(graph, VX_KERNEL_GAUSSIAN_3x3, gray, gb);
        ivx::Node::create(
            graph,
            VX_KERNEL_THRESHOLD,
            gb,
            ivx::Threshold::createBinary(context, VX_TYPE_UINT8, 50),
            res
        );

        graph.verify();
        graph.process();

        ivx::debug::fWriteImage(context, res, &quot;ovx-res-cpp.pgm&quot;);
    }
    catch (const ivx::RuntimeError&amp; e)
    {
        printf(&quot;ErrorRuntime: code = %d(%x), message = %s\n&quot;, e.status(), e.status(), e.what());
        return e.status();
    }
    catch (const ivx::WrapperError&amp; e)
    {
        printf(&quot;ErrorWrapper: message = %s\n&quot;, e.what());
        return -1;
    }
    catch(const std::exception&amp; e)
    {
        printf(&quot;runtime_error: message = %s\n&quot;, e.what());
        return -1;
    }

    return 0;
}
    
</code></pre>
<h2 id="C-API-overview"><a href="#C-API-overview" class="headerlink" title="C++ API overview"></a>C++ API overview</h2><p>The wrappers have <strong>header-only</strong> implementation that simplifies their integration to projects.<br>All the API is inside <code>ivx</code> namespace (E.g. <code>class ivx::Graph</code>).</p>
<p>While the C++ API is pretty much the same for underlying OpenVX version <strong>1.0</strong> and <strong>1.1</strong>, there are alternative code branches for some features implementation  that are selected at <strong>compile time</strong> via <code>#ifdef</code> preprocessor directives.<br>E.g. external ref-counting is implemented for 1.0 version and native OpenVX one is used (via  <code>vxRetainReference()</code> and <code>vxReleaseXYZ()</code>) for version 1.1.</p>
<p>Also there are some <strong>C++ 11</strong> features are used (e.g. rvalue ref-s) when their availability is detected at <em><strong>compile time</strong></em>.</p>
<p>C++ exceptions are used for errors indication instead of return codes. There are two types of exceptions are defined:  <code>RuntimeError</code> is thrown when OpenVX C call returned unsuccessful result and <code>WrapperError</code> is thrown when a problem is occured in the wrappers code. Both exception calsses are derived from <code>std::exception</code> (actually from its inheritants).</p>
<p>The so called <strong>OpenVX objects</strong> (e.g. <code>vx_image</code>) are represented as C++ classes in wrappers.<br>All these classes use automatic ref-counting that allows development of exception-safe code.<br>All these classes have <code>create()</code> or <code>createXYZ()</code> <code>static</code> methods for instances creation. (E.g. <code>Image::create()</code>, <code>Image::createVirtual()</code> and  <code>Image::createFromHandle()</code>)<br>Most of the wrapped OpenVX functions are represented as methods of the corresponding C++ classes, but in most cases they still accept C “object” types (e.g. <code>vx_image</code> or <code>vx_context</code>) that allows mixing of C and C++ OpenVX API use.<br>E.g.:</p>
<pre><code class="cpp">class Image
{
    static Image create(vx_context context, vx_uint32 width, vx_uint32 height, vx_df_image format);
    static Image createVirtual(vx_graph graph, vx_uint32 width = 0, vx_uint32 height = 0, vx_df_image format = VX_DF_IMAGE_VIRT);
    // ...
}
</code></pre>
<p>All the classes instances can automatically be converted to the corresponding C “object” types.</p>
<p>For more details please refer to C++ wrappers reference manual or directly to their source code.</p>
