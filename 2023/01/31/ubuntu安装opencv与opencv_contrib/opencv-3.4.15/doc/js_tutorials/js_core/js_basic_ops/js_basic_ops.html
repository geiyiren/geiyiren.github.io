<h1 id="Basic-Operations-on-Images-tutorial-js-basic-ops"><a href="#Basic-Operations-on-Images-tutorial-js-basic-ops" class="headerlink" title="Basic Operations on Images {#tutorial_js_basic_ops}"></a>Basic Operations on Images {#tutorial_js_basic_ops}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><ul>
<li>Learn how to access image properties</li>
<li>Learn how to construct Mat</li>
<li>Learn how to copy Mat</li>
<li>Learn how to convert the type of Mat</li>
<li>Learn how to use MatVector</li>
<li>Learn how to access pixel values and modify them</li>
<li>Learn how to set Region of Interest (ROI)</li>
<li>Learn how to split and merge images</li>
</ul>
<h2 id="Accessing-Image-Properties"><a href="#Accessing-Image-Properties" class="headerlink" title="Accessing Image Properties"></a>Accessing Image Properties</h2><p>Image properties include number of rows, columns and size, depth, channels, type of image data.</p>
<p>@code{.js}<br>let src &#x3D; cv.imread(“canvasInput”);<br>console.log(‘image width: ‘ + src.cols + ‘\n’ +<br>            ‘image height: ‘ + src.rows + ‘\n’ +<br>            ‘image size: ‘ + src.size().width + ‘*’ + src.size().height + ‘\n’ +<br>            ‘image depth: ‘ + src.depth() + ‘\n’ +<br>            ‘image channels ‘ + src.channels() + ‘\n’ +<br>            ‘image type: ‘ + src.type() + ‘\n’);<br>@endcode</p>
<p>@note src.type() is very important while debugging because a large number of errors in OpenCV.js<br>code are caused by invalid data type.</p>
<h2 id="How-to-construct-Mat"><a href="#How-to-construct-Mat" class="headerlink" title="How to construct Mat"></a>How to construct Mat</h2><p>There are 4 basic constructors:</p>
<p>@code{.js}<br>&#x2F;&#x2F; 1. default constructor<br>let mat &#x3D; new cv.Mat();<br>&#x2F;&#x2F; 2. two-dimensional arrays by size and type<br>let mat &#x3D; new cv.Mat(size, type);<br>&#x2F;&#x2F; 3. two-dimensional arrays by rows, cols, and type<br>let mat &#x3D; new cv.Mat(rows, cols, type);<br>&#x2F;&#x2F; 4. two-dimensional arrays by rows, cols, and type with initialization value<br>let mat &#x3D; new cv.Mat(rows, cols, type, new cv.Scalar());<br>@endcode</p>
<p>There are 3 static functions:</p>
<p>@code{.js}<br>&#x2F;&#x2F; 1. Create a Mat which is full of zeros<br>let mat &#x3D; cv.Mat.zeros(rows, cols, type);<br>&#x2F;&#x2F; 2. Create a Mat which is full of ones<br>let mat &#x3D; cv.Mat.ones(rows, cols, type);<br>&#x2F;&#x2F; 3. Create a Mat which is an identity matrix<br>let mat &#x3D; cv.Mat.eye(rows, cols, type);<br>@endcode</p>
<p>There are 2 factory functions:<br>@code{.js}<br>&#x2F;&#x2F; 1. Use JS array to construct a mat.<br>&#x2F;&#x2F; For example: let mat &#x3D; cv.matFromArray(2, 2, cv.CV_8UC1, [1, 2, 3, 4]);<br>let mat &#x3D; cv.matFromArray(rows, cols, type, array);<br>&#x2F;&#x2F; 2. Use imgData to construct a mat<br>let ctx &#x3D; canvas.getContext(“2d”);<br>let imgData &#x3D; ctx.getImageData(0, 0, canvas.width, canvas.height);<br>let mat &#x3D; cv.matFromImageData(imgData);<br>@endcode</p>
<p>@note Don’t forget to delete cv.Mat when you don’t want to use it any more.</p>
<h2 id="How-to-copy-Mat"><a href="#How-to-copy-Mat" class="headerlink" title="How to copy Mat"></a>How to copy Mat</h2><p>There are 2 ways to copy a Mat:</p>
<p>@code{.js}<br>&#x2F;&#x2F; 1. Clone<br>let dst &#x3D; src.clone();<br>&#x2F;&#x2F; 2. CopyTo(only entries indicated in the mask are copied)<br>src.copyTo(dst, mask);<br>@endcode</p>
<h2 id="How-to-convert-the-type-of-Mat"><a href="#How-to-convert-the-type-of-Mat" class="headerlink" title="How to convert the type of Mat"></a>How to convert the type of Mat</h2><p>We use the function: <strong>convertTo(m, rtype, alpha &#x3D; 1, beta &#x3D; 0)</strong><br>@param m        output matrix; if it does not have a proper size or type before the operation, it is reallocated.<br>@param rtype    desired output matrix type or, rather, the depth since the number of channels are the same as the input has; if rtype is negative, the output matrix will have the same type as the input.<br>@param alpha    optional scale factor.<br>@param beta     optional delta added to the scaled values.</p>
<p>@code{.js}<br>src.convertTo(dst, rtype);<br>@endcode</p>
<h2 id="How-use-MatVector"><a href="#How-use-MatVector" class="headerlink" title="How use MatVector"></a>How use MatVector</h2><p>@code{.js}<br>let mat &#x3D; new cv.Mat();<br>&#x2F;&#x2F; Initialise a MatVector<br>let matVec &#x3D; new cv.MatVector();<br>&#x2F;&#x2F; Push a Mat back into MatVector<br>matVec.push_back(mat);<br>&#x2F;&#x2F; Get a Mat fom MatVector<br>let cnt &#x3D; matVec.get(0);<br>mat.delete(); matVec.delete(); cnt.delete();<br>@endcode</p>
<p>@note Don’t forget to delete cv.Mat, cv.MatVector and cnt(the Mat you get from MatVector) when you don’t want to use them any more.</p>
<h2 id="Accessing-and-Modifying-pixel-values"><a href="#Accessing-and-Modifying-pixel-values" class="headerlink" title="Accessing and Modifying pixel values"></a>Accessing and Modifying pixel values</h2><p>Firstly, you should know the following type relationship:</p>
<table>
<thead>
<tr>
<th>Data Properties</th>
<th>C++ Type</th>
<th>JavaScript Typed Array</th>
<th>Mat Type</th>
</tr>
</thead>
<tbody><tr>
<td>data</td>
<td>uchar</td>
<td>Uint8Array</td>
<td>CV_8U</td>
</tr>
<tr>
<td>data8S</td>
<td>char</td>
<td>Int8Array</td>
<td>CV_8S</td>
</tr>
<tr>
<td>data16U</td>
<td>ushort</td>
<td>Uint16Array</td>
<td>CV_16U</td>
</tr>
<tr>
<td>data16S</td>
<td>short</td>
<td>Int16Array</td>
<td>CV_16S</td>
</tr>
<tr>
<td>data32S</td>
<td>int</td>
<td>Int32Array</td>
<td>CV_32S</td>
</tr>
<tr>
<td>data32F</td>
<td>float</td>
<td>Float32Array</td>
<td>CV_32F</td>
</tr>
<tr>
<td>data64F</td>
<td>double</td>
<td>Float64Array</td>
<td>CV_64F</td>
</tr>
</tbody></table>
<p><strong>1. data</strong></p>
<p>@code{.js}<br>let row &#x3D; 3, col &#x3D; 4;<br>let src &#x3D; cv.imread(“canvasInput”);<br>if (src.isContinuous()) {<br>    let R &#x3D; src.data[row * src.cols * src.channels() + col * src.channels()];<br>    let G &#x3D; src.data[row * src.cols * src.channels() + col * src.channels() + 1];<br>    let B &#x3D; src.data[row * src.cols * src.channels() + col * src.channels() + 2];<br>    let A &#x3D; src.data[row * src.cols * src.channels() + col * src.channels() + 3];<br>}<br>@endcode</p>
<p>@note  Data manipulation is only valid for continuous Mat. You should use isContinuous() to check first.</p>
<p><strong>2. at</strong></p>
<table>
<thead>
<tr>
<th>Mat Type</th>
<th>At Manipulation</th>
</tr>
</thead>
<tbody><tr>
<td>CV_8U</td>
<td>ucharAt</td>
</tr>
<tr>
<td>CV_8S</td>
<td>charAt</td>
</tr>
<tr>
<td>CV_16U</td>
<td>ushortAt</td>
</tr>
<tr>
<td>CV_16S</td>
<td>shortAt</td>
</tr>
<tr>
<td>CV_32S</td>
<td>intAt</td>
</tr>
<tr>
<td>CV_32F</td>
<td>floatAt</td>
</tr>
<tr>
<td>CV_64F</td>
<td>doubleAt</td>
</tr>
</tbody></table>
<p>@code{.js}<br>let row &#x3D; 3, col &#x3D; 4;<br>let src &#x3D; cv.imread(“canvasInput”);<br>let R &#x3D; src.ucharAt(row, col * src.channels());<br>let G &#x3D; src.ucharAt(row, col * src.channels() + 1);<br>let B &#x3D; src.ucharAt(row, col * src.channels() + 2);<br>let A &#x3D; src.ucharAt(row, col * src.channels() + 3);<br>@endcode</p>
<p>@note  At manipulation is only for single channel access and the value can’t be modified.</p>
<p><strong>3. ptr</strong></p>
<table>
<thead>
<tr>
<th>Mat Type</th>
<th>Ptr Manipulation</th>
<th>JavaScript Typed Array</th>
</tr>
</thead>
<tbody><tr>
<td>CV_8U</td>
<td>ucharPtr</td>
<td>Uint8Array</td>
</tr>
<tr>
<td>CV_8S</td>
<td>charPtr</td>
<td>Int8Array</td>
</tr>
<tr>
<td>CV_16U</td>
<td>ushortPtr</td>
<td>Uint16Array</td>
</tr>
<tr>
<td>CV_16S</td>
<td>shortPtr</td>
<td>Int16Array</td>
</tr>
<tr>
<td>CV_32S</td>
<td>intPtr</td>
<td>Int32Array</td>
</tr>
<tr>
<td>CV_32F</td>
<td>floatPtr</td>
<td>Float32Array</td>
</tr>
<tr>
<td>CV_64F</td>
<td>doublePtr</td>
<td>Float64Array</td>
</tr>
</tbody></table>
<p>@code{.js}<br>let row &#x3D; 3, col &#x3D; 4;<br>let src &#x3D; cv.imread(“canvasInput”);<br>let pixel &#x3D; src.ucharPtr(row, col);<br>let R &#x3D; pixel[0];<br>let G &#x3D; pixel[1];<br>let B &#x3D; pixel[2];<br>let A &#x3D; pixel[3];<br>@endcode</p>
<p>mat.ucharPtr(k) get the k th row of the mat. mat.ucharPtr(i, j) get the i th row and the j th column of the mat.</p>
<h2 id="Image-ROI"><a href="#Image-ROI" class="headerlink" title="Image ROI"></a>Image ROI</h2><p>Sometimes, you will have to play with certain region of images. For eye detection in images, first<br>face detection is done all over the image and when face is obtained, we select the face region alone<br>and search for eyes inside it instead of searching whole image. It improves accuracy (because eyes<br>are always on faces) and performance (because we search for a small area)</p>
<p>We use the function: <strong>roi (rect)</strong><br>@param rect    rectangle Region of Interest.</p>
<h2 id="Try-it"><a href="#Try-it" class="headerlink" title="Try it"></a>Try it</h2><p>\htmlonly</p>
<iframe src="../../js_basic_ops_roi.html" width="100%"
        onload="this.style.height=this.contentDocument.body.scrollHeight +'px';">
</iframe>
\endhtmlonly


<h2 id="Splitting-and-Merging-Image-Channels"><a href="#Splitting-and-Merging-Image-Channels" class="headerlink" title="Splitting and Merging Image Channels"></a>Splitting and Merging Image Channels</h2><p>Sometimes you will need to work separately on R,G,B channels of image. Then you need to split the<br>RGB images to single planes. Or another time, you may need to join these individual channels to RGB<br>image.</p>
<p>@code{.js}<br>let src &#x3D; cv.imread(“canvasInput”);<br>let rgbaPlanes &#x3D; new cv.MatVector();<br>&#x2F;&#x2F; Split the Mat<br>cv.split(src, rgbaPlanes);<br>&#x2F;&#x2F; Get R channel<br>let R &#x3D; rgbaPlanes.get(0);<br>&#x2F;&#x2F; Merge all channels<br>cv.merge(rgbaPlanes, src);<br>src.delete(); rgbaPlanes.delete(); R.delete();<br>@endcode</p>
<p>@note Don’t forget to delete cv.Mat, cv.MatVector and R(the Mat you get from MatVector) when you don’t want to use them any more.</p>
<h2 id="Making-Borders-for-Images-Padding"><a href="#Making-Borders-for-Images-Padding" class="headerlink" title="Making Borders for Images (Padding)"></a>Making Borders for Images (Padding)</h2><p>If you want to create a border around the image, something like a photo frame, you can use<br><strong>cv.copyMakeBorder()</strong> function. But it has more applications for convolution operation, zero<br>padding etc. This function takes following arguments:</p>
<ul>
<li><p><strong>src</strong> - input image</p>
</li>
<li><p><strong>top</strong>, <strong>bottom</strong>, <strong>left</strong>, <strong>right</strong> - border width in number of pixels in corresponding<br>directions</p>
</li>
<li><p><strong>borderType</strong> - Flag defining what kind of border to be added. It can be following types:</p>
<ul>
<li><strong>cv.BORDER_CONSTANT</strong> - Adds a constant colored border. The value should be given<br>as next argument.<ul>
<li><strong>cv.BORDER_REFLECT</strong> - Border will be mirror reflection of the border elements,<br>like this : <em>fedcba|abcdefgh|hgfedcb</em></li>
<li><strong>cv.BORDER_REFLECT_101</strong> or <strong>cv.BORDER_DEFAULT</strong> - Same as above, but with a<br>slight change, like this : <em>gfedcb|abcdefgh|gfedcba</em></li>
<li><strong>cv.BORDER_REPLICATE</strong> - Last element is replicated throughout, like this:<br><em>aaaaaa|abcdefgh|hhhhhhh</em></li>
<li><strong>cv.BORDER_WRAP</strong> - Can’t explain, it will look like this :<br><em>cdefgh|abcdefgh|abcdefg</em></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>value</strong> - Color of border if border type is cv.BORDER_CONSTANT</p>
</li>
</ul>
<h2 id="Try-it-1"><a href="#Try-it-1" class="headerlink" title="Try it"></a>Try it</h2><p>\htmlonly</p>
<iframe src="../../js_basic_ops_copymakeborder.html" width="100%"
        onload="this.style.height=this.contentDocument.body.scrollHeight +'px';">
</iframe>
\endhtmlonly
