<h1 id="Getting-Started-with-Images-tutorial-js-image-display"><a href="#Getting-Started-with-Images-tutorial-js-image-display" class="headerlink" title="Getting Started with Images {#tutorial_js_image_display}"></a>Getting Started with Images {#tutorial_js_image_display}</h1><h2 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h2><ul>
<li>Learn how to read an image and how to display it in a web.</li>
</ul>
<h2 id="Read-an-image"><a href="#Read-an-image" class="headerlink" title="Read an image"></a>Read an image</h2><p>OpenCV.js saves images as cv.Mat type. We use HTML canvas element to transfer cv.Mat to the web<br>or in reverse. The ImageData interface can represent or set the underlying pixel data of an area of a<br>canvas element.</p>
<p>@note Please refer to canvas docs for more details.</p>
<p>First, create an ImageData obj from canvas:<br>@code{.js}<br>let canvas &#x3D; document.getElementById(canvasInputId);<br>let ctx &#x3D; canvas.getContext(‘2d’);<br>let imgData &#x3D; ctx.getImageData(0, 0, canvas.width, canvas.height);<br>@endcode</p>
<p>Then, use cv.matFromImageData to construct a cv.Mat:<br>@code{.js}<br>let src &#x3D; cv.matFromImageData(imgData);<br>@endcode</p>
<p>@note Because canvas only support 8-bit RGBA image with continuous storage, the cv.Mat type is cv.CV_8UC4.<br>It is different from native OpenCV because images returned and shown by the native <strong>imread</strong> and<br><strong>imshow</strong> have the channels stored in BGR order.</p>
<h2 id="Display-an-image"><a href="#Display-an-image" class="headerlink" title="Display an image"></a>Display an image</h2><p>First, convert the type of src to cv.CV_8UC4:<br>@code{.js}<br>let dst &#x3D; new cv.Mat();<br>&#x2F;&#x2F; scale and shift are used to map the data to [0, 255].<br>src.convertTo(dst, cv.CV_8U, scale, shift);<br>&#x2F;&#x2F; *** is GRAY, RGB, or RGBA, according to src.channels() is 1, 3 or 4.<br>cv.cvtColor(dst, dst, cv.COLOR_***2RGBA);<br>@endcode</p>
<p>Then, new an ImageData obj from dst:<br>@code{.js}<br>let imgData &#x3D; new ImageData(new Uint8ClampedArray(dst.data, dst.cols, dst.rows);<br>@endcode</p>
<p>Finally, display it:<br>@code{.js}<br>let canvas &#x3D; document.getElementById(canvasOutputId);<br>let ctx &#x3D; canvas.getContext(‘2d’);<br>ctx.clearRect(0, 0, canvas.width, canvas.height);<br>canvas.width &#x3D; imgData.width;<br>canvas.height &#x3D; imgData.height;<br>ctx.putImageData(imgData, 0, 0);<br>@endcode</p>
<h2 id="In-OpenCV-js"><a href="#In-OpenCV-js" class="headerlink" title="In OpenCV.js"></a>In OpenCV.js</h2><p>OpenCV.js implements image reading and showing using the above method.</p>
<p>We use <strong>cv.imread (imageSource)</strong> to read an image from html canvas or img element.<br>@param imageSource   canvas element or id, or img element or id.<br>@return              mat with channels stored in RGBA order.</p>
<p>We use <strong>cv.imshow (canvasSource, mat)</strong> to display it. The function may scale the mat,<br>depending on its depth:</p>
<ul>
<li>If the mat is 8-bit unsigned, it is displayed as is.</li>
<li>If the mat is 16-bit unsigned or 32-bit integer, the pixels are divided by 256. That<br>is, the value range [0,255*256] is mapped to [0,255].</li>
<li>If the mat is 32-bit floating-point, the pixel values are multiplied by 255. That is,<br>the value range [0,1] is mapped to [0,255].</li>
</ul>
<p>@param canvasSource  canvas element or id.<br>@param mat           mat to be shown.</p>
<p>The above code of image reading and showing could be simplified as below.<br>@code{.js}<br>let img &#x3D; cv.imread(imageSource);<br>cv.imshow(canvasOutput, img);<br>img.delete();<br>@endcode</p>
<h2 id="Try-it"><a href="#Try-it" class="headerlink" title="Try it"></a>Try it</h2><p>\htmlonly</p>
<iframe src="../../js_image_display.html" width="100%"
        onload="this.style.height=this.contentDocument.body.scrollHeight +'px';">
</iframe>
\endhtmlonly
