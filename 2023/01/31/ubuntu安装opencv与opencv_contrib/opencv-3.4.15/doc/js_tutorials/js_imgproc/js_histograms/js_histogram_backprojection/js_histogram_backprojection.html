<h1 id="Histogram-3-Histogram-Backprojection-tutorial-js-histogram-backprojection"><a href="#Histogram-3-Histogram-Backprojection-tutorial-js-histogram-backprojection" class="headerlink" title="Histogram - 3 : Histogram Backprojection {#tutorial_js_histogram_backprojection}"></a>Histogram - 3 : Histogram Backprojection {#tutorial_js_histogram_backprojection}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><ul>
<li>We will learn about histogram backprojection.</li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>It was proposed by <strong>Michael J. Swain , Dana H. Ballard</strong> in their paper <strong>Indexing via color<br>histograms</strong>.</p>
<p><strong>What is it actually in simple words?</strong> It is used for image segmentation or finding objects of<br>interest in an image. In simple words, it creates an image of the same size (but single channel) as<br>that of our input image, where each pixel corresponds to the probability of that pixel belonging to<br>our object. In more simpler worlds, the output image will have our object of interest in more white<br>compared to remaining part. Well, that is an intuitive explanation. (I can’t make it more simpler).<br>Histogram Backprojection is used with camshift algorithm etc.</p>
<p><strong>How do we do it ?</strong> We create a histogram of an image containing our object of interest (in our<br>case, the ground, leaving player and other things). The object should fill the image as far as<br>possible for better results. And a color histogram is preferred over grayscale histogram, because<br>color of the object is a better way to define the object than its grayscale intensity. We then<br>“back-project” this histogram over our test image where we need to find the object, ie in other<br>words, we calculate the probability of every pixel belonging to the ground and show it. The<br>resulting output on proper thresholding gives us the ground alone.</p>
<h2 id="Backprojection-in-OpenCV"><a href="#Backprojection-in-OpenCV" class="headerlink" title="Backprojection in OpenCV"></a>Backprojection in OpenCV</h2><p>We use the functions: <strong>cv.calcBackProject (images, channels, hist, dst, ranges, scale)</strong></p>
<p>@param images       source arrays. They all should have the same depth, cv.CV_8U, cv.CV_16U or cv.CV_32F , and the same size. Each of them can have an arbitrary number of channels.<br>@param channels     the list of channels used to compute the back projection. The number of channels must match the histogram dimensionality.<br>@param hist         input histogram that can be dense or sparse.<br>@param dst          destination back projection array that is a single-channel array of the same size and depth as images[0].<br>@param ranges       array of arrays of the histogram bin boundaries in each dimension(see cv.calcHist).<br>@param scale        optional scale factor for the output back projection.</p>
<p><strong>cv.normalize (src, dst, alpha &#x3D; 1, beta &#x3D; 0, norm_type &#x3D; cv.NORM_L2, dtype &#x3D; -1, mask &#x3D; new cv.Mat())</strong></p>
<p>@param src        input array.<br>@param dst        output array of the same size as src .<br>@param alpha      norm value to normalize to or the lower range boundary in case of the range normalization.<br>@param beta       upper range boundary in case of the range normalization; it is not used for the norm normalization.<br>@param norm_type  normalization type (see cv.NormTypes).<br>@param dtype      when negative, the output array has the same type as src; otherwise, it has the same number of channels as src and the depth &#x3D; CV_MAT_DEPTH(dtype).<br>@param mask       optional operation mask.</p>
<h2 id="Try-it"><a href="#Try-it" class="headerlink" title="Try it"></a>Try it</h2><p>\htmlonly</p>
<iframe src="../../js_histogram_backprojection_calcBackProject.html" width="100%"
        onload="this.style.height=this.contentDocument.body.scrollHeight +'px';">
</iframe>
\endhtmlonly