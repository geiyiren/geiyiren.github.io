<h1 id="Hough-Line-Transform-tutorial-js-houghlines"><a href="#Hough-Line-Transform-tutorial-js-houghlines" class="headerlink" title="Hough Line Transform {#tutorial_js_houghlines}"></a>Hough Line Transform {#tutorial_js_houghlines}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><ul>
<li>We will understand the concept of the Hough Transform.</li>
<li>We will learn how to use it to detect lines in an image.</li>
<li>We will learn the following functions: <strong>cv.HoughLines()</strong>, <strong>cv.HoughLinesP()</strong></li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>The Hough Transform is a popular technique to detect any shape, if you can represent that shape in a<br>mathematical form. It can detect the shape even if it is broken or distorted a little bit. We will<br>see how it works for a line.</p>
<p>A line can be represented as \f$y &#x3D; mx+c\f$ or in a parametric form, as<br>\f$\rho &#x3D; x \cos \theta + y \sin \theta\f$ where \f$\rho\f$ is the perpendicular distance from the origin to the<br>line, and \f$\theta\f$ is the angle formed by this perpendicular line and the horizontal axis measured in<br>counter-clockwise (That direction varies on how you represent the coordinate system. This<br>representation is used in OpenCV). Check the image below:</p>
<p><img src="/images/houghlines1.svg" alt="image"></p>
<p>So if the line is passing below the origin, it will have a positive rho and an angle less than 180. If it<br>is going above the origin, instead of taking an angle greater than 180, the angle is taken less than 180,<br>and rho is taken negative. Any vertical line will have 0 degree and horizontal lines will have 90<br>degree.</p>
<p>Now let’s see how the Hough Transform works for lines. Any line can be represented in these two terms,<br>\f$(\rho, \theta)\f$. So first it creates a 2D array or accumulator (to hold the values of the two parameters)<br>and it is set to 0 initially. Let rows denote the \f$\rho\f$ and columns denote the \f$\theta\f$. Size of<br>array depends on the accuracy you need. Suppose you want the accuracy of angles to be 1 degree, you will<br>need 180 columns. For \f$\rho\f$, the maximum distance possible is the diagonal length of the image. So<br>taking one pixel accuracy, the number of rows can be the diagonal length of the image.</p>
<p>Consider a 100x100 image with a horizontal line at the middle. Take the first point of the line. You<br>know its (x,y) values. Now in the line equation, put the values \f$\theta &#x3D; 0,1,2,….,180\f$ and check<br>the \f$\rho\f$ you get. For every \f$(\rho, \theta)\f$ pair, you increment value by one in our accumulator<br>in its corresponding \f$(\rho, \theta)\f$ cells. So now in accumulator, the cell (50,90) &#x3D; 1 along with<br>some other cells.</p>
<p>Now take the second point on the line. Do the same as above. Increment the values in the cells<br>corresponding to \f$(\rho, \theta)\f$ you got. This time, the cell (50,90) &#x3D; 2. What you actually<br>do is voting the \f$(\rho, \theta)\f$ values. You continue this process for every point on the line. At<br>each point, the cell (50,90) will be incremented or voted up, while other cells may or may not be<br>voted up. This way, at the end, the cell (50,90) will have maximum votes. So if you search the<br>accumulator for maximum votes, you get the value (50,90) which says, there is a line in this image<br>at a distance 50 from the origin and at angle 90 degrees. It is well shown in the below animation (Image<br>Courtesy: <a href="http://homepages.inf.ed.ac.uk/amos/hough.html">Amos Storkey</a> )</p>
<p><img src="/houghlinesdemo.gif"></p>
<p>This is how hough transform works for lines. It is simple. Below is an image which shows the accumulator. Bright spots at some locations<br>denote they are the parameters of possible lines in the image. (Image courtesy: <a href="http://en.wikipedia.org/wiki/Hough_transform">Wikipedia</a> )</p>
<p><img src="/houghlines2.jpg"></p>
<h1 id="Hough-Transform-in-OpenCV"><a href="#Hough-Transform-in-OpenCV" class="headerlink" title="Hough Transform in OpenCV"></a>Hough Transform in OpenCV</h1><p>Everything explained above is encapsulated in the OpenCV function, <strong>cv.HoughLines()</strong>. It simply returns an array of (\f$(\rho, \theta)\f$ values. \f$\rho\f$ is measured in pixels and \f$\theta\f$ is measured in radians. First parameter,<br>Input image should be a binary image, so apply threshold or use canny edge detection before<br>applying hough transform.</p>
<p>We use the function: <strong>cv.HoughLines (image, lines, rho, theta, threshold, srn &#x3D; 0, stn &#x3D; 0, min_theta &#x3D; 0, max_theta &#x3D; Math.PI)</strong><br>@param image       8-bit, single-channel binary source image. The image may be modified by the function.<br>@param lines       output vector of lines(cv.32FC2 type). Each line is represented by a two-element vector (ρ,θ) . ρ is the distance from the coordinate origin (0,0). θ is the line rotation angle in radians.<br>@param rho    	   distance resolution of the accumulator in pixels.<br>@param theta       angle resolution of the accumulator in radians.<br>@param threshold   accumulator threshold parameter. Only those lines are returned that get enough votes<br>@param srn         for the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho&#x2F;srn . If both srn&#x3D;0 and stn&#x3D;0 , the classical Hough transform is used. Otherwise, both these parameters should be positive.<br>@param stn         for the multi-scale Hough transform, it is a divisor for the distance resolution theta.<br>@param min_theta   for standard and multi-scale Hough transform, minimum angle to check for lines. Must fall between 0 and max_theta.<br>@param max_theta   for standard and multi-scale Hough transform, maximum angle to check for lines. Must fall between min_theta and CV_PI.</p>
<h2 id="Try-it"><a href="#Try-it" class="headerlink" title="Try it"></a>Try it</h2><p>\htmlonly</p>
<iframe src="../../js_houghlines_HoughLines.html" width="100%"
        onload="this.style.height=this.contentDocument.body.scrollHeight +'px';">
</iframe>
\endhtmlonly

<h2 id="Probabilistic-Hough-Transform"><a href="#Probabilistic-Hough-Transform" class="headerlink" title="Probabilistic Hough Transform"></a>Probabilistic Hough Transform</h2><p>In the hough transform, you can see that even for a line with two arguments, it takes a lot of<br>computation. Probabilistic Hough Transform is an optimization of the Hough Transform we saw. It doesn’t<br>take all the points into consideration. Instead, it takes only a random subset of points which is<br>sufficient for line detection. Just we have to decrease the threshold. See image below which compares<br>Hough Transform and Probabilistic Hough Transform in Hough space. (Image Courtesy :<br><a href="http://phdfb1.free.fr/robot/mscthesis/node14.html">Franck Bettinger’s home page</a> )</p>
<p><img src="/images/houghlines4.png" alt="image"></p>
<p>OpenCV implementation is based on Robust Detection of Lines Using the Progressive Probabilistic<br>Hough Transform by Matas, J. and Galambos, C. and Kittler, J.V. @cite Matas00.</p>
<p>We use the function: <strong>cv.HoughLinesP (image, lines, rho, theta, threshold, minLineLength &#x3D; 0, maxLineGap &#x3D; 0)</strong></p>
<p>@param image          8-bit, single-channel binary source image. The image may be modified by the function.<br>@param lines          output vector of lines(cv.32SC4 type). Each line is represented by a 4-element vector (x1,y1,x2,y2) ,where (x1,y1) and (x2,y2) are the ending points of each detected line segment.<br>@param rho            distance resolution of the accumulator in pixels.<br>@param theta          angle resolution of the accumulator in radians.<br>@param threshold      accumulator threshold parameter. Only those lines are returned that get enough votes<br>@param minLineLength  minimum line length. Line segments shorter than that are rejected.<br>@param maxLineGap     maximum allowed gap between points on the same line to link them.</p>
<h2 id="Try-it-1"><a href="#Try-it-1" class="headerlink" title="Try it"></a>Try it</h2><p>\htmlonly</p>
<iframe src="../../js_houghlines_HoughLinesP.html" width="100%"
        onload="this.style.height=this.contentDocument.body.scrollHeight +'px';">
</iframe>
\endhtmlonly