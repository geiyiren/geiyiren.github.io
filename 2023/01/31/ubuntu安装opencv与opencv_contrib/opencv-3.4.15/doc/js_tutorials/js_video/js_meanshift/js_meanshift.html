<h1 id="Meanshift-and-Camshift-tutorial-js-meanshift"><a href="#Meanshift-and-Camshift-tutorial-js-meanshift" class="headerlink" title="Meanshift and Camshift {#tutorial_js_meanshift}"></a>Meanshift and Camshift {#tutorial_js_meanshift}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><ul>
<li>We will learn about Meanshift and Camshift algorithms to find and track objects in videos.</li>
</ul>
<h2 id="Meanshift"><a href="#Meanshift" class="headerlink" title="Meanshift"></a>Meanshift</h2><p>The intuition behind the meanshift is simple. Consider you have a set of points. (It can be a pixel<br>distribution like histogram backprojection). You are given a small window ( may be a circle) and you<br>have to move that window to the area of maximum pixel density (or maximum number of points). It is<br>illustrated in the simple image given below:</p>
<p><img src="/images/meanshift_basics.jpg" alt="image"></p>
<p>The initial window is shown in blue circle with the name “C1”. Its original center is marked in blue<br>rectangle, named “C1_o”. But if you find the centroid of the points inside that window, you will<br>get the point “C1_r” (marked in small blue circle) which is the real centroid of window. Surely<br>they don’t match. So move your window such that circle of the new window matches with previous<br>centroid. Again find the new centroid. Most probably, it won’t match. So move it again, and continue<br>the iterations such that center of window and its centroid falls on the same location (or with a<br>small desired error). So finally what you obtain is a window with maximum pixel distribution. It is<br>marked with green circle, named “C2”. As you can see in image, it has maximum number of points. The<br>whole process is demonstrated on a static image below:</p>
<p><img src="/images/meanshift_face.gif" alt="image"></p>
<p>So we normally pass the histogram backprojected image and initial target location. When the object<br>moves, obviously the movement is reflected in histogram backprojected image. As a result, meanshift<br>algorithm moves our window to the new location with maximum density.</p>
<h3 id="Meanshift-in-OpenCV-js"><a href="#Meanshift-in-OpenCV-js" class="headerlink" title="Meanshift in OpenCV.js"></a>Meanshift in OpenCV.js</h3><p>To use meanshift in OpenCV.js, first we need to setup the target, find its histogram so that we can<br>backproject the target on each frame for calculation of meanshift. We also need to provide initial<br>location of window. For histogram, only Hue is considered here. Also, to avoid false values due to<br>low light, low light values are discarded using <strong>cv.inRange()</strong> function.</p>
<p>We use the function: <strong>cv.meanShift (probImage, window, criteria)</strong><br>@param probImage     Back projection of the object histogram. See cv.calcBackProject for details.<br>@param window        Initial search window.<br>@param criteria      Stop criteria for the iterative search algorithm.<br>@return              number of iterations meanShift took to converge and the new location</p>
<h3 id="Try-it"><a href="#Try-it" class="headerlink" title="Try it"></a>Try it</h3><p>\htmlonly</p>
<iframe src="../../js_meanshift.html" width="100%"
        onload="this.style.height=this.contentDocument.body.scrollHeight +'px';">
</iframe>
\endhtmlonly

<h2 id="Camshift"><a href="#Camshift" class="headerlink" title="Camshift"></a>Camshift</h2><p>Did you closely watch the last result? There is a problem. Our window always has the same size when<br>the object is farther away and it is very close to camera. That is not good. We need to adapt the window<br>size with size and rotation of the target. Once again, the solution came from “OpenCV Labs” and it<br>is called CAMshift (Continuously Adaptive Meanshift) published by Gary Bradsky in his paper<br>“Computer Vision Face Tracking for Use in a Perceptual User Interface” in 1988.</p>
<p>It applies meanshift first. Once meanshift converges, it updates the size of the window as,<br>\f$s &#x3D; 2 \times \sqrt{\frac{M_{00}}{256}}\f$. It also calculates the orientation of best fitting ellipse<br>to it. Again it applies the meanshift with new scaled search window and previous window location.<br>The process is continued until required accuracy is met.</p>
<p><img src="/images/camshift_face.gif" alt="image"></p>
<h3 id="Camshift-in-OpenCV-js"><a href="#Camshift-in-OpenCV-js" class="headerlink" title="Camshift in OpenCV.js"></a>Camshift in OpenCV.js</h3><p>It is almost same as meanshift, but it returns a rotated rectangle (that is our result) and box<br>parameters (used to be passed as search window in next iteration).</p>
<p>We use the function: <strong>cv.CamShift (probImage, window, criteria)</strong><br>@param probImage     Back projection of the object histogram. See cv.calcBackProject for details.<br>@param window        Initial search window.<br>@param criteria      Stop criteria for the iterative search algorithm.<br>@return              Rotated rectangle and the new search window</p>
<h3 id="Try-it-1"><a href="#Try-it-1" class="headerlink" title="Try it"></a>Try it</h3><p>\htmlonly</p>
<iframe src="../../js_camshift.html" width="100%"
        onload="this.style.height=this.contentDocument.body.scrollHeight +'px';">
</iframe>
\endhtmlonly

<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><p>-#  French Wikipedia page on <a href="http://fr.wikipedia.org/wiki/Camshift">Camshift</a>. (The two animations<br>    are taken from here)<br>2.  Bradski, G.R., “Real time face and object tracking as a component of a perceptual user<br>    interface,” Applications of Computer Vision, 1998. WACV ‘98. Proceedings., Fourth IEEE Workshop<br>    on , vol., no., pp.214,219, 19-21 Oct 1998</p>
