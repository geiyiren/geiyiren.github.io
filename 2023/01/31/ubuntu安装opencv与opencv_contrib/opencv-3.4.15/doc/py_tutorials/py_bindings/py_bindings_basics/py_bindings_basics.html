<h1 id="How-OpenCV-Python-Bindings-Works-tutorial-py-bindings-basics"><a href="#How-OpenCV-Python-Bindings-Works-tutorial-py-bindings-basics" class="headerlink" title="How OpenCV-Python Bindings Works? {#tutorial_py_bindings_basics}"></a>How OpenCV-Python Bindings Works? {#tutorial_py_bindings_basics}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>Learn:</p>
<ul>
<li>How OpenCV-Python bindings are generated?</li>
<li>How to extend new OpenCV modules to Python?</li>
</ul>
<h2 id="How-OpenCV-Python-bindings-are-generated"><a href="#How-OpenCV-Python-bindings-are-generated" class="headerlink" title="How OpenCV-Python bindings are generated?"></a>How OpenCV-Python bindings are generated?</h2><p>In OpenCV, all algorithms are implemented in C++. But these algorithms can be used from different<br>languages like Python, Java etc. This is made possible by the bindings generators. These generators<br>create a bridge between C++ and Python which enables users to call C++ functions from Python. To get<br>a complete picture of what is happening in background, a good knowledge of Python&#x2F;C API is required.<br>A simple example on extending C++ functions to Python can be found in official Python<br>documentation[1]. So extending all functions in OpenCV to Python by writing their wrapper functions<br>manually is a time-consuming task. So OpenCV does it in a more intelligent way. OpenCV generates<br>these wrapper functions automatically from the C++ headers using some Python scripts which are<br>located in modules&#x2F;python&#x2F;src2. We will look into what they do.</p>
<p>First, modules&#x2F;python&#x2F;CMakeFiles.txt is a CMake script which checks the modules to be extended to<br>Python. It will automatically check all the modules to be extended and grab their header files.<br>These header files contain list of all classes, functions, constants etc. for that particular<br>modules.</p>
<p>Second, these header files are passed to a Python script, modules&#x2F;python&#x2F;src2&#x2F;gen2.py. This is the<br>Python bindings generator script. It calls another Python script modules&#x2F;python&#x2F;src2&#x2F;hdr_parser.py.<br>This is the header parser script. This header parser splits the complete header file into small<br>Python lists. So these lists contain all details about a particular function, class etc. For<br>example, a function will be parsed to get a list containing function name, return type, input<br>arguments, argument types etc. Final list contains details of all the functions, structs, classes<br>etc. in that header file.</p>
<p>But header parser doesn’t parse all the functions&#x2F;classes in the header file. The developer has to<br>specify which functions should be exported to Python. For that, there are certain macros added to<br>the beginning of these declarations which enables the header parser to identify functions to be<br>parsed. These macros are added by the developer who programs the particular function. In short, the<br>developer decides which functions should be extended to Python and which are not. Details of those<br>macros will be given in next session.</p>
<p>So header parser returns a final big list of parsed functions. Our generator script (gen2.py) will<br>create wrapper functions for all the functions&#x2F;classes&#x2F;enums&#x2F;structs parsed by header parser (You<br>can find these header files during compilation in the build&#x2F;modules&#x2F;python&#x2F; folder as<br>pyopencv_generated_*.h files). But there may be some basic OpenCV datatypes like Mat, Vec4i,<br>Size. They need to be extended manually. For example, a Mat type should be extended to Numpy array,<br>Size should be extended to a tuple of two integers etc. Similarly, there may be some complex<br>structs&#x2F;classes&#x2F;functions etc. which need to be extended manually. All such manual wrapper functions<br>are placed in modules&#x2F;python&#x2F;src2&#x2F;cv2.cpp.</p>
<p>So now only thing left is the compilation of these wrapper files which gives us <strong>cv2</strong> module. So<br>when you call a function, say res &#x3D; equalizeHist(img1,img2) in Python, you pass two numpy arrays and<br>you expect another numpy array as the output. So these numpy arrays are converted to cv::Mat and<br>then calls the equalizeHist() function in C++. Final result, res will be converted back into a Numpy<br>array. So in short, almost all operations are done in C++ which gives us almost same speed as that<br>of C++.</p>
<p>So this is the basic version of how OpenCV-Python bindings are generated.</p>
<h2 id="How-to-extend-new-modules-to-Python"><a href="#How-to-extend-new-modules-to-Python" class="headerlink" title="How to extend new modules to Python?"></a>How to extend new modules to Python?</h2><p>Header parser parse the header files based on some wrapper macros added to function declaration.<br>Enumeration constants don’t need any wrapper macros. They are automatically wrapped. But remaining<br>functions, classes etc. need wrapper macros.</p>
<p>Functions are extended using CV_EXPORTS_W macro. An example is shown below.<br>@code{.cpp}<br>CV_EXPORTS_W void equalizeHist( InputArray src, OutputArray dst );<br>@endcode<br>Header parser can understand the input and output arguments from keywords like<br>InputArray, OutputArray etc. But sometimes, we may need to hardcode inputs and outputs. For that,<br>macros like CV_OUT, CV_IN_OUT etc. are used.<br>@code{.cpp}<br>CV_EXPORTS_W void minEnclosingCircle( InputArray points,<br>                                     CV_OUT Point2f&amp; center, CV_OUT float&amp; radius );<br>@endcode<br>For large classes also, CV_EXPORTS_W is used. To extend class methods, CV_WRAP is used.<br>Similarly, CV_PROP is used for class fields.<br>@code{.cpp}<br>class CV_EXPORTS_W CLAHE : public Algorithm<br>{<br>public:<br>    CV_WRAP virtual void apply(InputArray src, OutputArray dst) &#x3D; 0;</p>
<pre><code>CV_WRAP virtual void setClipLimit(double clipLimit) = 0;
CV_WRAP virtual double getClipLimit() const = 0;
</code></pre>
<p>}<br>@endcode<br>Overloaded functions can be extended using CV_EXPORTS_AS. But we need to pass a new name so that<br>each function will be called by that name in Python. Take the case of integral function below. Three<br>functions are available, so each one is named with a suffix in Python. Similarly CV_WRAP_AS can be<br>used to wrap overloaded methods.<br>@code{.cpp}<br>&#x2F;&#x2F;! computes the integral image<br>CV_EXPORTS_W void integral( InputArray src, OutputArray sum, int sdepth &#x3D; -1 );</p>
<p>&#x2F;&#x2F;! computes the integral image and integral for the squared image<br>CV_EXPORTS_AS(integral2) void integral( InputArray src, OutputArray sum,<br>                                        OutputArray sqsum, int sdepth &#x3D; -1, int sqdepth &#x3D; -1 );</p>
<p>&#x2F;&#x2F;! computes the integral image, integral for the squared image and the tilted integral image<br>CV_EXPORTS_AS(integral3) void integral( InputArray src, OutputArray sum,<br>                                        OutputArray sqsum, OutputArray tilted,<br>                                        int sdepth &#x3D; -1, int sqdepth &#x3D; -1 );<br>@endcode<br>Small classes&#x2F;structs are extended using CV_EXPORTS_W_SIMPLE. These structs are passed by value<br>to C++ functions. Examples are KeyPoint, Match etc. Their methods are extended by CV_WRAP and<br>fields are extended by CV_PROP_RW.<br>@code{.cpp}<br>class CV_EXPORTS_W_SIMPLE DMatch<br>{<br>public:<br>    CV_WRAP DMatch();<br>    CV_WRAP DMatch(int _queryIdx, int _trainIdx, float _distance);<br>    CV_WRAP DMatch(int _queryIdx, int _trainIdx, int _imgIdx, float _distance);</p>
<pre><code>CV_PROP_RW int queryIdx; // query descriptor index
CV_PROP_RW int trainIdx; // train descriptor index
CV_PROP_RW int imgIdx;   // train image index

CV_PROP_RW float distance;
</code></pre>
<p>};<br>@endcode<br>Some other small classes&#x2F;structs can be exported using CV_EXPORTS_W_MAP where it is exported to a<br>Python native dictionary. Moments() is an example of it.<br>@code{.cpp}<br>class CV_EXPORTS_W_MAP Moments<br>{<br>public:<br>    &#x2F;&#x2F;! spatial moments<br>    CV_PROP_RW double  m00, m10, m01, m20, m11, m02, m30, m21, m12, m03;<br>    &#x2F;&#x2F;! central moments<br>    CV_PROP_RW double  mu20, mu11, mu02, mu30, mu21, mu12, mu03;<br>    &#x2F;&#x2F;! central normalized moments<br>    CV_PROP_RW double  nu20, nu11, nu02, nu30, nu21, nu12, nu03;<br>};<br>@endcode<br>So these are the major extension macros available in OpenCV. Typically, a developer has to put<br>proper macros in their appropriate positions. Rest is done by generator scripts. Sometimes, there<br>may be an exceptional cases where generator scripts cannot create the wrappers. Such functions need<br>to be handled manually, to do this write your own pyopencv_*.hpp extending headers and put them into<br>misc&#x2F;python subdirectory of your module. But most of the time, a code written according to OpenCV<br>coding guidelines will be automatically wrapped by generator scripts.</p>
