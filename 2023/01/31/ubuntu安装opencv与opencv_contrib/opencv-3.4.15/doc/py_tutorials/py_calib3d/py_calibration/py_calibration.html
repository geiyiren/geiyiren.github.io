<h1 id="Camera-Calibration-tutorial-py-calibration"><a href="#Camera-Calibration-tutorial-py-calibration" class="headerlink" title="Camera Calibration {#tutorial_py_calibration}"></a>Camera Calibration {#tutorial_py_calibration}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this section, we will learn about</p>
<ul>
<li>types of distortion caused by cameras</li>
<li>how to find the intrinsic and extrinsic properties of a camera</li>
<li>how to undistort images based off these properties</li>
</ul>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>Some pinhole cameras introduce significant distortion to images. Two major kinds of distortion are<br>radial distortion and tangential distortion.</p>
<p>Radial distortion causes straight lines to appear curved. Radial distortion becomes larger the farther points are from<br>the center of the image. For example, one image is shown below in which two edges of a chess board are<br>marked with red lines. But, you can see that the border of the chess board is not a straight line and doesn’t match with the<br>red line. All the expected straight lines are bulged out. Visit <a href="http://en.wikipedia.org/wiki/Distortion_%28optics%29">Distortion<br>(optics)</a> for more details.</p>
<p><img src="/images/calib_radial.jpg" alt="image"></p>
<p>Radial distortion can be represented as follows:</p>
<p>\f[x_{distorted} &#x3D; x( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6) \<br>y_{distorted} &#x3D; y( 1 + k_1 r^2 + k_2 r^4 + k_3 r^6)\f]</p>
<p>Similarly, tangential distortion occurs because the image-taking lense<br>is not aligned perfectly parallel to the imaging plane. So, some areas in the image may look nearer than<br>expected. The amount of tangential distortion can be represented as below:</p>
<p>\f[x_{distorted} &#x3D; x + [ 2p_1xy + p_2(r^2+2x^2)] \<br>y_{distorted} &#x3D; y + [ p_1(r^2+ 2y^2)+ 2p_2xy]\f]</p>
<p>In short, we need to find five parameters, known as distortion coefficients given by:</p>
<p>\f[Distortion ; coefficients&#x3D;(k_1 \hspace{10pt} k_2 \hspace{10pt} p_1 \hspace{10pt} p_2 \hspace{10pt} k_3)\f]</p>
<p>In addition to this, we need to some other information, like the intrinsic and extrinsic parameters<br>of the camera. Intrinsic parameters are specific to a camera. They include information like focal<br>length (\f$f_x,f_y\f$) and optical centers (\f$c_x, c_y\f$). The focal length and optical centers can be used to create a camera matrix, which can be used to remove distortion due to the lenses of a specific camera.  The camera matrix is unique to a specific camera, so once calculated, it can be reused on other images taken by the same camera. It is expressed as a 3x3<br>matrix:</p>
<p>\f[camera ; matrix &#x3D; \left [ \begin{matrix}   f_x &amp; 0 &amp; c_x \  0 &amp; f_y &amp; c_y \   0 &amp; 0 &amp; 1 \end{matrix} \right ]\f]</p>
<p>Extrinsic parameters corresponds to rotation and translation vectors which translates a coordinates<br>of a 3D point to a coordinate system.</p>
<p>For stereo applications, these distortions need to be corrected first. To find these parameters,<br>we must provide some sample images of a well defined pattern (e.g. a chess board). We<br>find some specific points of which we already know the relative positions (e.g. square corners in the chess board). We know the coordinates of these points in real world space and we know the coordinates in the image, so we can solve for the distortion coefficients. For better results, we need at least 10 test patterns.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>As mentioned above, we need at least 10 test patterns for camera calibration. OpenCV comes with some<br>images of a chess board (see samples&#x2F;data&#x2F;left01.jpg – left14.jpg), so we will utilize these. Consider an image of a chess board. The important input data needed for calibration of the camera<br>is the set of 3D real world points and the corresponding 2D coordinates of these points in the image. 2D image points<br>are OK which we can easily find from the image. (These image points are locations where two black<br>squares touch each other in chess boards)</p>
<p>What about the 3D points from real world space? Those images are taken from a static camera and<br>chess boards are placed at different locations and orientations. So we need to know \f$(X,Y,Z)\f$<br>values. But for simplicity, we can say chess board was kept stationary at XY plane, (so Z&#x3D;0 always)<br>and camera was moved accordingly. This consideration helps us to find only X,Y values. Now for X,Y<br>values, we can simply pass the points as (0,0), (1,0), (2,0), … which denotes the location of<br>points. In this case, the results we get will be in the scale of size of chess board square. But if<br>we know the square size, (say 30 mm), we can pass the values as (0,0), (30,0), (60,0), … .  Thus, we get<br>the results in mm. (In this case, we don’t know square size since we didn’t take those images, so we<br>pass in terms of square size).</p>
<p>3D points are called <strong>object points</strong> and 2D image points are called <strong>image points.</strong></p>
<h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>So to find pattern in chess board, we can use the function, <strong>cv.findChessboardCorners()</strong>. We also<br>need to pass what kind of pattern we are looking for, like 8x8 grid, 5x5 grid etc. In this example, we<br>use 7x6 grid. (Normally a chess board has 8x8 squares and 7x7 internal corners). It returns the<br>corner points and retval which will be True if pattern is obtained. These corners will be placed in<br>an order (from left-to-right, top-to-bottom)</p>
<p>@note This function may not be able to find the required pattern in all the images. So, one good option<br>is to write the code such that, it starts the camera and check each frame for required pattern. Once<br>the pattern is obtained, find the corners and store it in a list. Also, provide some interval before<br>reading next frame so that we can adjust our chess board in different direction. Continue this<br>process until the required number of good patterns are obtained. Even in the example provided here, we<br>are not sure how many images out of the 14 given are good.  Thus, we must read all the images and take only the good<br>ones.</p>
<p>@note Instead of chess board, we can alternatively use a circular grid.  In this case, we must use the function<br><strong>cv.findCirclesGrid()</strong> to find the pattern. Fewer images are sufficient to perform camera calibration using a circular grid.</p>
<p>Once we find the corners, we can increase their accuracy using <strong>cv.cornerSubPix()</strong>. We can also<br>draw the pattern using <strong>cv.drawChessboardCorners()</strong>. All these steps are included in below code:</p>
<p>@code{.py}<br>import numpy as np<br>import cv2 as cv<br>import glob</p>
<h1 id="termination-criteria"><a href="#termination-criteria" class="headerlink" title="termination criteria"></a>termination criteria</h1><p>criteria &#x3D; (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 30, 0.001)</p>
<h1 id="prepare-object-points-like-0-0-0-1-0-0-2-0-0-…-6-5-0"><a href="#prepare-object-points-like-0-0-0-1-0-0-2-0-0-…-6-5-0" class="headerlink" title="prepare object points, like (0,0,0), (1,0,0), (2,0,0) ….,(6,5,0)"></a>prepare object points, like (0,0,0), (1,0,0), (2,0,0) ….,(6,5,0)</h1><p>objp &#x3D; np.zeros((6*7,3), np.float32)<br>objp[:,:2] &#x3D; np.mgrid[0:7,0:6].T.reshape(-1,2)</p>
<h1 id="Arrays-to-store-object-points-and-image-points-from-all-the-images"><a href="#Arrays-to-store-object-points-and-image-points-from-all-the-images" class="headerlink" title="Arrays to store object points and image points from all the images."></a>Arrays to store object points and image points from all the images.</h1><p>objpoints &#x3D; [] # 3d point in real world space<br>imgpoints &#x3D; [] # 2d points in image plane.</p>
<p>images &#x3D; glob.glob(‘*.jpg’)</p>
<p>for fname in images:<br>    img &#x3D; cv.imread(fname)<br>    gray &#x3D; cv.cvtColor(img, cv.COLOR_BGR2GRAY)</p>
<pre><code># Find the chess board corners
ret, corners = cv.findChessboardCorners(gray, (7,6), None)

# If found, add object points, image points (after refining them)
if ret == True:
    objpoints.append(objp)

    corners2 = cv.cornerSubPix(gray,corners, (11,11), (-1,-1), criteria)
    imgpoints.append(corners)

    # Draw and display the corners
    cv.drawChessboardCorners(img, (7,6), corners2, ret)
    cv.imshow(&#39;img&#39;, img)
    cv.waitKey(500)
</code></pre>
<p>cv.destroyAllWindows()<br>@endcode<br>One image with pattern drawn on it is shown below:</p>
<p><img src="/images/calib_pattern.jpg" alt="image"></p>
<h3 id="Calibration"><a href="#Calibration" class="headerlink" title="Calibration"></a>Calibration</h3><p>Now that we have our object points and image points, we are ready to go for calibration. We can<br>use the function, <strong>cv.calibrateCamera()</strong> which returns the camera matrix, distortion coefficients,<br>rotation and translation vectors etc.<br>@code{.py}<br>ret, mtx, dist, rvecs, tvecs &#x3D; cv.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)<br>@endcode</p>
<h3 id="Undistortion"><a href="#Undistortion" class="headerlink" title="Undistortion"></a>Undistortion</h3><p>Now, we can take an image and undistort it. OpenCV comes with two<br>methods for doing this. However first, we can refine the camera matrix based on a free scaling<br>parameter using <strong>cv.getOptimalNewCameraMatrix()</strong>. If the scaling parameter alpha&#x3D;0, it returns<br>undistorted image with minimum unwanted pixels. So it may even remove some pixels at image corners.<br>If alpha&#x3D;1, all pixels are retained with some extra black images. This function also returns an image ROI which<br>can be used to crop the result.</p>
<p>So, we take a new image (left12.jpg in this case. That is the first image in this chapter)<br>@code{.py}<br>img &#x3D; cv.imread(‘left12.jpg’)<br>h,  w &#x3D; img.shape[:2]<br>newcameramtx, roi &#x3D; cv.getOptimalNewCameraMatrix(mtx, dist, (w,h), 1, (w,h))<br>@endcode</p>
<h4 id="1-Using-cv-undistort"><a href="#1-Using-cv-undistort" class="headerlink" title="1. Using cv.undistort()"></a>1. Using <strong>cv.undistort()</strong></h4><p>This is the easiest way. Just call the function and use ROI obtained above to crop the result.<br>@code{.py}</p>
<h1 id="undistort"><a href="#undistort" class="headerlink" title="undistort"></a>undistort</h1><p>dst &#x3D; cv.undistort(img, mtx, dist, None, newcameramtx)</p>
<h1 id="crop-the-image"><a href="#crop-the-image" class="headerlink" title="crop the image"></a>crop the image</h1><p>x, y, w, h &#x3D; roi<br>dst &#x3D; dst[y:y+h, x:x+w]<br>cv.imwrite(‘calibresult.png’, dst)<br>@endcode</p>
<h4 id="2-Using-remapping"><a href="#2-Using-remapping" class="headerlink" title="2. Using remapping"></a>2. Using <strong>remapping</strong></h4><p>This way is a little bit more difficult. First, find a mapping function from the distorted image to the undistorted image. Then<br>use the remap function.<br>@code{.py}</p>
<h1 id="undistort-1"><a href="#undistort-1" class="headerlink" title="undistort"></a>undistort</h1><p>mapx, mapy &#x3D; cv.initUndistortRectifyMap(mtx, dist, None, newcameramtx, (w,h), 5)<br>dst &#x3D; cv.remap(img, mapx, mapy, cv.INTER_LINEAR)</p>
<h1 id="crop-the-image-1"><a href="#crop-the-image-1" class="headerlink" title="crop the image"></a>crop the image</h1><p>x, y, w, h &#x3D; roi<br>dst &#x3D; dst[y:y+h, x:x+w]<br>cv.imwrite(‘calibresult.png’, dst)<br>@endcode<br>Still, both the methods give the same result. See the result below:</p>
<p><img src="/images/calib_result.jpg" alt="image"></p>
<p>You can see in the result that all the edges are straight.</p>
<p>Now you can store the camera matrix and distortion coefficients using write functions in NumPy<br>(np.savez, np.savetxt etc) for future uses.</p>
<h2 id="Re-projection-Error"><a href="#Re-projection-Error" class="headerlink" title="Re-projection Error"></a>Re-projection Error</h2><p>Re-projection error gives a good estimation of just how exact the found parameters are. The closer the re-projection error is to zero, the more accurate the parameters we found are. Given the intrinsic, distortion, rotation and translation matrices,<br>we must first transform the object point to image point using <strong>cv.projectPoints()</strong>. Then, we can calculate<br>the absolute norm between what we got with our transformation and the corner finding algorithm. To<br>find the average error, we calculate the arithmetical mean of the errors calculated for all the<br>calibration images.<br>@code{.py}<br>mean_error &#x3D; 0<br>for i in range(len(objpoints)):<br>    imgpoints2, _ &#x3D; cv.projectPoints(objpoints[i], rvecs[i], tvecs[i], mtx, dist)<br>    error &#x3D; cv.norm(imgpoints[i], imgpoints2, cv.NORM_L2)&#x2F;len(imgpoints2)<br>    mean_error +&#x3D; error</p>
<h2 id="print-“total-error-”-format-mean-error-x2F-len-objpoints-endcodeAdditional-Resources"><a href="#print-“total-error-”-format-mean-error-x2F-len-objpoints-endcodeAdditional-Resources" class="headerlink" title="print( “total error: {}”.format(mean_error&#x2F;len(objpoints)) )@endcodeAdditional Resources"></a>print( “total error: {}”.format(mean_error&#x2F;len(objpoints)) )<br>@endcode<br>Additional Resources</h2><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><p>-#  Try camera calibration with circular grid.</p>
