<h1 id="Pose-Estimation-tutorial-py-pose"><a href="#Pose-Estimation-tutorial-py-pose" class="headerlink" title="Pose Estimation {#tutorial_py_pose}"></a>Pose Estimation {#tutorial_py_pose}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this section,<br>    -   We will learn to exploit calib3d module to create some 3D effects in images.</p>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>This is going to be a small section. During the last session on camera calibration, you have found<br>the camera matrix, distortion coefficients etc. Given a pattern image, we can utilize the above<br>information to calculate its pose, or how the object is situated in space, like how it is rotated,<br>how it is displaced etc. For a planar object, we can assume Z&#x3D;0, such that, the problem now becomes<br>how camera is placed in space to see our pattern image. So, if we know how the object lies in the<br>space, we can draw some 2D diagrams in it to simulate the 3D effect. Let’s see how to do it.</p>
<p>Our problem is, we want to draw our 3D coordinate axis (X, Y, Z axes) on our chessboard’s first<br>corner. X axis in blue color, Y axis in green color and Z axis in red color. So in-effect, Z axis<br>should feel like it is perpendicular to our chessboard plane.</p>
<p>First, let’s load the camera matrix and distortion coefficients from the previous calibration<br>result.<br>@code{.py}<br>import numpy as np<br>import cv2 as cv<br>import glob</p>
<h1 id="Load-previously-saved-data"><a href="#Load-previously-saved-data" class="headerlink" title="Load previously saved data"></a>Load previously saved data</h1><p>with np.load(‘B.npz’) as X:<br>    mtx, dist, _, _ &#x3D; [X[i] for i in (‘mtx’,’dist’,’rvecs’,’tvecs’)]<br>@endcode<br>Now let’s create a function, draw which takes the corners in the chessboard (obtained using<br><strong>cv.findChessboardCorners()</strong>) and <strong>axis points</strong> to draw a 3D axis.<br>@code{.py}<br>def draw(img, corners, imgpts):<br>    corner &#x3D; tuple(corners[0].ravel())<br>    img &#x3D; cv.line(img, corner, tuple(imgpts[0].ravel()), (255,0,0), 5)<br>    img &#x3D; cv.line(img, corner, tuple(imgpts[1].ravel()), (0,255,0), 5)<br>    img &#x3D; cv.line(img, corner, tuple(imgpts[2].ravel()), (0,0,255), 5)<br>    return img<br>@endcode<br>Then as in previous case, we create termination criteria, object points (3D points of corners in<br>chessboard) and axis points. Axis points are points in 3D space for drawing the axis. We draw axis<br>of length 3 (units will be in terms of chess square size since we calibrated based on that size). So<br>our X axis is drawn from (0,0,0) to (3,0,0), so for Y axis. For Z axis, it is drawn from (0,0,0) to<br>(0,0,-3). Negative denotes it is drawn towards the camera.<br>@code{.py}<br>criteria &#x3D; (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 30, 0.001)<br>objp &#x3D; np.zeros((6*7,3), np.float32)<br>objp[:,:2] &#x3D; np.mgrid[0:7,0:6].T.reshape(-1,2)</p>
<p>axis &#x3D; np.float32([[3,0,0], [0,3,0], [0,0,-3]]).reshape(-1,3)<br>@endcode<br>Now, as usual, we load each image. Search for 7x6 grid. If found, we refine it with subcorner<br>pixels. Then to calculate the rotation and translation, we use the function,<br><strong>cv.solvePnPRansac()</strong>. Once we those transformation matrices, we use them to project our <strong>axis<br>points</strong> to the image plane. In simple words, we find the points on image plane corresponding to<br>each of (3,0,0),(0,3,0),(0,0,3) in 3D space. Once we get them, we draw lines from the first corner<br>to each of these points using our draw() function. Done !!!<br>@code{.py}<br>for fname in glob.glob(‘left*.jpg’):<br>    img &#x3D; cv.imread(fname)<br>    gray &#x3D; cv.cvtColor(img,cv.COLOR_BGR2GRAY)<br>    ret, corners &#x3D; cv.findChessboardCorners(gray, (7,6),None)</p>
<pre><code>if ret == True:
    corners2 = cv.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)

    # Find the rotation and translation vectors.
    ret,rvecs, tvecs = cv.solvePnP(objp, corners2, mtx, dist)

    # project 3D points to image plane
    imgpts, jac = cv.projectPoints(axis, rvecs, tvecs, mtx, dist)

    img = draw(img,corners2,imgpts)
    cv.imshow(&#39;img&#39;,img)
    k = cv.waitKey(0) &amp; 0xFF
    if k == ord(&#39;s&#39;):
        cv.imwrite(fname[:6]+&#39;.png&#39;, img)
</code></pre>
<p>cv.destroyAllWindows()<br>@endcode<br>See some results below. Notice that each axis is 3 squares long.:</p>
<p><img src="/images/pose_1.jpg" alt="image"></p>
<h3 id="Render-a-Cube"><a href="#Render-a-Cube" class="headerlink" title="Render a Cube"></a>Render a Cube</h3><p>If you want to draw a cube, modify the draw() function and axis points as follows.</p>
<p>Modified draw() function:<br>@code{.py}<br>def draw(img, corners, imgpts):<br>    imgpts &#x3D; np.int32(imgpts).reshape(-1,2)</p>
<pre><code># draw ground floor in green
img = cv.drawContours(img, [imgpts[:4]],-1,(0,255,0),-3)

# draw pillars in blue color
for i,j in zip(range(4),range(4,8)):
    img = cv.line(img, tuple(imgpts[i]), tuple(imgpts[j]),(255),3)

# draw top layer in red color
img = cv.drawContours(img, [imgpts[4:]],-1,(0,0,255),3)

return img
</code></pre>
<p>@endcode<br>Modified axis points. They are the 8 corners of a cube in 3D space:<br>@code{.py}<br>axis &#x3D; np.float32([[0,0,0], [0,3,0], [3,3,0], [3,0,0],<br>                   [0,0,-3],[0,3,-3],[3,3,-3],[3,0,-3] ])<br>@endcode<br>And look at the result below:</p>
<p><img src="/images/pose_2.jpg" alt="image"></p>
<p>If you are interested in graphics, augmented reality etc, you can use OpenGL to render more<br>complicated figures.</p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>