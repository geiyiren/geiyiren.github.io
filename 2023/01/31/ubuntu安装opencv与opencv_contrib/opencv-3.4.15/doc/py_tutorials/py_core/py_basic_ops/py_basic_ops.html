<h1 id="Basic-Operations-on-Images-tutorial-py-basic-ops"><a href="#Basic-Operations-on-Images-tutorial-py-basic-ops" class="headerlink" title="Basic Operations on Images {#tutorial_py_basic_ops}"></a>Basic Operations on Images {#tutorial_py_basic_ops}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>Learn to:</p>
<ul>
<li>Access pixel values and modify them</li>
<li>Access image properties</li>
<li>Set a Region of Interest (ROI)</li>
<li>Split and merge images</li>
</ul>
<p>Almost all the operations in this section are mainly related to Numpy rather than OpenCV. A good<br>knowledge of Numpy is required to write better optimized code with OpenCV.</p>
<p><em>( Examples will be shown in a Python terminal, since most of them are just single lines of code )</em></p>
<h2 id="Accessing-and-Modifying-pixel-values"><a href="#Accessing-and-Modifying-pixel-values" class="headerlink" title="Accessing and Modifying pixel values"></a>Accessing and Modifying pixel values</h2><p>Let’s load a color image first:<br>@code{.py}</p>
<blockquote>
<blockquote>
<blockquote>
<p>import numpy as np<br>import cv2 as cv</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>img &#x3D; cv.imread(‘messi5.jpg’)<br>@endcode<br>You can access a pixel value by its row and column coordinates. For BGR image, it returns an array<br>of Blue, Green, Red values. For grayscale image, just corresponding intensity is returned.<br>@code{.py}<br>px &#x3D; img[100,100]<br>print( px )<br>[157 166 200]</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="accessing-only-blue-pixel"><a href="#accessing-only-blue-pixel" class="headerlink" title="accessing only blue pixel"></a>accessing only blue pixel</h1><blockquote>
<blockquote>
<blockquote>
<p>blue &#x3D; img[100,100,0]<br>print( blue )<br>157<br>@endcode<br>You can modify the pixel values the same way.<br>@code{.py}<br>img[100,100] &#x3D; [255,255,255]<br>print( img[100,100] )<br>[255 255 255]<br>@endcode</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Warning</strong></p>
<p>Numpy is an optimized library for fast array calculations. So simply accessing each and every pixel<br>value and modifying it will be very slow and it is discouraged.</p>
<p>@note The above method is normally used for selecting a region of an array, say the first 5 rows<br>and last 3 columns. For individual pixel access, the Numpy array methods, array.item() and<br>array.itemset() are considered better. They always return a scalar, however, so if you want to access<br>all the B,G,R values, you will need to call array.item() separately for each value.</p>
<p>Better pixel accessing and editing method :<br>@code{.py}</p>
<h1 id="accessing-RED-value"><a href="#accessing-RED-value" class="headerlink" title="accessing RED value"></a>accessing RED value</h1><blockquote>
<blockquote>
<blockquote>
<p>img.item(10,10,2)<br>59</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="modifying-RED-value"><a href="#modifying-RED-value" class="headerlink" title="modifying RED value"></a>modifying RED value</h1><blockquote>
<blockquote>
<blockquote>
<p>img.itemset((10,10,2),100)<br>img.item(10,10,2)<br>100<br>@endcode</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="Accessing-Image-Properties"><a href="#Accessing-Image-Properties" class="headerlink" title="Accessing Image Properties"></a>Accessing Image Properties</h2><p>Image properties include number of rows, columns, and channels; type of image data; number of pixels; etc.</p>
<p>The shape of an image is accessed by img.shape. It returns a tuple of the number of rows, columns, and channels<br>(if the image is color):<br>@code{.py}</p>
<blockquote>
<blockquote>
<blockquote>
<p>print( img.shape )<br>(342, 548, 3)<br>@endcode</p>
</blockquote>
</blockquote>
</blockquote>
<p>@note If an image is grayscale, the tuple returned contains only the number of rows<br>and columns, so it is a good method to check whether the loaded image is grayscale or color.</p>
<p>Total number of pixels is accessed by <code>img.size</code>:<br>@code{.py}</p>
<blockquote>
<blockquote>
<blockquote>
<p>print( img.size )<br>562248<br>@endcode<br>Image datatype is obtained by `img.dtype`:<br>@code{.py}<br>print( img.dtype )<br>uint8<br>@endcode</p>
</blockquote>
</blockquote>
</blockquote>
<p>@note img.dtype is very important while debugging because a large number of errors in OpenCV-Python<br>code are caused by invalid datatype.</p>
<h2 id="Image-ROI"><a href="#Image-ROI" class="headerlink" title="Image ROI"></a>Image ROI</h2><p>Sometimes, you will have to play with certain regions of images. For eye detection in images, first<br>face detection is done over the entire image. When a face is obtained, we select the face region alone<br>and search for eyes inside it instead of searching the whole image. It improves accuracy (because eyes<br>are always on faces :D ) and performance (because we search in a small area).</p>
<p>ROI is again obtained using Numpy indexing. Here I am selecting the ball and copying it to another<br>region in the image:<br>@code{.py}</p>
<blockquote>
<blockquote>
<blockquote>
<p>ball &#x3D; img[280:340, 330:390]<br>img[273:333, 100:160] &#x3D; ball<br>@endcode<br>Check the results below:</p>
</blockquote>
</blockquote>
</blockquote>
<p><img src="/images/roi.jpg" alt="image"></p>
<h2 id="Splitting-and-Merging-Image-Channels"><a href="#Splitting-and-Merging-Image-Channels" class="headerlink" title="Splitting and Merging Image Channels"></a>Splitting and Merging Image Channels</h2><p>Sometimes you will need to work separately on the B,G,R channels of an image. In this case, you need<br>to split the BGR image into single channels. In other cases, you may need to join these individual<br>channels to create a BGR image. You can do this simply by:<br>@code{.py}</p>
<blockquote>
<blockquote>
<blockquote>
<p>b,g,r &#x3D; cv.split(img)<br>img &#x3D; cv.merge((b,g,r))<br>@endcode<br>Or<br>@code<br>b &#x3D; img[:,:,0]<br>@endcode<br>Suppose you want to set all the red pixels to zero - you do not need to split the channels first.<br>Numpy indexing is faster:<br>@code{.py}<br>img[:,:,2] &#x3D; 0<br>@endcode</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>Warning</strong></p>
<p>cv.split() is a costly operation (in terms of time). So use it only if necessary. Otherwise go<br>for Numpy indexing.</p>
<h2 id="Making-Borders-for-Images-Padding"><a href="#Making-Borders-for-Images-Padding" class="headerlink" title="Making Borders for Images (Padding)"></a>Making Borders for Images (Padding)</h2><p>If you want to create a border around an image, something like a photo frame, you can use<br><strong>cv.copyMakeBorder()</strong>. But it has more applications for convolution operation, zero<br>padding etc. This function takes following arguments:</p>
<ul>
<li><p><strong>src</strong> - input image</p>
</li>
<li><p><strong>top</strong>, <strong>bottom</strong>, <strong>left</strong>, <strong>right</strong> - border width in number of pixels in corresponding<br>directions</p>
</li>
<li><p><strong>borderType</strong> - Flag defining what kind of border to be added. It can be following types:</p>
<ul>
<li><strong>cv.BORDER_CONSTANT</strong> - Adds a constant colored border. The value should be given<br>as next argument.</li>
<li><strong>cv.BORDER_REFLECT</strong> - Border will be mirror reflection of the border elements,<br>like this : <em>fedcba|abcdefgh|hgfedcb</em></li>
<li><strong>cv.BORDER_REFLECT_101</strong> or <strong>cv.BORDER_DEFAULT</strong> - Same as above, but with a<br>slight change, like this : <em>gfedcb|abcdefgh|gfedcba</em></li>
<li><strong>cv.BORDER_REPLICATE</strong> - Last element is replicated throughout, like this:<br><em>aaaaaa|abcdefgh|hhhhhhh</em></li>
<li><strong>cv.BORDER_WRAP</strong> - Can’t explain, it will look like this :<br><em>cdefgh|abcdefgh|abcdefg</em></li>
</ul>
</li>
<li><p><strong>value</strong> - Color of border if border type is cv.BORDER_CONSTANT</p>
</li>
</ul>
<p>Below is a sample code demonstrating all these border types for better understanding:<br>@code{.py}<br>import cv2 as cv<br>import numpy as np<br>from matplotlib import pyplot as plt</p>
<p>BLUE &#x3D; [255,0,0]</p>
<p>img1 &#x3D; cv.imread(‘opencv-logo.png’)</p>
<p>replicate &#x3D; cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_REPLICATE)<br>reflect &#x3D; cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_REFLECT)<br>reflect101 &#x3D; cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_REFLECT_101)<br>wrap &#x3D; cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_WRAP)<br>constant&#x3D; cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_CONSTANT,value&#x3D;BLUE)</p>
<p>plt.subplot(231),plt.imshow(img1,’gray’),plt.title(‘ORIGINAL’)<br>plt.subplot(232),plt.imshow(replicate,’gray’),plt.title(‘REPLICATE’)<br>plt.subplot(233),plt.imshow(reflect,’gray’),plt.title(‘REFLECT’)<br>plt.subplot(234),plt.imshow(reflect101,’gray’),plt.title(‘REFLECT_101’)<br>plt.subplot(235),plt.imshow(wrap,’gray’),plt.title(‘WRAP’)<br>plt.subplot(236),plt.imshow(constant,’gray’),plt.title(‘CONSTANT’)</p>
<p>plt.show()<br>@endcode<br>See the result below. (Image is displayed with matplotlib. So RED and BLUE channels will be<br>interchanged):</p>
<p><img src="/images/border.jpg" alt="image"></p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>