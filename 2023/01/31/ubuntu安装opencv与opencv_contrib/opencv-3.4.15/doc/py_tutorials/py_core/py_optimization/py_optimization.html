<h1 id="Performance-Measurement-and-Improvement-Techniques-tutorial-py-optimization"><a href="#Performance-Measurement-and-Improvement-Techniques-tutorial-py-optimization" class="headerlink" title="Performance Measurement and Improvement Techniques {#tutorial_py_optimization}"></a>Performance Measurement and Improvement Techniques {#tutorial_py_optimization}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In image processing, since you are dealing with a large number of operations per second, it is mandatory that your code is not only providing the correct solution, but that it is also providing it in the fastest manner.<br>So in this chapter, you will learn:</p>
<ul>
<li>To measure the performance of your code.</li>
<li>Some tips to improve the performance of your code.</li>
<li>You will see these functions: <strong>cv.getTickCount</strong>, <strong>cv.getTickFrequency</strong>, etc.</li>
</ul>
<p>Apart from OpenCV, Python also provides a module <strong>time</strong> which is helpful in measuring the time of<br>execution. Another module <strong>profile</strong> helps to get a detailed report on the code, like how much time<br>each function in the code took, how many times the function was called, etc. But, if you are using<br>IPython, all these features are integrated in an user-friendly manner. We will see some important<br>ones, and for more details, check links in the <strong>Additional Resources</strong> section.</p>
<h2 id="Measuring-Performance-with-OpenCV"><a href="#Measuring-Performance-with-OpenCV" class="headerlink" title="Measuring Performance with OpenCV"></a>Measuring Performance with OpenCV</h2><p>The <strong>cv.getTickCount</strong> function returns the number of clock-cycles after a reference event (like the<br>moment the machine was switched ON) to the moment this function is called. So if you call it before and<br>after the function execution, you get the number of clock-cycles used to execute a function.</p>
<p>The <strong>cv.getTickFrequency</strong> function returns the frequency of clock-cycles, or the number of<br>clock-cycles per second. So to find the time of execution in seconds, you can do following:<br>@code{.py}<br>e1 &#x3D; cv.getTickCount()</p>
<h1 id="your-code-execution"><a href="#your-code-execution" class="headerlink" title="your code execution"></a>your code execution</h1><p>e2 &#x3D; cv.getTickCount()<br>time &#x3D; (e2 - e1)&#x2F; cv.getTickFrequency()<br>@endcode<br>We will demonstrate with following example. The following example applies median filtering with kernels<br>of odd sizes ranging from 5 to 49. (Don’t worry about what the result will look like - that is not our<br>goal):<br>@code{.py}<br>img1 &#x3D; cv.imread(‘messi5.jpg’)</p>
<p>e1 &#x3D; cv.getTickCount()<br>for i in range(5,49,2):<br>    img1 &#x3D; cv.medianBlur(img1,i)<br>e2 &#x3D; cv.getTickCount()<br>t &#x3D; (e2 - e1)&#x2F;cv.getTickFrequency()<br>print( t )</p>
<h1 id="Result-I-got-is-0-521107655-seconds"><a href="#Result-I-got-is-0-521107655-seconds" class="headerlink" title="Result I got is 0.521107655 seconds"></a>Result I got is 0.521107655 seconds</h1><p>@endcode<br>@note You can do the same thing with the time module. Instead of cv.getTickCount, use the time.time() function.<br>Then take the difference of the two times.</p>
<h2 id="Default-Optimization-in-OpenCV"><a href="#Default-Optimization-in-OpenCV" class="headerlink" title="Default Optimization in OpenCV"></a>Default Optimization in OpenCV</h2><p>Many of the OpenCV functions are optimized using SSE2, AVX, etc. It contains the unoptimized code also.<br>So if our system support these features, we should exploit them (almost all modern day processors<br>support them). It is enabled by default while compiling. So OpenCV runs the optimized code if it is<br>enabled, otherwise it runs the unoptimized code. You can use <strong>cv.useOptimized()</strong> to check if it is<br>enabled&#x2F;disabled and <strong>cv.setUseOptimized()</strong> to enable&#x2F;disable it. Let’s see a simple example.<br>@code{.py}</p>
<h1 id="check-if-optimization-is-enabled"><a href="#check-if-optimization-is-enabled" class="headerlink" title="check if optimization is enabled"></a>check if optimization is enabled</h1><p>In [5]: cv.useOptimized()<br>Out[5]: True</p>
<p>In [6]: %timeit res &#x3D; cv.medianBlur(img,49)<br>10 loops, best of 3: 34.9 ms per loop</p>
<h1 id="Disable-it"><a href="#Disable-it" class="headerlink" title="Disable it"></a>Disable it</h1><p>In [7]: cv.setUseOptimized(False)</p>
<p>In [8]: cv.useOptimized()<br>Out[8]: False</p>
<p>In [9]: %timeit res &#x3D; cv.medianBlur(img,49)<br>10 loops, best of 3: 64.1 ms per loop<br>@endcode<br>As you can see, optimized median filtering is ~2x faster than the unoptimized version. If you check its source,<br>you can see that median filtering is SIMD optimized. So you can use this to enable optimization at the<br>top of your code (remember it is enabled by default).</p>
<h2 id="Measuring-Performance-in-IPython"><a href="#Measuring-Performance-in-IPython" class="headerlink" title="Measuring Performance in IPython"></a>Measuring Performance in IPython</h2><p>Sometimes you may need to compare the performance of two similar operations. IPython gives you a<br>magic command %timeit to perform this. It runs the code several times to get more accurate results.<br>Once again, it is suitable to measuring single lines of code.</p>
<p>For example, do you know which of the following addition operations is better, x &#x3D; 5; y &#x3D; x**2,<br>x &#x3D; 5; y &#x3D; x*x, x &#x3D; np.uint8([5]); y &#x3D; x*x, or y &#x3D; np.square(x)? We will find out with %timeit in the<br>IPython shell.<br>@code{.py}<br>In [10]: x &#x3D; 5</p>
<p>In [11]: %timeit y&#x3D;x**2<br>10000000 loops, best of 3: 73 ns per loop</p>
<p>In [12]: %timeit y&#x3D;x*x<br>10000000 loops, best of 3: 58.3 ns per loop</p>
<p>In [15]: z &#x3D; np.uint8([5])</p>
<p>In [17]: %timeit y&#x3D;z*z<br>1000000 loops, best of 3: 1.25 us per loop</p>
<p>In [19]: %timeit y&#x3D;np.square(z)<br>1000000 loops, best of 3: 1.16 us per loop<br>@endcode<br>You can see that, x &#x3D; 5 ; y &#x3D; x*x is fastest and it is around 20x faster compared to Numpy. If you<br>consider the array creation also, it may reach up to 100x faster. Cool, right? <em>(Numpy devs are<br>working on this issue)</em></p>
<p>@note Python scalar operations are faster than Numpy scalar operations. So for operations including<br>one or two elements, Python scalar is better than Numpy arrays. Numpy has the advantage when the size of<br>the array is a little bit bigger.</p>
<p>We will try one more example. This time, we will compare the performance of <strong>cv.countNonZero()</strong><br>and <strong>np.count_nonzero()</strong> for the same image.</p>
<p>@code{.py}<br>In [35]: %timeit z &#x3D; cv.countNonZero(img)<br>100000 loops, best of 3: 15.8 us per loop</p>
<p>In [36]: %timeit z &#x3D; np.count_nonzero(img)<br>1000 loops, best of 3: 370 us per loop<br>@endcode<br>See, the OpenCV function is nearly 25x faster than the Numpy function.</p>
<p>@note Normally, OpenCV functions are faster than Numpy functions. So for same operation, OpenCV<br>functions are preferred. But, there can be exceptions, especially when Numpy works with views<br>instead of copies.</p>
<h2 id="More-IPython-magic-commands"><a href="#More-IPython-magic-commands" class="headerlink" title="More IPython magic commands"></a>More IPython magic commands</h2><p>There are several other magic commands to measure performance, profiling, line profiling, memory<br>measurement, and etc. They all are well documented. So only links to those docs are provided here.<br>Interested readers are recommended to try them out.</p>
<h2 id="Performance-Optimization-Techniques"><a href="#Performance-Optimization-Techniques" class="headerlink" title="Performance Optimization Techniques"></a>Performance Optimization Techniques</h2><p>There are several techniques and coding methods to exploit maximum performance of Python and Numpy.<br>Only relevant ones are noted here and links are given to important sources. The main thing to be<br>noted here is, first try to implement the algorithm in a simple manner. Once it is working,<br>profile it, find the bottlenecks, and optimize them.</p>
<p>-#  Avoid using loops in Python as much as possible, especially double&#x2F;triple loops etc. They are<br>    inherently slow.<br>2.  Vectorize the algorithm&#x2F;code to the maximum extent possible, because Numpy and OpenCV are<br>    optimized for vector operations.<br>3.  Exploit the cache coherence.<br>4.  Never make copies of an array unless it is necessary. Try to use views instead. Array copying is a<br>    costly operation.</p>
<p>If your code is still slow after doing all of these operations, or if the use of large loops is inevitable, use additional libraries like Cython to make it faster.</p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><p>-#  <a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips">Python Optimization Techniques</a><br>2.  Scipy Lecture Notes - <a href="http://scipy-lectures.github.io/advanced/advanced_numpy/index.html#advanced-numpy">Advanced<br>    Numpy</a><br>3.  <a href="http://pynash.org/2013/03/06/timing-and-profiling/">Timing and Profiling in IPython</a></p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>