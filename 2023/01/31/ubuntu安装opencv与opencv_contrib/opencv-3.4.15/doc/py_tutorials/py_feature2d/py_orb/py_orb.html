<h1 id="ORB-Oriented-FAST-and-Rotated-BRIEF-tutorial-py-orb"><a href="#ORB-Oriented-FAST-and-Rotated-BRIEF-tutorial-py-orb" class="headerlink" title="ORB (Oriented FAST and Rotated BRIEF) {#tutorial_py_orb}"></a>ORB (Oriented FAST and Rotated BRIEF) {#tutorial_py_orb}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter,<br>    -   We will see the basics of ORB</p>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>As an OpenCV enthusiast, the most important thing about the ORB is that it came from “OpenCV Labs”.<br>This algorithm was brought up by Ethan Rublee, Vincent Rabaud, Kurt Konolige and Gary R. Bradski in<br>their paper <strong>ORB: An efficient alternative to SIFT or SURF</strong> in 2011. As the title says, it is a<br>good alternative to SIFT and SURF in computation cost, matching performance and mainly the patents.<br>Yes, SIFT and SURF are patented and you are supposed to pay them for its use. But ORB is not !!!</p>
<p>ORB is basically a fusion of FAST keypoint detector and BRIEF descriptor with many modifications to<br>enhance the performance. First it use FAST to find keypoints, then apply Harris corner measure to<br>find top N points among them. It also use pyramid to produce multiscale-features. But one problem is<br>that, FAST doesn’t compute the orientation. So what about rotation invariance? Authors came up with<br>following modification.</p>
<p>It computes the intensity weighted centroid of the patch with located corner at center. The<br>direction of the vector from this corner point to centroid gives the orientation. To improve the<br>rotation invariance, moments are computed with x and y which should be in a circular region of<br>radius \f$r\f$, where \f$r\f$ is the size of the patch.</p>
<p>Now for descriptors, ORB use BRIEF descriptors. But we have already seen that BRIEF performs poorly<br>with rotation. So what ORB does is to “steer” BRIEF according to the orientation of keypoints. For<br>any feature set of \f$n\f$ binary tests at location \f$(x_i, y_i)\f$, define a \f$2 \times n\f$ matrix, \f$S\f$<br>which contains the coordinates of these pixels. Then using the orientation of patch, \f$\theta\f$, its<br>rotation matrix is found and rotates the \f$S\f$ to get steered(rotated) version \f$S_\theta\f$.</p>
<p>ORB discretize the angle to increments of \f$2 \pi &#x2F;30\f$ (12 degrees), and construct a lookup table of<br>precomputed BRIEF patterns. As long as the keypoint orientation \f$\theta\f$ is consistent across views,<br>the correct set of points \f$S_\theta\f$ will be used to compute its descriptor.</p>
<p>BRIEF has an important property that each bit feature has a large variance and a mean near 0.5. But<br>once it is oriented along keypoint direction, it loses this property and become more distributed.<br>High variance makes a feature more discriminative, since it responds differentially to inputs.<br>Another desirable property is to have the tests uncorrelated, since then each test will contribute<br>to the result. To resolve all these, ORB runs a greedy search among all possible binary tests to<br>find the ones that have both high variance and means close to 0.5, as well as being uncorrelated.<br>The result is called <strong>rBRIEF</strong>.</p>
<p>For descriptor matching, multi-probe LSH which improves on the traditional LSH, is used. The paper<br>says ORB is much faster than SURF and SIFT and ORB descriptor works better than SURF. ORB is a good<br>choice in low-power devices for panorama stitching etc.</p>
<h2 id="ORB-in-OpenCV"><a href="#ORB-in-OpenCV" class="headerlink" title="ORB in OpenCV"></a>ORB in OpenCV</h2><p>As usual, we have to create an ORB object with the function, <strong>cv.ORB()</strong> or using feature2d common<br>interface. It has a number of optional parameters. Most useful ones are nFeatures which denotes<br>maximum number of features to be retained (by default 500), scoreType which denotes whether Harris<br>score or FAST score to rank the features (by default, Harris score) etc. Another parameter, WTA_K<br>decides number of points that produce each element of the oriented BRIEF descriptor. By default it<br>is two, ie selects two points at a time. In that case, for matching, NORM_HAMMING distance is used.<br>If WTA_K is 3 or 4, which takes 3 or 4 points to produce BRIEF descriptor, then matching distance<br>is defined by NORM_HAMMING2.</p>
<p>Below is a simple code which shows the use of ORB.<br>@code{.py}<br>import numpy as np<br>import cv2 as cv<br>from matplotlib import pyplot as plt</p>
<p>img &#x3D; cv.imread(‘simple.jpg’,0)</p>
<h1 id="Initiate-ORB-detector"><a href="#Initiate-ORB-detector" class="headerlink" title="Initiate ORB detector"></a>Initiate ORB detector</h1><p>orb &#x3D; cv.ORB_create()</p>
<h1 id="find-the-keypoints-with-ORB"><a href="#find-the-keypoints-with-ORB" class="headerlink" title="find the keypoints with ORB"></a>find the keypoints with ORB</h1><p>kp &#x3D; orb.detect(img,None)</p>
<h1 id="compute-the-descriptors-with-ORB"><a href="#compute-the-descriptors-with-ORB" class="headerlink" title="compute the descriptors with ORB"></a>compute the descriptors with ORB</h1><p>kp, des &#x3D; orb.compute(img, kp)</p>
<h1 id="draw-only-keypoints-location-not-size-and-orientation"><a href="#draw-only-keypoints-location-not-size-and-orientation" class="headerlink" title="draw only keypoints location,not size and orientation"></a>draw only keypoints location,not size and orientation</h1><p>img2 &#x3D; cv.drawKeypoints(img, kp, None, color&#x3D;(0,255,0), flags&#x3D;0)<br>plt.imshow(img2), plt.show()<br>@endcode<br>See the result below:</p>
<p><img src="/images/orb_kp.jpg" alt="image"></p>
<p>ORB feature matching, we will do in another chapter.</p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><p>-#  Ethan Rublee, Vincent Rabaud, Kurt Konolige, Gary R. Bradski: ORB: An efficient alternative to<br>    SIFT or SURF. ICCV 2011: 2564-2571.</p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>