<h1 id="Shi-Tomasi-Corner-Detector-amp-Good-Features-to-Track-tutorial-py-shi-tomasi"><a href="#Shi-Tomasi-Corner-Detector-amp-Good-Features-to-Track-tutorial-py-shi-tomasi" class="headerlink" title="Shi-Tomasi Corner Detector &amp; Good Features to Track {#tutorial_py_shi_tomasi}"></a>Shi-Tomasi Corner Detector &amp; Good Features to Track {#tutorial_py_shi_tomasi}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter,</p>
<ul>
<li>We will learn about the another corner detector: Shi-Tomasi Corner Detector</li>
<li>We will see the function: <strong>cv.goodFeaturesToTrack()</strong></li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>In last chapter, we saw Harris Corner Detector. Later in 1994, J. Shi and C. Tomasi made a small<br>modification to it in their paper <strong>Good Features to Track</strong> which shows better results compared to<br>Harris Corner Detector. The scoring function in Harris Corner Detector was given by:</p>
<p>\f[R &#x3D; \lambda_1 \lambda_2 - k(\lambda_1+\lambda_2)^2\f]</p>
<p>Instead of this, Shi-Tomasi proposed:</p>
<p>\f[R &#x3D; \min(\lambda_1, \lambda_2)\f]</p>
<p>If it is a greater than a threshold value, it is considered as a corner. If we plot it in<br>\f$\lambda_1 - \lambda_2\f$ space as we did in Harris Corner Detector, we get an image as below:</p>
<p><img src="/images/shitomasi_space.png" alt="image"></p>
<p>From the figure, you can see that only when \f$\lambda_1\f$ and \f$\lambda_2\f$ are above a minimum value,<br>\f$\lambda_{\min}\f$, it is considered as a corner(green region).</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>OpenCV has a function, <strong>cv.goodFeaturesToTrack()</strong>. It finds N strongest corners in the image by<br>Shi-Tomasi method (or Harris Corner Detection, if you specify it). As usual, image should be a<br>grayscale image. Then you specify number of corners you want to find. Then you specify the quality<br>level, which is a value between 0-1, which denotes the minimum quality of corner below which<br>everyone is rejected. Then we provide the minimum euclidean distance between corners detected.</p>
<p>With all this information, the function finds corners in the image. All corners below quality<br>level are rejected. Then it sorts the remaining corners based on quality in the descending order.<br>Then function takes first strongest corner, throws away all the nearby corners in the range of<br>minimum distance and returns N strongest corners.</p>
<p>In below example, we will try to find 25 best corners:<br>@code{.py}<br>import numpy as np<br>import cv2 as cv<br>from matplotlib import pyplot as plt</p>
<p>img &#x3D; cv.imread(‘blox.jpg’)<br>gray &#x3D; cv.cvtColor(img,cv.COLOR_BGR2GRAY)</p>
<p>corners &#x3D; cv.goodFeaturesToTrack(gray,25,0.01,10)<br>corners &#x3D; np.int0(corners)</p>
<p>for i in corners:<br>    x,y &#x3D; i.ravel()<br>    cv.circle(img,(x,y),3,255,-1)</p>
<p>plt.imshow(img),plt.show()<br>@endcode<br>See the result below:</p>
<p><img src="/images/shitomasi_block1.jpg" alt="image"></p>
<p>This function is more appropriate for tracking. We will see that when its time comes.</p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>