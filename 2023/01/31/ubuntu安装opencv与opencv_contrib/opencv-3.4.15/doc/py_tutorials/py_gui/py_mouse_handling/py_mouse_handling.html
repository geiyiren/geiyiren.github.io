<h1 id="Mouse-as-a-Paint-Brush-tutorial-py-mouse-handling"><a href="#Mouse-as-a-Paint-Brush-tutorial-py-mouse-handling" class="headerlink" title="Mouse as a Paint-Brush {#tutorial_py_mouse_handling}"></a>Mouse as a Paint-Brush {#tutorial_py_mouse_handling}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><ul>
<li>Learn to handle mouse events in OpenCV</li>
<li>You will learn these functions : <strong>cv.setMouseCallback()</strong></li>
</ul>
<h2 id="Simple-Demo"><a href="#Simple-Demo" class="headerlink" title="Simple Demo"></a>Simple Demo</h2><p>Here, we create a simple application which draws a circle on an image wherever we double-click on<br>it.</p>
<p>First we create a mouse callback function which is executed when a mouse event take place. Mouse<br>event can be anything related to mouse like left-button down, left-button up, left-button<br>double-click etc. It gives us the coordinates (x,y) for every mouse event. With this event and<br>location, we can do whatever we like. To list all available events available, run the following code<br>in Python terminal:<br>@code{.py}<br>import cv2 as cv<br>events &#x3D; [i for i in dir(cv) if ‘EVENT’ in i]<br>print( events )<br>@endcode<br>Creating mouse callback function has a specific format which is same everywhere. It differs only in<br>what the function does. So our mouse callback function does one thing, it draws a circle where we<br>double-click. So see the code below. Code is self-explanatory from comments :<br>@code{.py}<br>import numpy as np<br>import cv2 as cv</p>
<h1 id="mouse-callback-function"><a href="#mouse-callback-function" class="headerlink" title="mouse callback function"></a>mouse callback function</h1><p>def draw_circle(event,x,y,flags,param):<br>    if event &#x3D;&#x3D; cv.EVENT_LBUTTONDBLCLK:<br>        cv.circle(img,(x,y),100,(255,0,0),-1)</p>
<h1 id="Create-a-black-image-a-window-and-bind-the-function-to-window"><a href="#Create-a-black-image-a-window-and-bind-the-function-to-window" class="headerlink" title="Create a black image, a window and bind the function to window"></a>Create a black image, a window and bind the function to window</h1><p>img &#x3D; np.zeros((512,512,3), np.uint8)<br>cv.namedWindow(‘image’)<br>cv.setMouseCallback(‘image’,draw_circle)</p>
<h2 id="while-1-cv-imshow-‘image’-img-if-cv-waitKey-20-amp-0xFF-x3D-x3D-27-breakcv-destroyAllWindows-endcodeMore-Advanced-Demo"><a href="#while-1-cv-imshow-‘image’-img-if-cv-waitKey-20-amp-0xFF-x3D-x3D-27-breakcv-destroyAllWindows-endcodeMore-Advanced-Demo" class="headerlink" title="while(1):    cv.imshow(‘image’,img)    if cv.waitKey(20) &amp; 0xFF &#x3D;&#x3D; 27:        breakcv.destroyAllWindows()@endcodeMore Advanced Demo"></a>while(1):<br>    cv.imshow(‘image’,img)<br>    if cv.waitKey(20) &amp; 0xFF &#x3D;&#x3D; 27:<br>        break<br>cv.destroyAllWindows()<br>@endcode<br>More Advanced Demo</h2><p>Now we go for a much better application. In this, we draw either rectangles or circles (depending on<br>the mode we select) by dragging the mouse like we do in Paint application. So our mouse callback<br>function has two parts, one to draw rectangle and other to draw the circles. This specific example<br>will be really helpful in creating and understanding some interactive applications like object<br>tracking, image segmentation etc.<br>@code{.py}<br>import numpy as np<br>import cv2 as cv</p>
<p>drawing &#x3D; False # true if mouse is pressed<br>mode &#x3D; True # if True, draw rectangle. Press ‘m’ to toggle to curve<br>ix,iy &#x3D; -1,-1</p>
<h1 id="mouse-callback-function-1"><a href="#mouse-callback-function-1" class="headerlink" title="mouse callback function"></a>mouse callback function</h1><p>def draw_circle(event,x,y,flags,param):<br>    global ix,iy,drawing,mode</p>
<pre><code>if event == cv.EVENT_LBUTTONDOWN:
    drawing = True
    ix,iy = x,y

elif event == cv.EVENT_MOUSEMOVE:
    if drawing == True:
        if mode == True:
            cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)
        else:
            cv.circle(img,(x,y),5,(0,0,255),-1)

elif event == cv.EVENT_LBUTTONUP:
    drawing = False
    if mode == True:
        cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)
    else:
        cv.circle(img,(x,y),5,(0,0,255),-1)
</code></pre>
<p>@endcode<br>Next we have to bind this mouse callback function to OpenCV window. In the main loop, we should set<br>a keyboard binding for key ‘m’ to toggle between rectangle and circle.<br>@code{.py}<br>img &#x3D; np.zeros((512,512,3), np.uint8)<br>cv.namedWindow(‘image’)<br>cv.setMouseCallback(‘image’,draw_circle)</p>
<p>while(1):<br>    cv.imshow(‘image’,img)<br>    k &#x3D; cv.waitKey(1) &amp; 0xFF<br>    if k &#x3D;&#x3D; ord(‘m’):<br>        mode &#x3D; not mode<br>    elif k &#x3D;&#x3D; 27:<br>        break</p>
<h2 id="cv-destroyAllWindows-endcodeAdditional-Resources"><a href="#cv-destroyAllWindows-endcodeAdditional-Resources" class="headerlink" title="cv.destroyAllWindows()@endcodeAdditional Resources"></a>cv.destroyAllWindows()<br>@endcode<br>Additional Resources</h2><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><p>-#  In our last example, we drew filled rectangle. You modify the code to draw an unfilled<br>    rectangle.</p>
