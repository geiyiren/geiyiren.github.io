<h1 id="Contours-More-Functions-tutorial-py-contours-more-functions"><a href="#Contours-More-Functions-tutorial-py-contours-more-functions" class="headerlink" title="Contours : More Functions {#tutorial_py_contours_more_functions}"></a>Contours : More Functions {#tutorial_py_contours_more_functions}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter, we will learn about<br>    -   Convexity defects and how to find them.<br>    -   Finding shortest distance from a point to a polygon<br>    -   Matching different shapes</p>
<h2 id="Theory-and-Code"><a href="#Theory-and-Code" class="headerlink" title="Theory and Code"></a>Theory and Code</h2><h3 id="1-Convexity-Defects"><a href="#1-Convexity-Defects" class="headerlink" title="1. Convexity Defects"></a>1. Convexity Defects</h3><p>We saw what is convex hull in second chapter about contours. Any deviation of the object from this<br>hull can be considered as convexity defect.</p>
<p>OpenCV comes with a ready-made function to find this, <strong>cv.convexityDefects()</strong>. A basic function<br>call would look like below:<br>@code{.py}<br>hull &#x3D; cv.convexHull(cnt,returnPoints &#x3D; False)<br>defects &#x3D; cv.convexityDefects(cnt,hull)<br>@endcode</p>
<p>@note Remember we have to pass returnPoints &#x3D; False while finding convex hull, in order to find<br>convexity defects.</p>
<p>It returns an array where each row contains these values - <strong>[ start point, end point, farthest<br>point, approximate distance to farthest point ]</strong>. We can visualize it using an image. We draw a<br>line joining start point and end point, then draw a circle at the farthest point. Remember first<br>three values returned are indices of cnt. So we have to bring those values from cnt.</p>
<p>@code{.py}<br>import cv2 as cv<br>import numpy as np</p>
<p>img &#x3D; cv.imread(‘star.jpg’)<br>img_gray &#x3D; cv.cvtColor(img,cv.COLOR_BGR2GRAY)<br>ret,thresh &#x3D; cv.threshold(img_gray, 127, 255,0)<br>im2,contours,hierarchy &#x3D; cv.findContours(thresh,2,1)<br>cnt &#x3D; contours[0]</p>
<p>hull &#x3D; cv.convexHull(cnt,returnPoints &#x3D; False)<br>defects &#x3D; cv.convexityDefects(cnt,hull)</p>
<p>for i in range(defects.shape[0]):<br>    s,e,f,d &#x3D; defects[i,0]<br>    start &#x3D; tuple(cnt[s][0])<br>    end &#x3D; tuple(cnt[e][0])<br>    far &#x3D; tuple(cnt[f][0])<br>    cv.line(img,start,end,[0,255,0],2)<br>    cv.circle(img,far,5,[0,0,255],-1)</p>
<p>cv.imshow(‘img’,img)<br>cv.waitKey(0)<br>cv.destroyAllWindows()<br>@endcode<br>And see the result:</p>
<p><img src="/images/defects.jpg" alt="image"></p>
<h3 id="2-Point-Polygon-Test"><a href="#2-Point-Polygon-Test" class="headerlink" title="2. Point Polygon Test"></a>2. Point Polygon Test</h3><p>This function finds the shortest distance between a point in the image and a contour. It returns the<br>distance which is negative when point is outside the contour, positive when point is inside and zero<br>if point is on the contour.</p>
<p>For example, we can check the point (50,50) as follows:<br>@code{.py}<br>dist &#x3D; cv.pointPolygonTest(cnt,(50,50),True)<br>@endcode<br>In the function, third argument is measureDist. If it is True, it finds the signed distance. If<br>False, it finds whether the point is inside or outside or on the contour (it returns +1, -1, 0<br>respectively).</p>
<p>@note If you don’t want to find the distance, make sure third argument is False, because, it is a<br>time consuming process. So, making it False gives about 2-3X speedup.</p>
<h3 id="3-Match-Shapes"><a href="#3-Match-Shapes" class="headerlink" title="3. Match Shapes"></a>3. Match Shapes</h3><p>OpenCV comes with a function <strong>cv.matchShapes()</strong> which enables us to compare two shapes, or two<br>contours and returns a metric showing the similarity. The lower the result, the better match it is.<br>It is calculated based on the hu-moment values. Different measurement methods are explained in the<br>docs.<br>@code{.py}<br>import cv2 as cv<br>import numpy as np</p>
<p>img1 &#x3D; cv.imread(‘star.jpg’,0)<br>img2 &#x3D; cv.imread(‘star2.jpg’,0)</p>
<p>ret, thresh &#x3D; cv.threshold(img1, 127, 255,0)<br>ret, thresh2 &#x3D; cv.threshold(img2, 127, 255,0)<br>im2,contours,hierarchy &#x3D; cv.findContours(thresh,2,1)<br>cnt1 &#x3D; contours[0]<br>im2,contours,hierarchy &#x3D; cv.findContours(thresh2,2,1)<br>cnt2 &#x3D; contours[0]</p>
<p>ret &#x3D; cv.matchShapes(cnt1,cnt2,1,0.0)<br>print( ret )<br>@endcode<br>I tried matching shapes with different shapes given below:</p>
<p><img src="/images/matchshapes.jpg" alt="image"></p>
<p>I got following results:</p>
<ul>
<li>Matching Image A with itself &#x3D; 0.0</li>
<li>Matching Image A with Image B &#x3D; 0.001946</li>
<li>Matching Image A with Image C &#x3D; 0.326911</li>
</ul>
<p>See, even image rotation doesn’t affect much on this comparison.</p>
<p>@note <a href="http://en.wikipedia.org/wiki/Image_moment#Rotation_invariant_moments">Hu-Moments</a> are seven<br>moments invariant to translation, rotation and scale. Seventh one is skew-invariant. Those values<br>can be found using <strong>cv.HuMoments()</strong> function.</p>
<h1 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h1><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><p>-#  Check the documentation for <strong>cv.pointPolygonTest()</strong>, you can find a nice image in Red and<br>    Blue color. It represents the distance from all pixels to the white curve on it. All pixels<br>    inside curve is blue depending on the distance. Similarly outside points are red. Contour edges<br>    are marked with White. So problem is simple. Write a code to create such a representation of<br>    distance.<br>-#  Compare images of digits or letters using <strong>cv.matchShapes()</strong>. ( That would be a simple step<br>    towards OCR )</p>
