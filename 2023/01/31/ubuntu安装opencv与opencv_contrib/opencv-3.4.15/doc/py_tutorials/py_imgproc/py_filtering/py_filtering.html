<h1 id="Smoothing-Images-tutorial-py-filtering"><a href="#Smoothing-Images-tutorial-py-filtering" class="headerlink" title="Smoothing Images {#tutorial_py_filtering}"></a>Smoothing Images {#tutorial_py_filtering}</h1><h2 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h2><p>Learn to:<br>    -   Blur images with various low pass filters<br>    -   Apply custom-made filters to images (2D convolution)</p>
<h2 id="2D-Convolution-Image-Filtering"><a href="#2D-Convolution-Image-Filtering" class="headerlink" title="2D Convolution ( Image Filtering )"></a>2D Convolution ( Image Filtering )</h2><p>As in one-dimensional signals, images also can be filtered with various low-pass filters (LPF),<br>high-pass filters (HPF), etc. LPF helps in removing noise, blurring images, etc. HPF filters help<br>in finding edges in images.</p>
<p>OpenCV provides a function <strong>cv.filter2D()</strong> to convolve a kernel with an image. As an example, we<br>will try an averaging filter on an image. A 5x5 averaging filter kernel will look like the below:</p>
<p>\f[K &#x3D;  \frac{1}{25} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1  \ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \end{bmatrix}\f]</p>
<p>The operation works like this: keep this kernel above a pixel, add all the 25 pixels below this kernel,<br>take the average, and replace the central pixel with the new average value. This operation is continued<br>for all the pixels in the image. Try this code and check the result:<br>@code{.py}<br>import numpy as np<br>import cv2 as cv<br>from matplotlib import pyplot as plt</p>
<p>img &#x3D; cv.imread(‘opencv_logo.png’)</p>
<p>kernel &#x3D; np.ones((5,5),np.float32)&#x2F;25<br>dst &#x3D; cv.filter2D(img,-1,kernel)</p>
<p>plt.subplot(121),plt.imshow(img),plt.title(‘Original’)<br>plt.xticks([]), plt.yticks([])<br>plt.subplot(122),plt.imshow(dst),plt.title(‘Averaging’)<br>plt.xticks([]), plt.yticks([])<br>plt.show()<br>@endcode<br>Result:</p>
<p><img src="/images/filter.jpg" alt="image"></p>
<h2 id="Image-Blurring-Image-Smoothing"><a href="#Image-Blurring-Image-Smoothing" class="headerlink" title="Image Blurring (Image Smoothing)"></a>Image Blurring (Image Smoothing)</h2><p>Image blurring is achieved by convolving the image with a low-pass filter kernel. It is useful for<br>removing noise. It actually removes high frequency content (eg: noise, edges) from the image. So<br>edges are blurred a little bit in this operation (there are also blurring techniques which don’t<br>blur the edges). OpenCV provides four main types of blurring techniques.</p>
<h3 id="1-Averaging"><a href="#1-Averaging" class="headerlink" title="1. Averaging"></a>1. Averaging</h3><p>This is done by convolving an image with a normalized box filter. It simply takes the average of all<br>the pixels under the kernel area and replaces the central element. This is done by the function<br><strong>cv.blur()</strong> or <strong>cv.boxFilter()</strong>. Check the docs for more details about the kernel. We should<br>specify the width and height of the kernel. A 3x3 normalized box filter would look like the below:</p>
<p>\f[K &#x3D;  \frac{1}{9} \begin{bmatrix} 1 &amp; 1 &amp; 1  \ 1 &amp; 1 &amp; 1 \ 1 &amp; 1 &amp; 1 \end{bmatrix}\f]</p>
<p>@note If you don’t want to use a normalized box filter, use <strong>cv.boxFilter()</strong>. Pass an argument<br>normalize&#x3D;False to the function.</p>
<p>Check a sample demo below with a kernel of 5x5 size:<br>@code{.py}<br>import cv2 as cv<br>import numpy as np<br>from matplotlib import pyplot as plt</p>
<p>img &#x3D; cv.imread(‘opencv-logo-white.png’)</p>
<p>blur &#x3D; cv.blur(img,(5,5))</p>
<p>plt.subplot(121),plt.imshow(img),plt.title(‘Original’)<br>plt.xticks([]), plt.yticks([])<br>plt.subplot(122),plt.imshow(blur),plt.title(‘Blurred’)<br>plt.xticks([]), plt.yticks([])<br>plt.show()<br>@endcode<br>Result:</p>
<p><img src="/images/blur.jpg" alt="image"></p>
<h3 id="2-Gaussian-Blurring"><a href="#2-Gaussian-Blurring" class="headerlink" title="2. Gaussian Blurring"></a>2. Gaussian Blurring</h3><p>In this method, instead of a box filter, a Gaussian kernel is used. It is done with the function,<br><strong>cv.GaussianBlur()</strong>. We should specify the width and height of the kernel which should be positive<br>and odd. We also should specify the standard deviation in the X and Y directions, sigmaX and sigmaY<br>respectively. If only sigmaX is specified, sigmaY is taken as the same as sigmaX. If both are given as<br>zeros, they are calculated from the kernel size. Gaussian blurring is highly effective in removing<br>Gaussian noise from an image.</p>
<p>If you want, you can create a Gaussian kernel with the function, <strong>cv.getGaussianKernel()</strong>.</p>
<p>The above code can be modified for Gaussian blurring:<br>@code{.py}<br>blur &#x3D; cv.GaussianBlur(img,(5,5),0)<br>@endcode<br>Result:</p>
<p><img src="/images/gaussian.jpg" alt="image"></p>
<h3 id="3-Median-Blurring"><a href="#3-Median-Blurring" class="headerlink" title="3. Median Blurring"></a>3. Median Blurring</h3><p>Here, the function <strong>cv.medianBlur()</strong> takes the median of all the pixels under the kernel area and the central<br>element is replaced with this median value. This is highly effective against salt-and-pepper noise<br>in an image. Interestingly, in the above filters, the central element is a newly<br>calculated value which may be a pixel value in the image or a new value. But in median blurring,<br>the central element is always replaced by some pixel value in the image. It reduces the noise<br>effectively. Its kernel size should be a positive odd integer.</p>
<p>In this demo, I added a 50% noise to our original image and applied median blurring. Check the result:<br>@code{.py}<br>median &#x3D; cv.medianBlur(img,5)<br>@endcode<br>Result:</p>
<p><img src="/images/median.jpg" alt="image"></p>
<h3 id="4-Bilateral-Filtering"><a href="#4-Bilateral-Filtering" class="headerlink" title="4. Bilateral Filtering"></a>4. Bilateral Filtering</h3><p><strong>cv.bilateralFilter()</strong> is highly effective in noise removal while keeping edges sharp. But the<br>operation is slower compared to other filters. We already saw that a Gaussian filter takes the<br>neighbourhood around the pixel and finds its Gaussian weighted average. This Gaussian filter is a<br>function of space alone, that is, nearby pixels are considered while filtering. It doesn’t consider<br>whether pixels have almost the same intensity. It doesn’t consider whether a pixel is an edge pixel or<br>not. So it blurs the edges also, which we don’t want to do.</p>
<p>Bilateral filtering also takes a Gaussian filter in space, but one more Gaussian filter which is a<br>function of pixel difference. The Gaussian function of space makes sure that only nearby pixels are considered<br>for blurring, while the Gaussian function of intensity difference makes sure that only those pixels with<br>similar intensities to the central pixel are considered for blurring. So it preserves the edges since<br>pixels at edges will have large intensity variation.</p>
<p>The below sample shows use of a bilateral filter (For details on arguments, visit docs).<br>@code{.py}<br>blur &#x3D; cv.bilateralFilter(img,9,75,75)<br>@endcode<br>Result:</p>
<p><img src="/images/bilateral.jpg" alt="image"></p>
<p>See, the texture on the surface is gone, but the edges are still preserved.</p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><p>-#  Details about the <a href="http://people.csail.mit.edu/sparis/bf_course/">bilateral filtering</a></p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>