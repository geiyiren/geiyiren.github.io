<h1 id="Image-Gradients-tutorial-py-gradients"><a href="#Image-Gradients-tutorial-py-gradients" class="headerlink" title="Image Gradients {#tutorial_py_gradients}"></a>Image Gradients {#tutorial_py_gradients}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter, we will learn to:</p>
<ul>
<li>Find Image gradients, edges etc</li>
<li>We will see following functions : <strong>cv.Sobel()</strong>, <strong>cv.Scharr()</strong>, <strong>cv.Laplacian()</strong> etc</li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>OpenCV provides three types of gradient filters or High-pass filters, Sobel, Scharr and Laplacian.<br>We will see each one of them.</p>
<h3 id="1-Sobel-and-Scharr-Derivatives"><a href="#1-Sobel-and-Scharr-Derivatives" class="headerlink" title="1. Sobel and Scharr Derivatives"></a>1. Sobel and Scharr Derivatives</h3><p>Sobel operators is a joint Gausssian smoothing plus differentiation operation, so it is more<br>resistant to noise. You can specify the direction of derivatives to be taken, vertical or horizontal<br>(by the arguments, yorder and xorder respectively). You can also specify the size of kernel by the<br>argument ksize. If ksize &#x3D; -1, a 3x3 Scharr filter is used which gives better results than 3x3 Sobel<br>filter. Please see the docs for kernels used.</p>
<h3 id="2-Laplacian-Derivatives"><a href="#2-Laplacian-Derivatives" class="headerlink" title="2. Laplacian Derivatives"></a>2. Laplacian Derivatives</h3><p>It calculates the Laplacian of the image given by the relation,<br>\f$\Delta src &#x3D; \frac{\partial ^2{src}}{\partial x^2} + \frac{\partial ^2{src}}{\partial y^2}\f$ where<br>each derivative is found using Sobel derivatives. If ksize &#x3D; 1, then following kernel is used for<br>filtering:</p>
<p>\f[kernel &#x3D; \begin{bmatrix} 0 &amp; 1 &amp; 0 \ 1 &amp; -4 &amp; 1 \ 0 &amp; 1 &amp; 0  \end{bmatrix}\f]</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>Below code shows all operators in a single diagram. All kernels are of 5x5 size. Depth of output<br>image is passed -1 to get the result in np.uint8 type.<br>@code{.py}<br>import numpy as np<br>import cv2 as cv<br>from matplotlib import pyplot as plt</p>
<p>img &#x3D; cv.imread(‘dave.jpg’,0)</p>
<p>laplacian &#x3D; cv.Laplacian(img,cv.CV_64F)<br>sobelx &#x3D; cv.Sobel(img,cv.CV_64F,1,0,ksize&#x3D;5)<br>sobely &#x3D; cv.Sobel(img,cv.CV_64F,0,1,ksize&#x3D;5)</p>
<p>plt.subplot(2,2,1),plt.imshow(img,cmap &#x3D; ‘gray’)<br>plt.title(‘Original’), plt.xticks([]), plt.yticks([])<br>plt.subplot(2,2,2),plt.imshow(laplacian,cmap &#x3D; ‘gray’)<br>plt.title(‘Laplacian’), plt.xticks([]), plt.yticks([])<br>plt.subplot(2,2,3),plt.imshow(sobelx,cmap &#x3D; ‘gray’)<br>plt.title(‘Sobel X’), plt.xticks([]), plt.yticks([])<br>plt.subplot(2,2,4),plt.imshow(sobely,cmap &#x3D; ‘gray’)<br>plt.title(‘Sobel Y’), plt.xticks([]), plt.yticks([])</p>
<p>plt.show()<br>@endcode<br>Result:</p>
<p><img src="/images/gradients.jpg" alt="image"></p>
<h2 id="One-Important-Matter"><a href="#One-Important-Matter" class="headerlink" title="One Important Matter!"></a>One Important Matter!</h2><p>In our last example, output datatype is cv.CV_8U or np.uint8. But there is a slight problem with<br>that. Black-to-White transition is taken as Positive slope (it has a positive value) while<br>White-to-Black transition is taken as a Negative slope (It has negative value). So when you convert<br>data to np.uint8, all negative slopes are made zero. In simple words, you miss that edge.</p>
<p>If you want to detect both edges, better option is to keep the output datatype to some higher forms,<br>like cv.CV_16S, cv.CV_64F etc, take its absolute value and then convert back to cv.CV_8U.<br>Below code demonstrates this procedure for a horizontal Sobel filter and difference in results.<br>@code{.py}<br>import numpy as np<br>import cv2 as cv<br>from matplotlib import pyplot as plt</p>
<p>img &#x3D; cv.imread(‘box.png’,0)</p>
<h1 id="Output-dtype-x3D-cv-CV-8U"><a href="#Output-dtype-x3D-cv-CV-8U" class="headerlink" title="Output dtype &#x3D; cv.CV_8U"></a>Output dtype &#x3D; cv.CV_8U</h1><p>sobelx8u &#x3D; cv.Sobel(img,cv.CV_8U,1,0,ksize&#x3D;5)</p>
<h1 id="Output-dtype-x3D-cv-CV-64F-Then-take-its-absolute-and-convert-to-cv-CV-8U"><a href="#Output-dtype-x3D-cv-CV-64F-Then-take-its-absolute-and-convert-to-cv-CV-8U" class="headerlink" title="Output dtype &#x3D; cv.CV_64F. Then take its absolute and convert to cv.CV_8U"></a>Output dtype &#x3D; cv.CV_64F. Then take its absolute and convert to cv.CV_8U</h1><p>sobelx64f &#x3D; cv.Sobel(img,cv.CV_64F,1,0,ksize&#x3D;5)<br>abs_sobel64f &#x3D; np.absolute(sobelx64f)<br>sobel_8u &#x3D; np.uint8(abs_sobel64f)</p>
<p>plt.subplot(1,3,1),plt.imshow(img,cmap &#x3D; ‘gray’)<br>plt.title(‘Original’), plt.xticks([]), plt.yticks([])<br>plt.subplot(1,3,2),plt.imshow(sobelx8u,cmap &#x3D; ‘gray’)<br>plt.title(‘Sobel CV_8U’), plt.xticks([]), plt.yticks([])<br>plt.subplot(1,3,3),plt.imshow(sobel_8u,cmap &#x3D; ‘gray’)<br>plt.title(‘Sobel abs(CV_64F)’), plt.xticks([]), plt.yticks([])</p>
<p>plt.show()<br>@endcode<br>Check the result below:</p>
<p><img src="/images/double_edge.jpg" alt="image"></p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>