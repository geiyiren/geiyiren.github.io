<h1 id="Histogram-4-Histogram-Backprojection-tutorial-py-histogram-backprojection"><a href="#Histogram-4-Histogram-Backprojection-tutorial-py-histogram-backprojection" class="headerlink" title="Histogram - 4 : Histogram Backprojection {#tutorial_py_histogram_backprojection}"></a>Histogram - 4 : Histogram Backprojection {#tutorial_py_histogram_backprojection}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter, we will learn about histogram backprojection.</p>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>It was proposed by <strong>Michael J. Swain , Dana H. Ballard</strong> in their paper <strong>Indexing via color<br>histograms</strong>.</p>
<p><strong>What is it actually in simple words?</strong> It is used for image segmentation or finding objects of<br>interest in an image. In simple words, it creates an image of the same size (but single channel) as<br>that of our input image, where each pixel corresponds to the probability of that pixel belonging to<br>our object. In more simpler words, the output image will have our object of interest in more white<br>compared to remaining part. Well, that is an intuitive explanation. (I can’t make it more simpler).<br>Histogram Backprojection is used with camshift algorithm etc.</p>
<p><strong>How do we do it ?</strong> We create a histogram of an image containing our object of interest (in our<br>case, the ground, leaving player and other things). The object should fill the image as far as<br>possible for better results. And a color histogram is preferred over grayscale histogram, because<br>color of the object is a better way to define the object than its grayscale intensity. We then<br>“back-project” this histogram over our test image where we need to find the object, ie in other<br>words, we calculate the probability of every pixel belonging to the ground and show it. The<br>resulting output on proper thresholding gives us the ground alone.</p>
<h2 id="Algorithm-in-Numpy"><a href="#Algorithm-in-Numpy" class="headerlink" title="Algorithm in Numpy"></a>Algorithm in Numpy</h2><p>-#  First we need to calculate the color histogram of both the object we need to find (let it be<br>    ‘M’) and the image where we are going to search (let it be ‘I’).<br>@code{.py}<br>import numpy as np<br>import cv2 as cvfrom matplotlib import pyplot as plt</p>
<p>#roi is the object or region of object we need to find<br>roi &#x3D; cv.imread(‘rose_red.png’)<br>hsv &#x3D; cv.cvtColor(roi,cv.COLOR_BGR2HSV)</p>
<p>#target is the image we search in<br>target &#x3D; cv.imread(‘rose.png’)<br>hsvt &#x3D; cv.cvtColor(target,cv.COLOR_BGR2HSV)</p>
<h1 id="Find-the-histograms-using-calcHist-Can-be-done-with-np-histogram2d-also"><a href="#Find-the-histograms-using-calcHist-Can-be-done-with-np-histogram2d-also" class="headerlink" title="Find the histograms using calcHist. Can be done with np.histogram2d also"></a>Find the histograms using calcHist. Can be done with np.histogram2d also</h1><p>M &#x3D; cv.calcHist([hsv],[0, 1], None, [180, 256], [0, 180, 0, 256] )<br>I &#x3D; cv.calcHist([hsvt],[0, 1], None, [180, 256], [0, 180, 0, 256] )<br>@endcode<br>2.  Find the ratio \f$R &#x3D; \frac{M}{I}\f$. Then backproject R, ie use R as palette and create a new image<br>    with every pixel as its corresponding probability of being target. ie B(x,y) &#x3D; R[h(x,y),s(x,y)]<br>    where h is hue and s is saturation of the pixel at (x,y). After that apply the condition<br>    \f$B(x,y) &#x3D; min[B(x,y), 1]\f$.<br>@code{.py}<br>h,s,v &#x3D; cv.split(hsvt)<br>B &#x3D; R[h.ravel(),s.ravel()]<br>B &#x3D; np.minimum(B,1)<br>B &#x3D; B.reshape(hsvt.shape[:2])<br>@endcode<br>3.  Now apply a convolution with a circular disc, \f$B &#x3D; D \ast B\f$, where D is the disc kernel.<br>@code{.py}<br>disc &#x3D; cv.getStructuringElement(cv.MORPH_ELLIPSE,(5,5))<br>cv.filter2D(B,-1,disc,B)<br>B &#x3D; np.uint8(B)<br>cv.normalize(B,B,0,255,cv.NORM_MINMAX)<br>@endcode<br>4.  Now the location of maximum intensity gives us the location of object. If we are expecting a<br>    region in the image, thresholding for a suitable value gives a nice result.<br>@code{.py}<br>ret,thresh &#x3D; cv.threshold(B,50,255,0)<br>@endcode<br>That’s it !!</p>
<h2 id="Backprojection-in-OpenCV"><a href="#Backprojection-in-OpenCV" class="headerlink" title="Backprojection in OpenCV"></a>Backprojection in OpenCV</h2><p>OpenCV provides an inbuilt function <strong>cv.calcBackProject()</strong>. Its parameters are almost same as the<br><strong>cv.calcHist()</strong> function. One of its parameter is histogram which is histogram of the object and<br>we have to find it. Also, the object histogram should be normalized before passing on to the<br>backproject function. It returns the probability image. Then we convolve the image with a disc<br>kernel and apply threshold. Below is my code and output :<br>@code{.py}<br>import numpy as np<br>import cv2 as cv</p>
<p>roi &#x3D; cv.imread(‘rose_red.png’)<br>hsv &#x3D; cv.cvtColor(roi,cv.COLOR_BGR2HSV)</p>
<p>target &#x3D; cv.imread(‘rose.png’)<br>hsvt &#x3D; cv.cvtColor(target,cv.COLOR_BGR2HSV)</p>
<h1 id="calculating-object-histogram"><a href="#calculating-object-histogram" class="headerlink" title="calculating object histogram"></a>calculating object histogram</h1><p>roihist &#x3D; cv.calcHist([hsv],[0, 1], None, [180, 256], [0, 180, 0, 256] )</p>
<h1 id="normalize-histogram-and-apply-backprojection"><a href="#normalize-histogram-and-apply-backprojection" class="headerlink" title="normalize histogram and apply backprojection"></a>normalize histogram and apply backprojection</h1><p>cv.normalize(roihist,roihist,0,255,cv.NORM_MINMAX)<br>dst &#x3D; cv.calcBackProject([hsvt],[0,1],roihist,[0,180,0,256],1)</p>
<h1 id="Now-convolute-with-circular-disc"><a href="#Now-convolute-with-circular-disc" class="headerlink" title="Now convolute with circular disc"></a>Now convolute with circular disc</h1><p>disc &#x3D; cv.getStructuringElement(cv.MORPH_ELLIPSE,(5,5))<br>cv.filter2D(dst,-1,disc,dst)</p>
<h1 id="threshold-and-binary-AND"><a href="#threshold-and-binary-AND" class="headerlink" title="threshold and binary AND"></a>threshold and binary AND</h1><p>ret,thresh &#x3D; cv.threshold(dst,50,255,0)<br>thresh &#x3D; cv.merge((thresh,thresh,thresh))<br>res &#x3D; cv.bitwise_and(target,thresh)</p>
<p>res &#x3D; np.vstack((target,thresh,res))<br>cv.imwrite(‘res.jpg’,res)<br>@endcode<br>Below is one example I worked with. I used the region inside blue rectangle as sample object and I<br>wanted to extract the full ground.</p>
<p><img src="/images/backproject_opencv.jpg" alt="image"></p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><p>-#  “Indexing via color histograms”, Swain, Michael J. , Third international conference on computer<br>    vision,1990.</p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>