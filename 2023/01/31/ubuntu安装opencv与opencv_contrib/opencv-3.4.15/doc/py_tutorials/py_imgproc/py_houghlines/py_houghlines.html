<h1 id="Hough-Line-Transform-tutorial-py-houghlines"><a href="#Hough-Line-Transform-tutorial-py-houghlines" class="headerlink" title="Hough Line Transform {#tutorial_py_houghlines}"></a>Hough Line Transform {#tutorial_py_houghlines}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter,<br>    -   We will understand the concept of the Hough Transform.<br>    -   We will see how to use it to detect lines in an image.<br>    -   We will see the following functions: <strong>cv.HoughLines()</strong>, <strong>cv.HoughLinesP()</strong></p>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>The Hough Transform is a popular technique to detect any shape, if you can represent that shape in a<br>mathematical form. It can detect the shape even if it is broken or distorted a little bit. We will<br>see how it works for a line.</p>
<p>A line can be represented as \f$y &#x3D; mx+c\f$ or in a parametric form, as<br>\f$\rho &#x3D; x \cos \theta + y \sin \theta\f$ where \f$\rho\f$ is the perpendicular distance from the origin to the<br>line, and \f$\theta\f$ is the angle formed by this perpendicular line and the horizontal axis measured in<br>counter-clockwise (That direction varies on how you represent the coordinate system. This<br>representation is used in OpenCV). Check the image below:</p>
<p><img src="/images/houghlines1.svg" alt="image"></p>
<p>So if the line is passing below the origin, it will have a positive rho and an angle less than 180. If it<br>is going above the origin, instead of taking an angle greater than 180, the angle is taken less than 180,<br>and rho is taken negative. Any vertical line will have 0 degree and horizontal lines will have 90<br>degree.</p>
<p>Now let’s see how the Hough Transform works for lines. Any line can be represented in these two terms,<br>\f$(\rho, \theta)\f$. So first it creates a 2D array or accumulator (to hold the values of the two parameters)<br>and it is set to 0 initially. Let rows denote the \f$\rho\f$ and columns denote the \f$\theta\f$. Size of<br>array depends on the accuracy you need. Suppose you want the accuracy of angles to be 1 degree, you will<br>need 180 columns. For \f$\rho\f$, the maximum distance possible is the diagonal length of the image. So<br>taking one pixel accuracy, the number of rows can be the diagonal length of the image.</p>
<p>Consider a 100x100 image with a horizontal line at the middle. Take the first point of the line. You<br>know its (x,y) values. Now in the line equation, put the values \f$\theta &#x3D; 0,1,2,….,180\f$ and check<br>the \f$\rho\f$ you get. For every \f$(\rho, \theta)\f$ pair, you increment value by one in our accumulator<br>in its corresponding \f$(\rho, \theta)\f$ cells. So now in accumulator, the cell (50,90) &#x3D; 1 along with<br>some other cells.</p>
<p>Now take the second point on the line. Do the same as above. Increment the values in the cells<br>corresponding to <code>(rho, theta)</code> you got. This time, the cell (50,90) &#x3D; 2. What you actually<br>do is voting the \f$(\rho, \theta)\f$ values. You continue this process for every point on the line. At<br>each point, the cell (50,90) will be incremented or voted up, while other cells may or may not be<br>voted up. This way, at the end, the cell (50,90) will have maximum votes. So if you search the<br>accumulator for maximum votes, you get the value (50,90) which says, there is a line in this image<br>at a distance 50 from the origin and at angle 90 degrees. It is well shown in the below animation (Image<br>Courtesy: <a href="http://homepages.inf.ed.ac.uk/amos/hough.html">Amos Storkey</a> )</p>
<p><img src="/images/houghlinesdemo.gif"></p>
<p>This is how hough transform works for lines. It is simple, and may be you can implement it using<br>Numpy on your own. Below is an image which shows the accumulator. Bright spots at some locations<br>denote they are the parameters of possible lines in the image. (Image courtesy: <a href="http://en.wikipedia.org/wiki/Hough_transform">Wikipedia</a> )</p>
<p><img src="/images/houghlines2.jpg"></p>
<h1 id="Hough-Transform-in-OpenCV"><a href="#Hough-Transform-in-OpenCV" class="headerlink" title="Hough Transform in OpenCV"></a>Hough Transform in OpenCV</h1><p>Everything explained above is encapsulated in the OpenCV function, <strong>cv.HoughLines()</strong>. It simply returns an array of :math:(rho,<br>theta)` values. \f$\rho\f$ is measured in pixels and \f$\theta\f$ is measured in radians. First parameter,<br>Input image should be a binary image, so apply threshold or use canny edge detection before<br>applying hough transform. Second and third parameters are \f$\rho\f$ and \f$\theta\f$ accuracies<br>respectively. Fourth argument is the threshold, which means the minimum vote it should get to be<br>considered as a line. Remember, number of votes depends upon the number of points on the line. So it<br>represents the minimum length of line that should be detected.<br>@include hough_line_transform.py<br>Check the results below:</p>
<p><img src="/images/houghlines3.jpg" alt="image"></p>
<h2 id="Probabilistic-Hough-Transform"><a href="#Probabilistic-Hough-Transform" class="headerlink" title="Probabilistic Hough Transform"></a>Probabilistic Hough Transform</h2><p>In the hough transform, you can see that even for a line with two arguments, it takes a lot of<br>computation. Probabilistic Hough Transform is an optimization of the Hough Transform we saw. It doesn’t<br>take all the points into consideration. Instead, it takes only a random subset of points which is<br>sufficient for line detection. We just have to decrease the threshold. See image below which compares<br>Hough Transform and Probabilistic Hough Transform in Hough space. (Image Courtesy :<br><a href="http://phdfb1.free.fr/robot/mscthesis/node14.html">Franck Bettinger’s home page</a> )</p>
<p><img src="/images/houghlines4.png" alt="image"></p>
<p>OpenCV implementation is based on Robust Detection of Lines Using the Progressive Probabilistic<br>Hough Transform by Matas, J. and Galambos, C. and Kittler, J.V. @cite Matas00. The function used is<br><strong>cv.HoughLinesP()</strong>. It has two new arguments.</p>
<ul>
<li><strong>minLineLength</strong> - Minimum length of line. Line segments shorter than this are rejected.</li>
<li><strong>maxLineGap</strong> - Maximum allowed gap between line segments to treat them as a single line.</li>
</ul>
<p>Best thing is that, it directly returns the two endpoints of lines. In previous case, you got only<br>the parameters of lines, and you had to find all the points. Here, everything is direct and simple.<br>@include probabilistic_hough_line_transform.py<br>See the results below:</p>
<p><img src="/images/houghlines5.jpg" alt="image"></p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><p>-#  <a href="http://en.wikipedia.org/wiki/Hough_transform">Hough Transform on Wikipedia</a></p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>