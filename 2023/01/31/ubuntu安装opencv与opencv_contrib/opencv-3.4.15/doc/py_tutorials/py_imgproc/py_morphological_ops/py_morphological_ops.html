<h1 id="Morphological-Transformations-tutorial-py-morphological-ops"><a href="#Morphological-Transformations-tutorial-py-morphological-ops" class="headerlink" title="Morphological Transformations {#tutorial_py_morphological_ops}"></a>Morphological Transformations {#tutorial_py_morphological_ops}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter,<br>    -   We will learn different morphological operations like Erosion, Dilation, Opening, Closing<br>        etc.<br>    -   We will see different functions like : <strong>cv.erode()</strong>, <strong>cv.dilate()</strong>,<br>        <strong>cv.morphologyEx()</strong> etc.</p>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>Morphological transformations are some simple operations based on the image shape. It is normally<br>performed on binary images. It needs two inputs, one is our original image, second one is called<br><strong>structuring element</strong> or <strong>kernel</strong> which decides the nature of operation. Two basic morphological<br>operators are Erosion and Dilation. Then its variant forms like Opening, Closing, Gradient etc also<br>comes into play. We will see them one-by-one with help of following image:</p>
<p><img src="/images/j.png" alt="image"></p>
<h3 id="1-Erosion"><a href="#1-Erosion" class="headerlink" title="1. Erosion"></a>1. Erosion</h3><p>The basic idea of erosion is just like soil erosion only, it erodes away the boundaries of<br>foreground object (Always try to keep foreground in white). So what it does? The kernel slides<br>through the image (as in 2D convolution). A pixel in the original image (either 1 or 0) will be<br>considered 1 only if all the pixels under the kernel is 1, otherwise it is eroded (made to zero).</p>
<p>So what happends is that, all the pixels near boundary will be discarded depending upon the size of<br>kernel. So the thickness or size of the foreground object decreases or simply white region decreases<br>in the image. It is useful for removing small white noises (as we have seen in colorspace chapter),<br>detach two connected objects etc.</p>
<p>Here, as an example, I would use a 5x5 kernel with full of ones. Let’s see it how it works:<br>@code{.py}<br>import cv2 as cv<br>import numpy as np</p>
<p>img &#x3D; cv.imread(‘j.png’,0)<br>kernel &#x3D; np.ones((5,5),np.uint8)<br>erosion &#x3D; cv.erode(img,kernel,iterations &#x3D; 1)<br>@endcode<br>Result:</p>
<p><img src="/images/erosion.png" alt="image"></p>
<h3 id="2-Dilation"><a href="#2-Dilation" class="headerlink" title="2. Dilation"></a>2. Dilation</h3><p>It is just opposite of erosion. Here, a pixel element is ‘1’ if atleast one pixel under the kernel<br>is ‘1’. So it increases the white region in the image or size of foreground object increases.<br>Normally, in cases like noise removal, erosion is followed by dilation. Because, erosion removes<br>white noises, but it also shrinks our object. So we dilate it. Since noise is gone, they won’t come<br>back, but our object area increases. It is also useful in joining broken parts of an object.<br>@code{.py}<br>dilation &#x3D; cv.dilate(img,kernel,iterations &#x3D; 1)<br>@endcode<br>Result:</p>
<p><img src="/images/dilation.png" alt="image"></p>
<h3 id="3-Opening"><a href="#3-Opening" class="headerlink" title="3. Opening"></a>3. Opening</h3><p>Opening is just another name of <strong>erosion followed by dilation</strong>. It is useful in removing noise, as<br>we explained above. Here we use the function, <strong>cv.morphologyEx()</strong><br>@code{.py}<br>opening &#x3D; cv.morphologyEx(img, cv.MORPH_OPEN, kernel)<br>@endcode<br>Result:</p>
<p><img src="/images/opening.png" alt="image"></p>
<h3 id="4-Closing"><a href="#4-Closing" class="headerlink" title="4. Closing"></a>4. Closing</h3><p>Closing is reverse of Opening, <strong>Dilation followed by Erosion</strong>. It is useful in closing small holes<br>inside the foreground objects, or small black points on the object.<br>@code{.py}<br>closing &#x3D; cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)<br>@endcode<br>Result:</p>
<p><img src="/images/closing.png" alt="image"></p>
<h3 id="5-Morphological-Gradient"><a href="#5-Morphological-Gradient" class="headerlink" title="5. Morphological Gradient"></a>5. Morphological Gradient</h3><p>It is the difference between dilation and erosion of an image.</p>
<p>The result will look like the outline of the object.<br>@code{.py}<br>gradient &#x3D; cv.morphologyEx(img, cv.MORPH_GRADIENT, kernel)<br>@endcode<br>Result:</p>
<p><img src="/images/gradient.png" alt="image"></p>
<h3 id="6-Top-Hat"><a href="#6-Top-Hat" class="headerlink" title="6. Top Hat"></a>6. Top Hat</h3><p>It is the difference between input image and Opening of the image. Below example is done for a 9x9<br>kernel.<br>@code{.py}<br>tophat &#x3D; cv.morphologyEx(img, cv.MORPH_TOPHAT, kernel)<br>@endcode<br>Result:</p>
<p><img src="/images/tophat.png" alt="image"></p>
<h3 id="7-Black-Hat"><a href="#7-Black-Hat" class="headerlink" title="7. Black Hat"></a>7. Black Hat</h3><p>It is the difference between the closing of the input image and input image.<br>@code{.py}<br>blackhat &#x3D; cv.morphologyEx(img, cv.MORPH_BLACKHAT, kernel)<br>@endcode<br>Result:</p>
<p><img src="/images/blackhat.png" alt="image"></p>
<h2 id="Structuring-Element"><a href="#Structuring-Element" class="headerlink" title="Structuring Element"></a>Structuring Element</h2><p>We manually created a structuring elements in the previous examples with help of Numpy. It is<br>rectangular shape. But in some cases, you may need elliptical&#x2F;circular shaped kernels. So for this<br>purpose, OpenCV has a function, <strong>cv.getStructuringElement()</strong>. You just pass the shape and size of<br>the kernel, you get the desired kernel.<br>@code{.py}</p>
<h1 id="Rectangular-Kernel"><a href="#Rectangular-Kernel" class="headerlink" title="Rectangular Kernel"></a>Rectangular Kernel</h1><blockquote>
<blockquote>
<blockquote>
<p>cv.getStructuringElement(cv.MORPH_RECT,(5,5))<br>array([[1, 1, 1, 1, 1],<br>       [1, 1, 1, 1, 1],<br>       [1, 1, 1, 1, 1],<br>       [1, 1, 1, 1, 1],<br>       [1, 1, 1, 1, 1]], dtype&#x3D;uint8)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="Elliptical-Kernel"><a href="#Elliptical-Kernel" class="headerlink" title="Elliptical Kernel"></a>Elliptical Kernel</h1><blockquote>
<blockquote>
<blockquote>
<p>cv.getStructuringElement(cv.MORPH_ELLIPSE,(5,5))<br>array([[0, 0, 1, 0, 0],<br>       [1, 1, 1, 1, 1],<br>       [1, 1, 1, 1, 1],<br>       [1, 1, 1, 1, 1],<br>       [0, 0, 1, 0, 0]], dtype&#x3D;uint8)</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="Cross-shaped-Kernel"><a href="#Cross-shaped-Kernel" class="headerlink" title="Cross-shaped Kernel"></a>Cross-shaped Kernel</h1><blockquote>
<blockquote>
<blockquote>
<p>cv.getStructuringElement(cv.MORPH_CROSS,(5,5))<br>array([[0, 0, 1, 0, 0],<br>       [0, 0, 1, 0, 0],<br>       [1, 1, 1, 1, 1],<br>       [0, 0, 1, 0, 0],<br>       [0, 0, 1, 0, 0]], dtype&#x3D;uint8)<br>@endcode<br>Additional Resources</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>-#  <a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm">Morphological Operations</a> at HIPR2</p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>