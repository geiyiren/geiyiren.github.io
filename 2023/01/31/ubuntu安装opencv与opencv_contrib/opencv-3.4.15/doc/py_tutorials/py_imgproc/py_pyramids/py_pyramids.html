<h1 id="Image-Pyramids-tutorial-py-pyramids"><a href="#Image-Pyramids-tutorial-py-pyramids" class="headerlink" title="Image Pyramids {#tutorial_py_pyramids}"></a>Image Pyramids {#tutorial_py_pyramids}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter,<br>    -   We will learn about Image Pyramids<br>    -   We will use Image pyramids to create a new fruit, “Orapple”<br>    -   We will see these functions: <strong>cv.pyrUp()</strong>, <strong>cv.pyrDown()</strong></p>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>Normally, we used to work with an image of constant size. But on some occasions, we need to work<br>with (the same) images in different resolution. For example, while searching for something in<br>an image, like face, we are not sure at what size the object will be present in said image. In that<br>case, we will need to create a set of the same image with different resolutions and search for object<br>in all of them. These set of images with different resolutions are called <strong>Image Pyramids</strong> (because<br>when they are kept in a stack with the highest resolution image at the bottom and the lowest resolution<br>image at top, it looks like a pyramid).</p>
<p>There are two kinds of Image Pyramids. 1) <strong>Gaussian Pyramid</strong> and 2) <strong>Laplacian Pyramids</strong></p>
<p>Higher level (Low resolution) in a Gaussian Pyramid is formed by removing consecutive rows and<br>columns in Lower level (higher resolution) image. Then each pixel in higher level is formed by the<br>contribution from 5 pixels in underlying level with gaussian weights. By doing so, a \f$M \times N\f$<br>image becomes \f$M&#x2F;2 \times N&#x2F;2\f$ image. So area reduces to one-fourth of original area. It is called<br>an Octave. The same pattern continues as we go upper in pyramid (ie, resolution decreases).<br>Similarly while expanding, area becomes 4 times in each level. We can find Gaussian pyramids using<br><strong>cv.pyrDown()</strong> and <strong>cv.pyrUp()</strong> functions.<br>@code{.py}<br>img &#x3D; cv.imread(‘messi5.jpg’)<br>lower_reso &#x3D; cv.pyrDown(higher_reso)<br>@endcode<br>Below is the 4 levels in an image pyramid.</p>
<p><img src="/images/messipyr.jpg" alt="image"></p>
<p>Now you can go down the image pyramid with <strong>cv.pyrUp()</strong> function.<br>@code{.py}<br>higher_reso2 &#x3D; cv.pyrUp(lower_reso)<br>@endcode<br>Remember, higher_reso2 is not equal to higher_reso, because once you decrease the resolution, you<br>loose the information. Below image is 3 level down the pyramid created from smallest image in<br>previous case. Compare it with original image:</p>
<p><img src="/images/messiup.jpg" alt="image"></p>
<p>Laplacian Pyramids are formed from the Gaussian Pyramids. There is no exclusive function for that.<br>Laplacian pyramid images are like edge images only. Most of its elements are zeros. They are used in<br>image compression. A level in Laplacian Pyramid is formed by the difference between that level in<br>Gaussian Pyramid and expanded version of its upper level in Gaussian Pyramid. The three levels of a<br>Laplacian level will look like below (contrast is adjusted to enhance the contents):</p>
<p><img src="/images/lap.jpg" alt="image"></p>
<h2 id="Image-Blending-using-Pyramids"><a href="#Image-Blending-using-Pyramids" class="headerlink" title="Image Blending using Pyramids"></a>Image Blending using Pyramids</h2><p>One application of Pyramids is Image Blending. For example, in image stitching, you will need to<br>stack two images together, but it may not look good due to discontinuities between images. In that<br>case, image blending with Pyramids gives you seamless blending without leaving much data in the<br>images. One classical example of this is the blending of two fruits, Orange and Apple. See the<br>result now itself to understand what I am saying:</p>
<p><img src="/images/orapple.jpg" alt="image"></p>
<p>Please check first reference in additional resources, it has full diagramatic details on image<br>blending, Laplacian Pyramids etc. Simply it is done as follows:</p>
<p>-#  Load the two images of apple and orange<br>2.  Find the Gaussian Pyramids for apple and orange (in this particular example, number of levels<br>    is 6)<br>3.  From Gaussian Pyramids, find their Laplacian Pyramids<br>4.  Now join the left half of apple and right half of orange in each levels of Laplacian Pyramids<br>5.  Finally from this joint image pyramids, reconstruct the original image.</p>
<p>Below is the full code. (For sake of simplicity, each step is done separately which may take more<br>memory. You can optimize it if you want so).<br>@code{.py}<br>import cv2 as cv<br>import numpy as np,sys</p>
<p>A &#x3D; cv.imread(‘apple.jpg’)<br>B &#x3D; cv.imread(‘orange.jpg’)</p>
<h1 id="generate-Gaussian-pyramid-for-A"><a href="#generate-Gaussian-pyramid-for-A" class="headerlink" title="generate Gaussian pyramid for A"></a>generate Gaussian pyramid for A</h1><p>G &#x3D; A.copy()<br>gpA &#x3D; [G]<br>for i in range(6):<br>    G &#x3D; cv.pyrDown(G)<br>    gpA.append(G)</p>
<h1 id="generate-Gaussian-pyramid-for-B"><a href="#generate-Gaussian-pyramid-for-B" class="headerlink" title="generate Gaussian pyramid for B"></a>generate Gaussian pyramid for B</h1><p>G &#x3D; B.copy()<br>gpB &#x3D; [G]<br>for i in range(6):<br>    G &#x3D; cv.pyrDown(G)<br>    gpB.append(G)</p>
<h1 id="generate-Laplacian-Pyramid-for-A"><a href="#generate-Laplacian-Pyramid-for-A" class="headerlink" title="generate Laplacian Pyramid for A"></a>generate Laplacian Pyramid for A</h1><p>lpA &#x3D; [gpA[5]]<br>for i in range(5,0,-1):<br>    GE &#x3D; cv.pyrUp(gpA[i])<br>    L &#x3D; cv.subtract(gpA[i-1],GE)<br>    lpA.append(L)</p>
<h1 id="generate-Laplacian-Pyramid-for-B"><a href="#generate-Laplacian-Pyramid-for-B" class="headerlink" title="generate Laplacian Pyramid for B"></a>generate Laplacian Pyramid for B</h1><p>lpB &#x3D; [gpB[5]]<br>for i in range(5,0,-1):<br>    GE &#x3D; cv.pyrUp(gpB[i])<br>    L &#x3D; cv.subtract(gpB[i-1],GE)<br>    lpB.append(L)</p>
<h1 id="Now-add-left-and-right-halves-of-images-in-each-level"><a href="#Now-add-left-and-right-halves-of-images-in-each-level" class="headerlink" title="Now add left and right halves of images in each level"></a>Now add left and right halves of images in each level</h1><p>LS &#x3D; []<br>for la,lb in zip(lpA,lpB):<br>    rows,cols,dpt &#x3D; la.shape<br>    ls &#x3D; np.hstack((la[:,0:cols&#x2F;2], lb[:,cols&#x2F;2:]))<br>    LS.append(ls)</p>
<h1 id="now-reconstruct"><a href="#now-reconstruct" class="headerlink" title="now reconstruct"></a>now reconstruct</h1><p>ls_ &#x3D; LS[0]<br>for i in range(1,6):<br>    ls_ &#x3D; cv.pyrUp(ls_)<br>    ls_ &#x3D; cv.add(ls_, LS[i])</p>
<h1 id="image-with-direct-connecting-each-half"><a href="#image-with-direct-connecting-each-half" class="headerlink" title="image with direct connecting each half"></a>image with direct connecting each half</h1><p>real &#x3D; np.hstack((A[:,:cols&#x2F;2],B[:,cols&#x2F;2:]))</p>
<h2 id="cv-imwrite-‘Pyramid-blending2-jpg’-ls-cv-imwrite-‘Direct-blending-jpg’-real-endcodeAdditional-Resources"><a href="#cv-imwrite-‘Pyramid-blending2-jpg’-ls-cv-imwrite-‘Direct-blending-jpg’-real-endcodeAdditional-Resources" class="headerlink" title="cv.imwrite(‘Pyramid_blending2.jpg’,ls_)cv.imwrite(‘Direct_blending.jpg’,real)@endcodeAdditional Resources"></a>cv.imwrite(‘Pyramid_blending2.jpg’,ls_)<br>cv.imwrite(‘Direct_blending.jpg’,real)<br>@endcode<br>Additional Resources</h2><p>-#  <a href="http://pages.cs.wisc.edu/~csverma/CS766_09/ImageMosaic/imagemosaic.html">Image Blending</a></p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>