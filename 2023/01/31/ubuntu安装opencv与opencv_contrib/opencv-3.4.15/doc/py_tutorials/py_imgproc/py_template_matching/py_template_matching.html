<h1 id="Template-Matching-tutorial-py-template-matching"><a href="#Template-Matching-tutorial-py-template-matching" class="headerlink" title="Template Matching {#tutorial_py_template_matching}"></a>Template Matching {#tutorial_py_template_matching}</h1><h2 id="Goals"><a href="#Goals" class="headerlink" title="Goals"></a>Goals</h2><p>In this chapter, you will learn<br>    -   To find objects in an image using Template Matching<br>    -   You will see these functions : <strong>cv.matchTemplate()</strong>, <strong>cv.minMaxLoc()</strong></p>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>Template Matching is a method for searching and finding the location of a template image in a larger<br>image. OpenCV comes with a function <strong>cv.matchTemplate()</strong> for this purpose. It simply slides the<br>template image over the input image (as in 2D convolution) and compares the template and patch of<br>input image under the template image. Several comparison methods are implemented in OpenCV. (You can<br>check docs for more details). It returns a grayscale image, where each pixel denotes how much does<br>the neighbourhood of that pixel match with template.</p>
<p>If input image is of size (WxH) and template image is of size (wxh), output image will have a size<br>of (W-w+1, H-h+1). Once you got the result, you can use <strong>cv.minMaxLoc()</strong> function to find where<br>is the maximum&#x2F;minimum value. Take it as the top-left corner of rectangle and take (w,h) as width<br>and height of the rectangle. That rectangle is your region of template.</p>
<p>@note If you are using cv.TM_SQDIFF as comparison method, minimum value gives the best match.</p>
<h2 id="Template-Matching-in-OpenCV"><a href="#Template-Matching-in-OpenCV" class="headerlink" title="Template Matching in OpenCV"></a>Template Matching in OpenCV</h2><p>Here, as an example, we will search for Messi’s face in his photo. So I created a template as below:</p>
<p><img src="/images/messi_face.jpg" alt="image"></p>
<p>We will try all the comparison methods so that we can see how their results look like:<br>@code{.py}<br>import cv2 as cv<br>import numpy as np<br>from matplotlib import pyplot as plt</p>
<p>img &#x3D; cv.imread(‘messi5.jpg’,0)<br>img2 &#x3D; img.copy()<br>template &#x3D; cv.imread(‘template.jpg’,0)<br>w, h &#x3D; template.shape[::-1]</p>
<h1 id="All-the-6-methods-for-comparison-in-a-list"><a href="#All-the-6-methods-for-comparison-in-a-list" class="headerlink" title="All the 6 methods for comparison in a list"></a>All the 6 methods for comparison in a list</h1><p>methods &#x3D; [‘cv.TM_CCOEFF’, ‘cv.TM_CCOEFF_NORMED’, ‘cv.TM_CCORR’,<br>            ‘cv.TM_CCORR_NORMED’, ‘cv.TM_SQDIFF’, ‘cv.TM_SQDIFF_NORMED’]</p>
<p>for meth in methods:<br>    img &#x3D; img2.copy()<br>    method &#x3D; eval(meth)</p>
<pre><code># Apply template Matching
res = cv.matchTemplate(img,template,method)
min_val, max_val, min_loc, max_loc = cv.minMaxLoc(res)

# If the method is TM_SQDIFF or TM_SQDIFF_NORMED, take minimum
if method in [cv.TM_SQDIFF, cv.TM_SQDIFF_NORMED]:
    top_left = min_loc
else:
    top_left = max_loc
bottom_right = (top_left[0] + w, top_left[1] + h)

cv.rectangle(img,top_left, bottom_right, 255, 2)

plt.subplot(121),plt.imshow(res,cmap = &#39;gray&#39;)
plt.title(&#39;Matching Result&#39;), plt.xticks([]), plt.yticks([])
plt.subplot(122),plt.imshow(img,cmap = &#39;gray&#39;)
plt.title(&#39;Detected Point&#39;), plt.xticks([]), plt.yticks([])
plt.suptitle(meth)

plt.show()
</code></pre>
<p>@endcode<br>See the results below:</p>
<ul>
<li>cv.TM_CCOEFF</li>
</ul>
<p><img src="/images/template_ccoeff_1.jpg" alt="image"></p>
<ul>
<li>cv.TM_CCOEFF_NORMED</li>
</ul>
<p><img src="/images/template_ccoeffn_2.jpg" alt="image"></p>
<ul>
<li>cv.TM_CCORR</li>
</ul>
<p><img src="/images/template_ccorr_3.jpg" alt="image"></p>
<ul>
<li>cv.TM_CCORR_NORMED</li>
</ul>
<p><img src="/images/template_ccorrn_4.jpg" alt="image"></p>
<ul>
<li>cv.TM_SQDIFF</li>
</ul>
<p><img src="/images/template_sqdiff_5.jpg" alt="image"></p>
<ul>
<li>cv.TM_SQDIFF_NORMED</li>
</ul>
<p><img src="/images/template_sqdiffn_6.jpg" alt="image"></p>
<p>You can see that the result using <strong>cv.TM_CCORR</strong> is not good as we expected.</p>
<h2 id="Template-Matching-with-Multiple-Objects"><a href="#Template-Matching-with-Multiple-Objects" class="headerlink" title="Template Matching with Multiple Objects"></a>Template Matching with Multiple Objects</h2><p>In the previous section, we searched image for Messi’s face, which occurs only once in the image.<br>Suppose you are searching for an object which has multiple occurrences, <strong>cv.minMaxLoc()</strong> won’t<br>give you all the locations. In that case, we will use thresholding. So in this example, we will use<br>a screenshot of the famous game <strong>Mario</strong> and we will find the coins in it.<br>@code{.py}<br>import cv2 as cv<br>import numpy as np<br>from matplotlib import pyplot as plt</p>
<p>img_rgb &#x3D; cv.imread(‘mario.png’)<br>img_gray &#x3D; cv.cvtColor(img_rgb, cv.COLOR_BGR2GRAY)<br>template &#x3D; cv.imread(‘mario_coin.png’,0)<br>w, h &#x3D; template.shape[::-1]</p>
<p>res &#x3D; cv.matchTemplate(img_gray,template,cv.TM_CCOEFF_NORMED)<br>threshold &#x3D; 0.8<br>loc &#x3D; np.where( res &gt;&#x3D; threshold)<br>for pt in zip(*loc[::-1]):<br>    cv.rectangle(img_rgb, pt, (pt[0] + w, pt[1] + h), (0,0,255), 2)</p>
<p>cv.imwrite(‘res.png’,img_rgb)<br>@endcode<br>Result:</p>
<p><img src="/images/res_mario.jpg" alt="image"></p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2>