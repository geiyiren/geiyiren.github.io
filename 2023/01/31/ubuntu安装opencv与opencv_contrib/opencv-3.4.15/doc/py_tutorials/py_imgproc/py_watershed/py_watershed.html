<h1 id="Image-Segmentation-with-Watershed-Algorithm-tutorial-py-watershed"><a href="#Image-Segmentation-with-Watershed-Algorithm-tutorial-py-watershed" class="headerlink" title="Image Segmentation with Watershed Algorithm {#tutorial_py_watershed}"></a>Image Segmentation with Watershed Algorithm {#tutorial_py_watershed}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter,<br>    -   We will learn to use marker-based image segmentation using watershed algorithm<br>    -   We will see: <strong>cv.watershed()</strong></p>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>Any grayscale image can be viewed as a topographic surface where high intensity denotes peaks and<br>hills while low intensity denotes valleys. You start filling every isolated valleys (local minima)<br>with different colored water (labels). As the water rises, depending on the peaks (gradients)<br>nearby, water from different valleys, obviously with different colors will start to merge. To avoid<br>that, you build barriers in the locations where water merges. You continue the work of filling water<br>and building barriers until all the peaks are under water. Then the barriers you created gives you<br>the segmentation result. This is the “philosophy” behind the watershed. You can visit the <a href="http://cmm.ensmp.fr/~beucher/wtshed.html">CMM<br>webpage on watershed</a> to understand it with the help of<br>some animations.</p>
<p>But this approach gives you oversegmented result due to noise or any other irregularities in the<br>image. So OpenCV implemented a marker-based watershed algorithm where you specify which are all<br>valley points are to be merged and which are not. It is an interactive image segmentation. What we<br>do is to give different labels for our object we know. Label the region which we are sure of being<br>the foreground or object with one color (or intensity), label the region which we are sure of being<br>background or non-object with another color and finally the region which we are not sure of<br>anything, label it with 0. That is our marker. Then apply watershed algorithm. Then our marker will<br>be updated with the labels we gave, and the boundaries of objects will have a value of -1.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>Below we will see an example on how to use the Distance Transform along with watershed to segment<br>mutually touching objects.</p>
<p>Consider the coins image below, the coins are touching each other. Even if you threshold it, it will<br>be touching each other.</p>
<p><img src="/images/water_coins.jpg" alt="image"></p>
<p>We start with finding an approximate estimate of the coins. For that, we can use the Otsu’s<br>binarization.<br>@code{.py}<br>import numpy as np<br>import cv2 as cv<br>from matplotlib import pyplot as plt</p>
<p>img &#x3D; cv.imread(‘coins.png’)<br>gray &#x3D; cv.cvtColor(img,cv.COLOR_BGR2GRAY)<br>ret, thresh &#x3D; cv.threshold(gray,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU)<br>@endcode<br>Result:</p>
<p><img src="/images/water_thresh.jpg" alt="image"></p>
<p>Now we need to remove any small white noises in the image. For that we can use morphological<br>opening. To remove any small holes in the object, we can use morphological closing. So, now we know<br>for sure that region near to center of objects are foreground and region much away from the object<br>are background. Only region we are not sure is the boundary region of coins.</p>
<p>So we need to extract the area which we are sure they are coins. Erosion removes the boundary<br>pixels. So whatever remaining, we can be sure it is coin. That would work if objects were not<br>touching each other. But since they are touching each other, another good option would be to find<br>the distance transform and apply a proper threshold. Next we need to find the area which we are sure<br>they are not coins. For that, we dilate the result. Dilation increases object boundary to<br>background. This way, we can make sure whatever region in background in result is really a<br>background, since boundary region is removed. See the image below.</p>
<p><img src="/images/water_fgbg.jpg" alt="image"></p>
<p>The remaining regions are those which we don’t have any idea, whether it is coins or background.<br>Watershed algorithm should find it. These areas are normally around the boundaries of coins where<br>foreground and background meet (Or even two different coins meet). We call it border. It can be<br>obtained from subtracting sure_fg area from sure_bg area.<br>@code{.py}</p>
<h1 id="noise-removal"><a href="#noise-removal" class="headerlink" title="noise removal"></a>noise removal</h1><p>kernel &#x3D; np.ones((3,3),np.uint8)<br>opening &#x3D; cv.morphologyEx(thresh,cv.MORPH_OPEN,kernel, iterations &#x3D; 2)</p>
<h1 id="sure-background-area"><a href="#sure-background-area" class="headerlink" title="sure background area"></a>sure background area</h1><p>sure_bg &#x3D; cv.dilate(opening,kernel,iterations&#x3D;3)</p>
<h1 id="Finding-sure-foreground-area"><a href="#Finding-sure-foreground-area" class="headerlink" title="Finding sure foreground area"></a>Finding sure foreground area</h1><p>dist_transform &#x3D; cv.distanceTransform(opening,cv.DIST_L2,5)<br>ret, sure_fg &#x3D; cv.threshold(dist_transform,0.7*dist_transform.max(),255,0)</p>
<h1 id="Finding-unknown-region"><a href="#Finding-unknown-region" class="headerlink" title="Finding unknown region"></a>Finding unknown region</h1><p>sure_fg &#x3D; np.uint8(sure_fg)<br>unknown &#x3D; cv.subtract(sure_bg,sure_fg)<br>@endcode<br>See the result. In the thresholded image, we get some regions of coins which we are sure of coins<br>and they are detached now. (In some cases, you may be interested in only foreground segmentation,<br>not in separating the mutually touching objects. In that case, you need not use distance transform,<br>just erosion is sufficient. Erosion is just another method to extract sure foreground area, that’s<br>all.)</p>
<p><img src="/images/water_dt.jpg" alt="image"></p>
<p>Now we know for sure which are region of coins, which are background and all. So we create marker<br>(it is an array of same size as that of original image, but with int32 datatype) and label the<br>regions inside it. The regions we know for sure (whether foreground or background) are labelled with<br>any positive integers, but different integers, and the area we don’t know for sure are just left as<br>zero. For this we use <strong>cv.connectedComponents()</strong>. It labels background of the image with 0, then<br>other objects are labelled with integers starting from 1.</p>
<p>But we know that if background is marked with 0, watershed will consider it as unknown area. So we<br>want to mark it with different integer. Instead, we will mark unknown region, defined by unknown,<br>with 0.<br>@code{.py}</p>
<h1 id="Marker-labelling"><a href="#Marker-labelling" class="headerlink" title="Marker labelling"></a>Marker labelling</h1><p>ret, markers &#x3D; cv.connectedComponents(sure_fg)</p>
<h1 id="Add-one-to-all-labels-so-that-sure-background-is-not-0-but-1"><a href="#Add-one-to-all-labels-so-that-sure-background-is-not-0-but-1" class="headerlink" title="Add one to all labels so that sure background is not 0, but 1"></a>Add one to all labels so that sure background is not 0, but 1</h1><p>markers &#x3D; markers+1</p>
<h1 id="Now-mark-the-region-of-unknown-with-zero"><a href="#Now-mark-the-region-of-unknown-with-zero" class="headerlink" title="Now, mark the region of unknown with zero"></a>Now, mark the region of unknown with zero</h1><p>markers[unknown&#x3D;&#x3D;255] &#x3D; 0<br>@endcode<br>See the result shown in JET colormap. The dark blue region shows unknown region. Sure coins are<br>colored with different values. Remaining area which are sure background are shown in lighter blue<br>compared to unknown region.</p>
<p><img src="/images/water_marker.jpg" alt="image"></p>
<p>Now our marker is ready. It is time for final step, apply watershed. Then marker image will be<br>modified. The boundary region will be marked with -1.<br>@code{.py}<br>markers &#x3D; cv.watershed(img,markers)<br>img[markers &#x3D;&#x3D; -1] &#x3D; [255,0,0]<br>@endcode<br>See the result below. For some coins, the region where they touch are segmented properly and for<br>some, they are not.</p>
<p><img src="/images/water_result.jpg" alt="image"></p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><p>-#  CMM page on <a href="http://cmm.ensmp.fr/~beucher/wtshed.html">Watershed Transformation</a></p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><p>-#  OpenCV samples has an interactive sample on watershed segmentation, watershed.py. Run it, Enjoy<br>    it, then learn it.</p>
