<h1 id="Understanding-k-Nearest-Neighbour-tutorial-py-knn-understanding"><a href="#Understanding-k-Nearest-Neighbour-tutorial-py-knn-understanding" class="headerlink" title="Understanding k-Nearest Neighbour {#tutorial_py_knn_understanding}"></a>Understanding k-Nearest Neighbour {#tutorial_py_knn_understanding}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter, we will understand the concepts of the k-Nearest Neighbour (kNN) algorithm.</p>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>kNN is one of the simplest classification algorithms available for supervised learning. The idea<br>is to search for the closest match(es) of the test data in the feature space. We will look into it with the below<br>image.</p>
<p><img src="/images/knn_theory.png" alt="image"></p>
<p>In the image, there are two families: Blue Squares and Red Triangles. We refer to each family as<br>a <strong>Class</strong>. Their houses are shown in their town map which we call the <strong>Feature Space</strong>. You can consider<br>a feature space as a space where all data are projected. For example, consider a 2D coordinate<br>space. Each datum has two features, a x coordinate and a y coordinate. You can represent this datum in your 2D<br>coordinate space, right? Now imagine that there are three features, you will need 3D space. Now consider N<br>features: you need N-dimensional space, right? This N-dimensional space is its feature space.<br>In our image, you can consider it as a 2D case with two features.</p>
<p>Now consider what happens if a new member comes into the town and creates a new home, which is shown as the green circle. He<br>should be added to one of these Blue or Red families (or <em>classes</em>). We call that process, <strong>Classification</strong>. How exactly should this new member be classified? Since we are dealing with kNN, let us apply the algorithm.</p>
<p>One simple method is to check who is his nearest neighbour. From the image, it is clear that it is a member of the Red<br>Triangle family. So he is classified as a Red Triangle. This method is called simply <strong>Nearest Neighbour</strong> classification, because classification depends only on the <em>nearest neighbour</em>.</p>
<p>But there is a problem with this approach! Red Triangle may be the nearest neighbour, but what if there are also a lot of Blue<br>Squares nearby? Then Blue Squares have more strength in that locality than Red Triangles, so<br>just checking the nearest one is not sufficient. Instead we may want to check some <strong>k</strong> nearest families. Then whichever family is the majority amongst them, the new guy should belong to that family. In our image, let’s take k&#x3D;3, i.e. consider the 3 nearest<br>neighbours. The new member has two Red neighbours and one Blue neighbour (there are two Blues equidistant, but since k&#x3D;3, we can take only<br>one of them), so again he should be added to Red family. But what if we take k&#x3D;7? Then he has 5 Blue<br>neighbours and 2 Red neighbours and should be added to the Blue family. The result will vary with the selected<br>value of k. Note that if k is not an odd number, we can get a tie, as would happen in the above case with k&#x3D;4. We would see that our new member has 2 Red and 2 Blue neighbours as his four nearest neighbours and we would need to choose a method for breaking the tie to perform classification. So to reiterate, this method is called <strong>k-Nearest Neighbour</strong> since<br>classification depends on the <em>k nearest neighbours</em>.</p>
<p>Again, in kNN, it is true we are considering k neighbours, but we are giving equal importance to<br>all, right? Is this justified? For example, take the tied case of k&#x3D;4. As we can see, the 2<br>Red neighbours are actually closer to the new member than the other 2 Blue neighbours, so he is more eligible to be<br>added to the Red family. How do we mathematically explain that? We give some weights to each neighbour<br>depending on their distance to the new-comer: those who are nearer to him get higher weights, while<br>those that are farther away get lower weights. Then we add the total weights of each family separately and classify the new-comer as part of whichever family<br>received higher total weights. This is called <strong>modified kNN</strong> or <strong>weighted kNN</strong>.</p>
<p>So what are some important things you see here?</p>
<ul>
<li>Because we have to check<br>the distance from the new-comer to all the existing houses to find the nearest neighbour(s), you need to have information about all of the houses in town, right?  If there are plenty of houses and families, it takes a lot of memory, and also more time for calculation.</li>
<li>There is almost zero time for any kind of “training” or preparation. Our “learning” involves only memorizing (storing) the data, before testing and classifying.</li>
</ul>
<p>Now let’s see this algorithm at work in OpenCV.</p>
<h2 id="kNN-in-OpenCV"><a href="#kNN-in-OpenCV" class="headerlink" title="kNN in OpenCV"></a>kNN in OpenCV</h2><p>We will do a simple example here, with two families (classes), just like above. Then in the next<br>chapter, we will do an even better example.</p>
<p>So here, we label the Red family as <strong>Class-0</strong> (so denoted by 0) and Blue family as <strong>Class-1</strong><br>(denoted by 1). We create 25 neighbours or 25 training data, and label each of them as either part of Class-0 or Class-1.<br>We can do this with the help of a Random Number Generator from NumPy.</p>
<p>Then we can plot it with the help of Matplotlib. Red neighbours are shown as Red Triangles and Blue<br>neighbours are shown as Blue Squares.<br>@code{.py}<br>import cv2 as cv<br>import numpy as np<br>import matplotlib.pyplot as plt</p>
<h1 id="Feature-set-containing-x-y-values-of-25-known-x2F-training-data"><a href="#Feature-set-containing-x-y-values-of-25-known-x2F-training-data" class="headerlink" title="Feature set containing (x,y) values of 25 known&#x2F;training data"></a>Feature set containing (x,y) values of 25 known&#x2F;training data</h1><p>trainData &#x3D; np.random.randint(0,100,(25,2)).astype(np.float32)</p>
<h1 id="Label-each-one-either-Red-or-Blue-with-numbers-0-and-1"><a href="#Label-each-one-either-Red-or-Blue-with-numbers-0-and-1" class="headerlink" title="Label each one either Red or Blue with numbers 0 and 1"></a>Label each one either Red or Blue with numbers 0 and 1</h1><p>responses &#x3D; np.random.randint(0,2,(25,1)).astype(np.float32)</p>
<h1 id="Take-Red-neighbours-and-plot-them"><a href="#Take-Red-neighbours-and-plot-them" class="headerlink" title="Take Red neighbours and plot them"></a>Take Red neighbours and plot them</h1><p>red &#x3D; trainData[responses.ravel()&#x3D;&#x3D;0]<br>plt.scatter(red[:,0],red[:,1],80,’r’,’^’)</p>
<h1 id="Take-Blue-neighbours-and-plot-them"><a href="#Take-Blue-neighbours-and-plot-them" class="headerlink" title="Take Blue neighbours and plot them"></a>Take Blue neighbours and plot them</h1><p>blue &#x3D; trainData[responses.ravel()&#x3D;&#x3D;1]<br>plt.scatter(blue[:,0],blue[:,1],80,’b’,’s’)</p>
<p>plt.show()<br>@endcode<br>You will get something similar to our first image. Since you are using a random number generator, you<br>will get different data each time you run the code.</p>
<p>Next initiate the kNN algorithm and pass the trainData and responses to train the kNN. (Underneath the hood, it constructs<br>a search tree: see the Additional Resources section below for more information on this.)</p>
<p>Then we will bring one new-comer and classify him as belonging to a family with the help of kNN in OpenCV. Before<br>running kNN, we need to know something about our test data (data of new comers). Our data should be a<br>floating point array with size \f$number ; of ; testdata \times number ; of ; features\f$. Then we<br>find the nearest neighbours of the new-comer. We can specify <em>k</em>: how many neighbours we want. (Here we used 3.) It returns:</p>
<ol>
<li>The label given to the new-comer depending upon the kNN theory we saw earlier. If you want the <em>Nearest<br>Neighbour</em> algorithm, just specify k&#x3D;1.</li>
<li>The labels of the k-Nearest Neighbours.</li>
<li>The corresponding distances from the new-comer to each nearest neighbour.</li>
</ol>
<p>So let’s see how it works. The new-comer is marked in green.<br>@code{.py}<br>newcomer &#x3D; np.random.randint(0,100,(1,2)).astype(np.float32)<br>plt.scatter(newcomer[:,0],newcomer[:,1],80,’g’,’o’)</p>
<p>knn &#x3D; cv.ml.KNearest_create()<br>knn.train(trainData, cv.ml.ROW_SAMPLE, responses)<br>ret, results, neighbours ,dist &#x3D; knn.findNearest(newcomer, 3)</p>
<p>print( “result:  {}\n”.format(results) )<br>print( “neighbours:  {}\n”.format(neighbours) )<br>print( “distance:  {}\n”.format(dist) )</p>
<p>plt.show()<br>@endcode<br>I got the following results:<br>@code{.py}<br>result:  [[ 1.]]<br>neighbours:  [[ 1.  1.  1.]]<br>distance:  [[ 53.  58.  61.]]<br>@endcode<br>It says that our new-comer’s 3 nearest neighbours are all from the Blue family. Therefore, he is labelled as part of the Blue<br>family. It is obvious from the plot below:</p>
<p><img src="/images/knn_simple.png" alt="image"></p>
<h2 id="If-you-have-multiple-new-comers-test-data-you-can-just-pass-them-as-an-array-Corresponding-results-are-alsoobtained-as-arrays-code-py-10-new-comersnewcomers-x3D-np-random-randint-0-100-10-2-astype-np-float32-ret-results-neighbours-dist-x3D-knn-findNearest-newcomer-3-The-results-also-will-contain-10-labels-endcodeAdditional-Resources"><a href="#If-you-have-multiple-new-comers-test-data-you-can-just-pass-them-as-an-array-Corresponding-results-are-alsoobtained-as-arrays-code-py-10-new-comersnewcomers-x3D-np-random-randint-0-100-10-2-astype-np-float32-ret-results-neighbours-dist-x3D-knn-findNearest-newcomer-3-The-results-also-will-contain-10-labels-endcodeAdditional-Resources" class="headerlink" title="If you have multiple new-comers (test data), you can just pass them as an array. Corresponding results are alsoobtained as arrays.@code{.py}# 10 new-comersnewcomers &#x3D; np.random.randint(0,100,(10,2)).astype(np.float32)ret, results,neighbours,dist &#x3D; knn.findNearest(newcomer, 3)# The results also will contain 10 labels.@endcodeAdditional Resources"></a>If you have multiple new-comers (test data), you can just pass them as an array. Corresponding results are also<br>obtained as arrays.<br>@code{.py}<br># 10 new-comers<br>newcomers &#x3D; np.random.randint(0,100,(10,2)).astype(np.float32)<br>ret, results,neighbours,dist &#x3D; knn.findNearest(newcomer, 3)<br># The results also will contain 10 labels.<br>@endcode<br>Additional Resources</h2><ol>
<li><a href="https://nptel.ac.in/courses/106/108/106108057/">NPTEL notes on Pattern Recognition, Chapter<br>11</a></li>
<li><a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search">Wikipedia article on Nearest neighbor search</a></li>
<li><a href="https://en.wikipedia.org/wiki/K-d_tree">Wikipedia article on k-d tree</a></li>
</ol>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li>Try repeating the above with more classes and different choices of k. Does choosing k become harder with more classes in the same 2D feature space?</li>
</ol>
