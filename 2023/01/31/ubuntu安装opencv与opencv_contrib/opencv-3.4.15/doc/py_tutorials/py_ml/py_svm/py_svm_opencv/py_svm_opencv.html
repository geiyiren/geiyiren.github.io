<h1 id="OCR-of-Hand-written-Data-using-SVM-tutorial-py-svm-opencv"><a href="#OCR-of-Hand-written-Data-using-SVM-tutorial-py-svm-opencv" class="headerlink" title="OCR of Hand-written Data using SVM {#tutorial_py_svm_opencv}"></a>OCR of Hand-written Data using SVM {#tutorial_py_svm_opencv}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter</p>
<ul>
<li>We will revisit the hand-written data OCR, but, with SVM instead of kNN.</li>
</ul>
<h2 id="OCR-of-Hand-written-Digits"><a href="#OCR-of-Hand-written-Digits" class="headerlink" title="OCR of Hand-written Digits"></a>OCR of Hand-written Digits</h2><p>In kNN, we directly used pixel intensity as the feature vector. This time we will use <a href="http://en.wikipedia.org/wiki/Histogram_of_oriented_gradients">Histogram of<br>Oriented Gradients</a> (HOG) as feature<br>vectors.</p>
<p>Here, before finding the HOG, we deskew the image using its second order moments. So we first define<br>a function <strong>deskew()</strong> which takes a digit image and deskew it. Below is the deskew() function:</p>
<p>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;ml&#x2F;py_svm_opencv&#x2F;hogsvm.py deskew</p>
<p>Below image shows above deskew function applied to an image of zero. Left image is the original<br>image and right image is the deskewed image.</p>
<p><img src="/images/deskew.jpg" alt="image"></p>
<p>Next we have to find the HOG Descriptor of each cell. For that, we find Sobel derivatives of each<br>cell in X and Y direction. Then find their magnitude and direction of gradient at each pixel. This<br>gradient is quantized to 16 integer values. Divide this image to four sub-squares. For each<br>sub-square, calculate the histogram of direction (16 bins) weighted with their magnitude. So each<br>sub-square gives you a vector containing 16 values. Four such vectors (of four sub-squares) together<br>gives us a feature vector containing 64 values. This is the feature vector we use to train our data.</p>
<p>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;ml&#x2F;py_svm_opencv&#x2F;hogsvm.py hog</p>
<p>Finally, as in the previous case, we start by splitting our big dataset into individual cells. For<br>every digit, 250 cells are reserved for training data and remaining 250 data is reserved for<br>testing. Full code is given below, you also can download it from <a href="https://github.com/opencv/opencv/tree/3.4/samples/python/tutorial_code/ml/py_svm_opencv/hogsvm.py">here</a>:</p>
<p>@include samples&#x2F;python&#x2F;tutorial_code&#x2F;ml&#x2F;py_svm_opencv&#x2F;hogsvm.py</p>
<p>This particular technique gave me nearly 94% accuracy. You can try different values for various<br>parameters of SVM to check if higher accuracy is possible. Or you can read technical papers on this<br>area and try to implement them.</p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><p>-#  <a href="https://www.youtube.com/watch?v=0Zib1YEE4LU">Histograms of Oriented Gradients Video</a></p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><p>-#  OpenCV samples contain digits.py which applies a slight improvement of the above method to get<br>    improved result. It also contains the reference. Check it and understand it.</p>
