<h1 id="Image-Inpainting-tutorial-py-inpainting"><a href="#Image-Inpainting-tutorial-py-inpainting" class="headerlink" title="Image Inpainting {#tutorial_py_inpainting}"></a>Image Inpainting {#tutorial_py_inpainting}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter,<br>    -   We will learn how to remove small noises, strokes etc in old photographs by a method called<br>        inpainting<br>    -   We will see inpainting functionalities in OpenCV.</p>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>Most of you will have some old degraded photos at your home with some black spots, some strokes etc<br>on it. Have you ever thought of restoring it back? We can’t simply erase them in a paint tool<br>because it is will simply replace black structures with white structures which is of no use. In<br>these cases, a technique called image inpainting is used. The basic idea is simple: Replace those<br>bad marks with its neighbouring pixels so that it looks like the neighbourhood. Consider the image<br>shown below (taken from <a href="http://en.wikipedia.org/wiki/Inpainting">Wikipedia</a>):</p>
<p><img src="/images/inpaint_basics.jpg" alt="image"></p>
<p>Several algorithms were designed for this purpose and OpenCV provides two of them. Both can be<br>accessed by the same function, <strong>cv.inpaint()</strong></p>
<p>First algorithm is based on the paper <strong>“An Image Inpainting Technique Based on the Fast Marching<br>Method”</strong> by Alexandru Telea in 2004. It is based on Fast Marching Method. Consider a region in the<br>image to be inpainted. Algorithm starts from the boundary of this region and goes inside the region<br>gradually filling everything in the boundary first. It takes a small neighbourhood around the pixel<br>on the neighbourhood to be inpainted. This pixel is replaced by normalized weighted sum of all the<br>known pixels in the neighbourhood. Selection of the weights is an important matter. More weightage is<br>given to those pixels lying near to the point, near to the normal of the boundary and those lying on<br>the boundary contours. Once a pixel is inpainted, it moves to next nearest pixel using Fast Marching<br>Method. FMM ensures those pixels near the known pixels are inpainted first, so that it just works<br>like a manual heuristic operation. This algorithm is enabled by using the flag, cv.INPAINT_TELEA.</p>
<p>Second algorithm is based on the paper <strong>“Navier-Stokes, Fluid Dynamics, and Image and Video<br>Inpainting”</strong> by Bertalmio, Marcelo, Andrea L. Bertozzi, and Guillermo Sapiro in 2001. This<br>algorithm is based on fluid dynamics and utilizes partial differential equations. Basic principle is<br>heurisitic. It first travels along the edges from known regions to unknown regions (because edges<br>are meant to be continuous). It continues isophotes (lines joining points with same intensity, just<br>like contours joins points with same elevation) while matching gradient vectors at the boundary of<br>the inpainting region. For this, some methods from fluid dynamics are used. Once they are obtained,<br>color is filled to reduce minimum variance in that area. This algorithm is enabled by using the<br>flag, cv.INPAINT_NS.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>We need to create a mask of same size as that of input image, where non-zero pixels corresponds to<br>the area which is to be inpainted. Everything else is simple. My image is degraded with some black<br>strokes (I added manually). I created a corresponding strokes with Paint tool.<br>@code{.py}<br>import numpy as np<br>import cv2 as cv</p>
<p>img &#x3D; cv.imread(‘messi_2.jpg’)<br>mask &#x3D; cv.imread(‘mask2.png’,0)</p>
<p>dst &#x3D; cv.inpaint(img,mask,3,cv.INPAINT_TELEA)</p>
<p>cv.imshow(‘dst’,dst)<br>cv.waitKey(0)<br>cv.destroyAllWindows()<br>@endcode<br>See the result below. First image shows degraded input. Second image is the mask. Third image is the<br>result of first algorithm and last image is the result of second algorithm.</p>
<p><img src="/images/inpaint_result.jpg" alt="image"></p>
<h2 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h2><p>-#  Bertalmio, Marcelo, Andrea L. Bertozzi, and Guillermo Sapiro. “Navier-stokes, fluid dynamics,<br>    and image and video inpainting.” In Computer Vision and Pattern Recognition, 2001. CVPR 2001.<br>    Proceedings of the 2001 IEEE Computer Society Conference on, vol. 1, pp. I-355. IEEE, 2001.<br>2.  Telea, Alexandru. “An image inpainting technique based on the fast marching method.” Journal of<br>    graphics tools 9.1 (2004): 23-34.</p>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><p>-#  OpenCV comes with an interactive sample on inpainting, samples&#x2F;python&#x2F;inpaint.py, try it.<br>2.  A few months ago, I watched a video on <a href="http://www.youtube.com/watch?v=ZtoUiplKa2A">Content-Aware<br>    Fill</a>, an advanced inpainting technique used in<br>    Adobe Photoshop. On further search, I was able to find that same technique is already there in<br>    GIMP with different name, “Resynthesizer” (You need to install separate plugin). I am sure you<br>    will enjoy the technique.</p>
