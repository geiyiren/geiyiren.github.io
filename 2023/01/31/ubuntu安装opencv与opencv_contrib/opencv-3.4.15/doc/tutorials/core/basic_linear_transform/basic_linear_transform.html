<h1 id="Changing-the-contrast-and-brightness-of-an-image-tutorial-basic-linear-transform"><a href="#Changing-the-contrast-and-brightness-of-an-image-tutorial-basic-linear-transform" class="headerlink" title="Changing the contrast and brightness of an image! {#tutorial_basic_linear_transform}"></a>Changing the contrast and brightness of an image! {#tutorial_basic_linear_transform}</h1><p>@prev_tutorial{tutorial_adding_images}<br>@next_tutorial{tutorial_discrete_fourier_transform}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this tutorial you will learn how to:</p>
<ul>
<li>Access pixel values</li>
<li>Initialize a matrix with zeros</li>
<li>Learn what @ref cv::saturate_cast does and why it is useful</li>
<li>Get some cool info about pixel transformations</li>
<li>Improve the brightness of an image on a practical example</li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>@note<br>   The explanation below belongs to the book <a href="http://szeliski.org/Book/">Computer Vision: Algorithms and<br>    Applications</a> by Richard Szeliski</p>
<h3 id="Image-Processing"><a href="#Image-Processing" class="headerlink" title="Image Processing"></a>Image Processing</h3><ul>
<li>A general image processing operator is a function that takes one or more input images and<br>produces an output image.</li>
<li>Image transforms can be seen as:<ul>
<li>Point operators (pixel transforms)</li>
<li>Neighborhood (area-based) operators</li>
</ul>
</li>
</ul>
<h3 id="Pixel-Transforms"><a href="#Pixel-Transforms" class="headerlink" title="Pixel Transforms"></a>Pixel Transforms</h3><ul>
<li>In this kind of image processing transform, each output pixelâ€™s value depends on only the<br>corresponding input pixel value (plus, potentially, some globally collected information or<br>parameters).</li>
<li>Examples of such operators include <em>brightness and contrast adjustments</em> as well as color<br>correction and transformations.</li>
</ul>
<h3 id="Brightness-and-contrast-adjustments"><a href="#Brightness-and-contrast-adjustments" class="headerlink" title="Brightness and contrast adjustments"></a>Brightness and contrast adjustments</h3><ul>
<li><p>Two commonly used point processes are <em>multiplication</em> and <em>addition</em> with a constant:</p>
<p>\f[g(x) &#x3D; \alpha f(x) + \beta\f]</p>
</li>
<li><p>The parameters \f$\alpha &gt; 0\f$ and \f$\beta\f$ are often called the <em>gain</em> and <em>bias</em> parameters;<br>sometimes these parameters are said to control <em>contrast</em> and <em>brightness</em> respectively.</p>
</li>
<li><p>You can think of \f$f(x)\f$ as the source image pixels and \f$g(x)\f$ as the output image pixels. Then,<br>more conveniently we can write the expression as:</p>
<p>\f[g(i,j) &#x3D; \alpha \cdot f(i,j) + \beta\f]</p>
<p>where \f$i\f$ and \f$j\f$ indicates that the pixel is located in the <em>i-th</em> row and <em>j-th</em> column.</p>
</li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>@add_toggle_cpp</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/ImgProc/BasicLinearTransforms.cpp">here</a></p>
</li>
<li><p>The following code performs the operation \f$g(i,j) &#x3D; \alpha \cdot f(i,j) + \beta\f$ :<br>@include samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;BasicLinearTransforms.cpp<br>@end_toggle</p>
</li>
</ul>
<p>@add_toggle_java</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/java/tutorial_code/ImgProc/changing_contrast_brightness_image/BasicLinearTransformsDemo.java">here</a></p>
</li>
<li><p>The following code performs the operation \f$g(i,j) &#x3D; \alpha \cdot f(i,j) + \beta\f$ :<br>@include samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransformsDemo.java<br>@end_toggle</p>
</li>
</ul>
<p>@add_toggle_python</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/python/tutorial_code/imgProc/changing_contrast_brightness_image/BasicLinearTransforms.py">here</a></p>
</li>
<li><p>The following code performs the operation \f$g(i,j) &#x3D; \alpha \cdot f(i,j) + \beta\f$ :<br>@include samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransforms.py<br>@end_toggle</p>
</li>
</ul>
<h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><ul>
<li>We load an image using @ref cv::imread and save it in a Mat object:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;BasicLinearTransforms.cpp basic-linear-transform-load<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransformsDemo.java basic-linear-transform-load<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransforms.py basic-linear-transform-load<br>@end_toggle</p>
<ul>
<li><p>Now, since we will make some transformations to this image, we need a new Mat object to store<br>it. Also, we want this to have the following features:</p>
<ul>
<li>Initial pixel values equal to zero</li>
<li>Same size and type as the original image</li>
</ul>
</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;BasicLinearTransforms.cpp basic-linear-transform-output<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransformsDemo.java basic-linear-transform-output<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransforms.py basic-linear-transform-output<br>@end_toggle</p>
<p>We observe that @ref cv::Mat::zeros returns a Matlab-style zero initializer based on<br><em>image.size()</em> and <em>image.type()</em></p>
<ul>
<li>We ask now the values of \f$\alpha\f$ and \f$\beta\f$ to be entered by the user:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;BasicLinearTransforms.cpp basic-linear-transform-parameters<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransformsDemo.java basic-linear-transform-parameters<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransforms.py basic-linear-transform-parameters<br>@end_toggle</p>
<ul>
<li>Now, to perform the operation \f$g(i,j) &#x3D; \alpha \cdot f(i,j) + \beta\f$ we will access to each<br>pixel in image. Since we are operating with BGR images, we will have three values per pixel (B,<br>G and R), so we will also access them separately. Here is the piece of code:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;BasicLinearTransforms.cpp basic-linear-transform-operation<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransformsDemo.java basic-linear-transform-operation<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransforms.py basic-linear-transform-operation<br>@end_toggle</p>
<p>Notice the following (<strong>C++ code only</strong>):</p>
<ul>
<li><p>To access each pixel in the images we are using this syntax: <em>image.at&lt;Vec3b&gt;(y,x)[c]</em><br>where <em>y</em> is the row, <em>x</em> is the column and <em>c</em> is B, G or R (0, 1 or 2).</p>
</li>
<li><p>Since the operation \f$\alpha \cdot p(i,j) + \beta\f$ can give values out of range or not<br>integers (if \f$\alpha\f$ is float), we use cv::saturate_cast to make sure the<br>values are valid.</p>
</li>
<li><p>Finally, we create windows and show the images, the usual way.</p>
</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;BasicLinearTransforms.cpp basic-linear-transform-display<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransformsDemo.java basic-linear-transform-display<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;changing_contrast_brightness_image&#x2F;BasicLinearTransforms.py basic-linear-transform-display<br>@end_toggle</p>
<p>@note<br>    Instead of using the <strong>for</strong> loops to access each pixel, we could have simply used this command:</p>
<p>@add_toggle_cpp<br>@code{.cpp}<br>image.convertTo(new_image, -1, alpha, beta);<br>@endcode<br>@end_toggle</p>
<p>@add_toggle_java<br>@code{.java}<br>image.convertTo(newImage, -1, alpha, beta);<br>@endcode<br>@end_toggle</p>
<p>@add_toggle_python<br>@code{.py}<br>new_image &#x3D; cv.convertScaleAbs(image, alpha&#x3D;alpha, beta&#x3D;beta)<br>@endcode<br>@end_toggle</p>
<p>where @ref cv::Mat::convertTo would effectively perform <em>new_image &#x3D; a</em>image + beta*. However, we<br>wanted to show you how to access each pixel. In any case, both methods give the same result but<br>convertTo is more optimized and works a lot faster.</p>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><ul>
<li><h2 id="Running-our-code-and-using-f-alpha-x3D-2-2-f-and-f-beta-x3D-50-f-code-bash-x2F-BasicLinearTransforms-lena-jpgBasic-Linear-Transforms"><a href="#Running-our-code-and-using-f-alpha-x3D-2-2-f-and-f-beta-x3D-50-f-code-bash-x2F-BasicLinearTransforms-lena-jpgBasic-Linear-Transforms" class="headerlink" title="Running our code and using \f$\alpha &#x3D; 2.2\f$ and \f$\beta &#x3D; 50\f$@code{.bash}$ .&#x2F;BasicLinearTransforms lena.jpgBasic Linear Transforms"></a>Running our code and using \f$\alpha &#x3D; 2.2\f$ and \f$\beta &#x3D; 50\f$<br>@code{.bash}<br>$ .&#x2F;BasicLinearTransforms lena.jpg<br>Basic Linear Transforms</h2><ul>
<li>Enter the alpha value [1.0-3.0]: 2.2</li>
<li>Enter the beta value [0-100]: 50<br>@endcode</li>
</ul>
</li>
<li><p>We get this:</p>
<p><img src="/images/Basic_Linear_Transform_Tutorial_Result_big.jpg"></p>
</li>
</ul>
<h2 id="Practical-example"><a href="#Practical-example" class="headerlink" title="Practical example"></a>Practical example</h2><p>In this paragraph, we will put into practice what we have learned to correct an underexposed image by adjusting the brightness<br>and the contrast of the image. We will also see another technique to correct the brightness of an image called<br>gamma correction.</p>
<h3 id="Brightness-and-contrast-adjustments-1"><a href="#Brightness-and-contrast-adjustments-1" class="headerlink" title="Brightness and contrast adjustments"></a>Brightness and contrast adjustments</h3><p>Increasing (&#x2F; decreasing) the \f$\beta\f$ value will add (&#x2F; subtract) a constant value to every pixel. Pixel values outside of the [0 ; 255]<br>range will be saturated (i.e. a pixel value higher (&#x2F; lesser) than 255 (&#x2F; 0) will be clamped to 255 (&#x2F; 0)).</p>
<p><img src="/images/Basic_Linear_Transform_Tutorial_hist_beta.png" alt="In light gray, histogram of the original image, in dark gray when brightness = 80 in Gimp"></p>
<p>The histogram represents for each color level the number of pixels with that color level. A dark image will have many pixels with<br>low color value and thus the histogram will present a peak in its left part. When adding a constant bias, the histogram is shifted to the<br>right as we have added a constant bias to all the pixels.</p>
<p>The \f$\alpha\f$ parameter will modify how the levels spread. If \f$ \alpha &lt; 1 \f$, the color levels will be compressed and the result<br>will be an image with less contrast.</p>
<p><img src="/images/Basic_Linear_Transform_Tutorial_hist_alpha.png" alt="In light gray, histogram of the original image, in dark gray when contrast &lt; 0 in Gimp"></p>
<p>Note that these histograms have been obtained using the Brightness-Contrast tool in the Gimp software. The brightness tool should be<br>identical to the \f$\beta\f$ bias parameters but the contrast tool seems to differ to the \f$\alpha\f$ gain where the output range<br>seems to be centered with Gimp (as you can notice in the previous histogram).</p>
<p>It can occur that playing with the \f$\beta\f$ bias will improve the brightness but in the same time the image will appear with a<br>slight veil as the contrast will be reduced. The \f$\alpha\f$ gain can be used to diminue this effect but due to the saturation,<br>we will lose some details in the original bright regions.</p>
<h3 id="Gamma-correction"><a href="#Gamma-correction" class="headerlink" title="Gamma correction"></a>Gamma correction</h3><p><a href="https://en.wikipedia.org/wiki/Gamma_correction">Gamma correction</a> can be used to correct the brightness of an image by using a non<br>linear transformation between the input values and the mapped output values:</p>
<p>\f[O &#x3D; \left( \frac{I}{255} \right)^{\gamma} \times 255\f]</p>
<p>As this relation is non linear, the effect will not be the same for all the pixels and will depend to their original value.</p>
<p><img src="/images/Basic_Linear_Transform_Tutorial_gamma.png" alt="Plot for different values of gamma"></p>
<p>When \f$ \gamma &lt; 1 \f$, the original dark regions will be brighter and the histogram will be shifted to the right whereas it will<br>be the opposite with \f$ \gamma &gt; 1 \f$.</p>
<h3 id="Correct-an-underexposed-image"><a href="#Correct-an-underexposed-image" class="headerlink" title="Correct an underexposed image"></a>Correct an underexposed image</h3><p>The following image has been corrected with: \f$ \alpha &#x3D; 1.3 \f$ and \f$ \beta &#x3D; 40 \f$.</p>
<p><img src="/images/Basic_Linear_Transform_Tutorial_linear_transform_correction.jpg" alt="By Visem (Own work) [CC BY-SA 3.0], via Wikimedia Commons"></p>
<p>The overall brightness has been improved but you can notice that the clouds are now greatly saturated due to the numerical saturation<br>of the implementation used (<a href="https://en.wikipedia.org/wiki/Clipping_(photography)">highlight clipping</a> in photography).</p>
<p>The following image has been corrected with: \f$ \gamma &#x3D; 0.4 \f$.</p>
<p><img src="/images/Basic_Linear_Transform_Tutorial_gamma_correction.jpg" alt="By Visem (Own work) [CC BY-SA 3.0], via Wikimedia Commons"></p>
<p>The gamma correction should tend to add less saturation effect as the mapping is non linear and there is no numerical saturation possible as in the previous method.</p>
<p><img src="/images/Basic_Linear_Transform_Tutorial_histogram_compare.png" alt="Left: histogram after alpha, beta correction ; Center: histogram of the original image ; Right: histogram after the gamma correction"></p>
<p>The previous figure compares the histograms for the three images (the y-ranges are not the same between the three histograms).<br>You can notice that most of the pixel values are in the lower part of the histogram for the original image. After \f$ \alpha \f$,<br>\f$ \beta \f$ correction, we can observe a big peak at 255 due to the saturation as well as a shift in the right.<br>After gamma correction, the histogram is shifted to the right but the pixels in the dark regions are more shifted<br>(see the gamma curves <a href="Basic_Linear_Transform_Tutorial_gamma.png">figure</a>) than those in the bright regions.</p>
<p>In this tutorial, you have seen two simple methods to adjust the contrast and the brightness of an image. <strong>They are basic techniques<br>and are not intended to be used as a replacement of a raster graphics editor!</strong></p>
<h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><p>@add_toggle_cpp<br>Code for the tutorial is <a href="https://github.com/opencv/opencv/blob/3.4/samples/cpp/tutorial_code/ImgProc/changing_contrast_brightness_image/changing_contrast_brightness_image.cpp">here</a>.<br>@end_toggle</p>
<p>@add_toggle_java<br>Code for the tutorial is <a href="https://github.com/opencv/opencv/blob/3.4/samples/java/tutorial_code/ImgProc/changing_contrast_brightness_image/ChangingContrastBrightnessImageDemo.java">here</a>.<br>@end_toggle</p>
<p>@add_toggle_python<br>Code for the tutorial is <a href="https://github.com/opencv/opencv/blob/3.4/samples/python/tutorial_code/imgProc/changing_contrast_brightness_image/changing_contrast_brightness_image.py">here</a>.<br>@end_toggle</p>
<p>Code for the gamma correction:</p>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;changing_contrast_brightness_image&#x2F;changing_contrast_brightness_image.cpp changing-contrast-brightness-gamma-correction<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;changing_contrast_brightness_image&#x2F;ChangingContrastBrightnessImageDemo.java changing-contrast-brightness-gamma-correction<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;changing_contrast_brightness_image&#x2F;changing_contrast_brightness_image.py changing-contrast-brightness-gamma-correction<br>@end_toggle</p>
<p>A look-up table is used to improve the performance of the computation as only 256 values needs to be calculated once.</p>
<h3 id="Additional-resources"><a href="#Additional-resources" class="headerlink" title="Additional resources"></a>Additional resources</h3><ul>
<li><a href="https://learnopengl.com/#!Advanced-Lighting/Gamma-Correction">Gamma correction in graphics rendering</a></li>
<li><a href="http://www.graphics.cornell.edu/~westin/gamma/gamma.html">Gamma correction and images displayed on CRT monitors</a></li>
<li><a href="http://www.cambridgeincolour.com/tutorials/digital-exposure-techniques.htm">Digital exposure techniques</a></li>
</ul>
