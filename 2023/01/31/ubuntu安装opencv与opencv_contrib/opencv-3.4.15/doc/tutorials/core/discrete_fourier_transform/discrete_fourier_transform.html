<h1 id="Discrete-Fourier-Transform-tutorial-discrete-fourier-transform"><a href="#Discrete-Fourier-Transform-tutorial-discrete-fourier-transform" class="headerlink" title="Discrete Fourier Transform {#tutorial_discrete_fourier_transform}"></a>Discrete Fourier Transform {#tutorial_discrete_fourier_transform}</h1><p>@prev_tutorial{tutorial_basic_linear_transform}<br>@next_tutorial{tutorial_file_input_output_with_xml_yml}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>We’ll seek answers for the following questions:</p>
<ul>
<li>What is a Fourier transform and why use it?</li>
<li>How to do it in OpenCV?</li>
<li>Usage of functions such as: <strong>copyMakeBorder()</strong> , <strong>merge()</strong> , <strong>dft()</strong> ,<br><strong>getOptimalDFTSize()</strong> , <strong>log()</strong> and <strong>normalize()</strong> .</li>
</ul>
<h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h2><p>@add_toggle_cpp<br>You can <a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/cpp/tutorial_code/core/discrete_fourier_transform/discrete_fourier_transform.cpp">download this from here
</a> or<br>find it in the<br><code>samples/cpp/tutorial_code/core/discrete_fourier_transform/discrete_fourier_transform.cpp</code> of the<br>OpenCV source code library.<br>@end_toggle</p>
<p>@add_toggle_java<br>You can <a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/java/tutorial_code/core/discrete_fourier_transform/DiscreteFourierTransform.java">download this from here
</a> or<br>find it in the<br><code>samples/java/tutorial_code/core/discrete_fourier_transform/DiscreteFourierTransform.java</code> of the<br>OpenCV source code library.<br>@end_toggle</p>
<p>@add_toggle_python<br>You can <a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/python/tutorial_code/core/discrete_fourier_transform/discrete_fourier_transform.py">download this from here
</a> or<br>find it in the<br><code>samples/python/tutorial_code/core/discrete_fourier_transform/discrete_fourier_transform.py</code> of the<br>OpenCV source code library.<br>@end_toggle</p>
<p>Here’s a sample usage of <strong>dft()</strong> :</p>
<p>@add_toggle_cpp<br>@include cpp&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.cpp<br>@end_toggle</p>
<p>@add_toggle_java<br>@include java&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;DiscreteFourierTransform.java<br>@end_toggle</p>
<p>@add_toggle_python<br>@include python&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.py<br>@end_toggle</p>
<h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><p>The Fourier Transform will decompose an image into its sinus and cosines components. In other words,<br>it will transform an image from its spatial domain to its frequency domain. The idea is that any<br>function may be approximated exactly with the sum of infinite sinus and cosines functions. The<br>Fourier Transform is a way how to do this. Mathematically a two dimensional images Fourier transform<br>is:</p>
<p>\f[F(k,l) &#x3D; \displaystyle\sum\limits_{i&#x3D;0}^{N-1}\sum\limits_{j&#x3D;0}^{N-1} f(i,j)e^{-i2\pi(\frac{ki}{N}+\frac{lj}{N})}\f]\f[e^{ix} &#x3D; \cos{x} + i\sin {x}\f]</p>
<p>Here f is the image value in its spatial domain and F in its frequency domain. The result of the<br>transformation is complex numbers. Displaying this is possible either via a <em>real</em> image and a<br><em>complex</em> image or via a <em>magnitude</em> and a <em>phase</em> image. However, throughout the image processing<br>algorithms only the <em>magnitude</em> image is interesting as this contains all the information we need<br>about the images geometric structure. Nevertheless, if you intend to make some modifications of the<br>image in these forms and then you need to retransform it you’ll need to preserve both of these.</p>
<p>In this sample I’ll show how to calculate and show the <em>magnitude</em> image of a Fourier Transform. In<br>case of digital images are discrete. This means they may take up a value from a given domain value.<br>For example in a basic gray scale image values usually are between zero and 255. Therefore the<br>Fourier Transform too needs to be of a discrete type resulting in a Discrete Fourier Transform<br>(<em>DFT</em>). You’ll want to use this whenever you need to determine the structure of an image from a<br>geometrical point of view. Here are the steps to follow (in case of a gray scale input image <em>I</em>):</p>
<h4 id="Expand-the-image-to-an-optimal-size"><a href="#Expand-the-image-to-an-optimal-size" class="headerlink" title="Expand the image to an optimal size"></a>Expand the image to an optimal size</h4><p>The performance of a DFT is dependent of the image<br>size. It tends to be the fastest for image sizes that are multiple of the numbers two, three and<br>five. Therefore, to achieve maximal performance it is generally a good idea to pad border values<br>to the image to get a size with such traits. The <strong>getOptimalDFTSize()</strong> returns this<br>optimal size and we can use the <strong>copyMakeBorder()</strong> function to expand the borders of an<br>image (the appended pixels are initialized with zero):</p>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.cpp expand<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;DiscreteFourierTransform.java expand<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.py expand<br>@end_toggle</p>
<h4 id="Make-place-for-both-the-complex-and-the-real-values"><a href="#Make-place-for-both-the-complex-and-the-real-values" class="headerlink" title="Make place for both the complex and the real values"></a>Make place for both the complex and the real values</h4><p>The result of a Fourier Transform is<br>complex. This implies that for each image value the result is two image values (one per<br>component). Moreover, the frequency domains range is much larger than its spatial counterpart.<br>Therefore, we store these usually at least in a <em>float</em> format. Therefore we’ll convert our<br>input image to this type and expand it with another channel to hold the complex values:</p>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.cpp complex_and_real<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;DiscreteFourierTransform.java complex_and_real<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.py complex_and_real<br>@end_toggle</p>
<h4 id="Make-the-Discrete-Fourier-Transform"><a href="#Make-the-Discrete-Fourier-Transform" class="headerlink" title="Make the Discrete Fourier Transform"></a>Make the Discrete Fourier Transform</h4><p>It’s possible an in-place calculation (same input as<br>output):</p>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.cpp dft<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;DiscreteFourierTransform.java dft<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.py dft<br>@end_toggle</p>
<h4 id="Transform-the-real-and-complex-values-to-magnitude"><a href="#Transform-the-real-and-complex-values-to-magnitude" class="headerlink" title="Transform the real and complex values to magnitude"></a>Transform the real and complex values to magnitude</h4><p>A complex number has a real (<em>Re</em>) and a<br>complex (imaginary - <em>Im</em>) part. The results of a DFT are complex numbers. The magnitude of a<br>DFT is:</p>
<p>\f[M &#x3D; \sqrt[2]{ {Re(DFT(I))}^2 + {Im(DFT(I))}^2}\f]</p>
<p>Translated to OpenCV code:</p>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.cpp magnitude<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;DiscreteFourierTransform.java magnitude<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.py magnitude<br>@end_toggle</p>
<h4 id="Switch-to-a-logarithmic-scale"><a href="#Switch-to-a-logarithmic-scale" class="headerlink" title="Switch to a logarithmic scale"></a>Switch to a logarithmic scale</h4><p>It turns out that the dynamic range of the Fourier<br>coefficients is too large to be displayed on the screen. We have some small and some high<br>changing values that we can’t observe like this. Therefore the high values will all turn out as<br>white points, while the small ones as black. To use the gray scale values to for visualization<br>we can transform our linear scale to a logarithmic one:</p>
<p>\f[M_1 &#x3D; \log{(1 + M)}\f]</p>
<p>Translated to OpenCV code:</p>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.cpp log<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;DiscreteFourierTransform.java log<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.py log<br>@end_toggle</p>
<h4 id="Crop-and-rearrange"><a href="#Crop-and-rearrange" class="headerlink" title="Crop and rearrange"></a>Crop and rearrange</h4><p>Remember, that at the first step, we expanded the image? Well, it’s time<br>to throw away the newly introduced values. For visualization purposes we may also rearrange the<br>quadrants of the result, so that the origin (zero, zero) corresponds with the image center.</p>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.cpp crop_rearrange<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;DiscreteFourierTransform.java crop_rearrange<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.py crop_rearrange<br>@end_toggle</p>
<h4 id="Normalize"><a href="#Normalize" class="headerlink" title="Normalize"></a>Normalize</h4><p>This is done again for visualization purposes. We now have the magnitudes,<br>however this are still out of our image display range of zero to one. We normalize our values to<br>this range using the @ref cv::normalize() function.</p>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.cpp normalize<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;DiscreteFourierTransform.java normalize<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;core&#x2F;discrete_fourier_transform&#x2F;discrete_fourier_transform.py normalize<br>@end_toggle</p>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>An application idea would be to determine the geometrical orientation present in the image. For<br>example, let us find out if a text is horizontal or not? Looking at some text you’ll notice that the<br>text lines sort of form also horizontal lines and the letters form sort of vertical lines. These two<br>main components of a text snippet may be also seen in case of the Fourier transform. Let us use<br><a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/data/imageTextN.png">this horizontal </a> and <a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/data/imageTextR.png">this rotated</a><br>image about a text.</p>
<p>In case of the horizontal text:</p>
<p><img src="/images/result_normal.jpg"></p>
<p>In case of a rotated text:</p>
<p><img src="/images/result_rotated.jpg"></p>
<p>You can see that the most influential components of the frequency domain (brightest dots on the<br>magnitude image) follow the geometric rotation of objects on the image. From this we may calculate<br>the offset and perform an image rotation to correct eventual miss alignments.</p>
