<h1 id="File-Input-and-Output-using-XML-and-YAML-files-tutorial-file-input-output-with-xml-yml"><a href="#File-Input-and-Output-using-XML-and-YAML-files-tutorial-file-input-output-with-xml-yml" class="headerlink" title="File Input and Output using XML and YAML files {#tutorial_file_input_output_with_xml_yml}"></a>File Input and Output using XML and YAML files {#tutorial_file_input_output_with_xml_yml}</h1><p>@prev_tutorial{tutorial_discrete_fourier_transform}<br>@next_tutorial{tutorial_interoperability_with_OpenCV_1}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>You’ll find answers for the following questions:</p>
<ul>
<li>How to print and read text entries to a file and OpenCV using YAML or XML files?</li>
<li>How to do the same for OpenCV data structures?</li>
<li>How to do this for your data structures?</li>
<li>Usage of OpenCV data structures such as @ref cv::FileStorage , @ref cv::FileNode or @ref<br>cv::FileNodeIterator .</li>
</ul>
<h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h2><p>@add_toggle_cpp<br>You can <a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/core/file_input_output/file_input_output.cpp">download this from here
</a> or find it in the<br><code>samples/cpp/tutorial_code/core/file_input_output/file_input_output.cpp</code> of the OpenCV source code<br>library.</p>
<p>Here’s a sample code of how to achieve all the stuff enumerated at the goal list.</p>
<p>@include cpp&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.cpp<br>@end_toggle</p>
<p>@add_toggle_python<br>You can <a href="https://github.com/opencv/opencv/tree/3.4/samples/python/tutorial_code/core/file_input_output/file_input_output.py">download this from here
</a> or find it in the<br><code>samples/python/tutorial_code/core/file_input_output/file_input_output.py</code> of the OpenCV source code<br>library.</p>
<p>Here’s a sample code of how to achieve all the stuff enumerated at the goal list.</p>
<p>@include python&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.py<br>@end_toggle</p>
<h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><p>Here we talk only about XML and YAML file inputs. Your output (and its respective input) file may<br>have only one of these extensions and the structure coming from this. They are two kinds of data<br>structures you may serialize: <em>mappings</em> (like the STL map and the Python dictionary) and <em>element sequence</em> (like the STL<br>vector). The difference between these is that in a map every element has a unique name through what<br>you may access it. For sequences you need to go through them to query a specific item.</p>
<p>-#  <strong>XML&#x2F;YAML File Open and Close.</strong> Before you write any content to such file you need to open it<br>    and at the end to close it. The XML&#x2F;YAML data structure in OpenCV is @ref cv::FileStorage . To<br>    specify that this structure to which file binds on your hard drive you can use either its<br>    constructor or the <em>open()</em> function of this:<br>    @add_toggle_cpp<br>    @snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.cpp open<br>    @end_toggle<br>    @add_toggle_python<br>    @snippet python&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.py open<br>    @end_toggle<br>    Either one of this you use the second argument is a constant specifying the type of operations<br>    you’ll be able to on them: WRITE, READ or APPEND. The extension specified in the file name also<br>    determinates the output format that will be used. The output may be even compressed if you<br>    specify an extension such as <em>.xml.gz</em>.</p>
<pre><code>The file automatically closes when the @ref cv::FileStorage objects is destroyed. However, you
may explicitly call for this by using the *release* function:
@add_toggle_cpp
@snippet cpp/tutorial_code/core/file_input_output/file_input_output.cpp close
@end_toggle
@add_toggle_python
@snippet python/tutorial_code/core/file_input_output/file_input_output.py close
@end_toggle
</code></pre>
<p>-#  <strong>Input and Output of text and numbers.</strong> In C++, the data structure uses the &lt;&lt; output<br>    operator in the STL library. In Python, @ref cv::FileStorage.write() is used instead. For<br>    outputting any type of data structure we need first to specify its name. We do this by just<br>    simply pushing the name of this to the stream in C++. In Python, the first parameter for the<br>    write function is the name. For basic types you may follow this with the print of the value :<br>    @add_toggle_cpp<br>    @snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.cpp writeNum<br>    @end_toggle<br>    @add_toggle_python<br>    @snippet python&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.py writeNum<br>    @end_toggle<br>    Reading in is a simple addressing (via the [] operator) and casting operation or a read via<br>    the &gt;&gt; operator. In Python, we address with getNode() and use real() :<br>    @add_toggle_cpp<br>    @snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.cpp readNum<br>    @end_toggle<br>    @add_toggle_python<br>    @snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.cpp readNum<br>    @end_toggle<br>-#  <strong>Input&#x2F;Output of OpenCV Data structures.</strong> Well these behave exactly just as the basic C++<br>    and Python types:<br>    @add_toggle_cpp<br>    @snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.cpp iomati<br>    @snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.cpp iomatw<br>    @snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.cpp iomat<br>    @end_toggle<br>    @add_toggle_python<br>    @snippet python&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.py iomati<br>    @snippet python&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.py iomatw<br>    @snippet python&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.py iomat<br>    @end_toggle<br>-#  <strong>Input&#x2F;Output of vectors (arrays) and associative maps.</strong> As I mentioned beforehand, we can<br>    output maps and sequences (array, vector) too. Again we first print the name of the variable and<br>    then we have to specify if our output is either a sequence or map.</p>
<pre><code>For sequence before the first element print the &quot;[&quot; character and after the last one the &quot;]&quot;
character. With Python, call `FileStorage.startWriteStruct(structure_name, struct_type)`,
where `struct_type` is `cv2.FileNode_MAP` or `cv2.FileNode_SEQ` to start writing the structure.
Call `FileStorage.endWriteStruct()` to finish the structure:
@add_toggle_cpp
@snippet cpp/tutorial_code/core/file_input_output/file_input_output.cpp writeStr
@end_toggle
@add_toggle_python
@snippet python/tutorial_code/core/file_input_output/file_input_output.py writeStr
@end_toggle
For maps the drill is the same however now we use the &quot;{&quot; and &quot;}&quot; delimiter characters:
@add_toggle_cpp
@snippet cpp/tutorial_code/core/file_input_output/file_input_output.cpp writeMap
@end_toggle
@add_toggle_python
@snippet python/tutorial_code/core/file_input_output/file_input_output.py writeMap
@end_toggle
To read from these we use the @ref cv::FileNode and the @ref cv::FileNodeIterator data
structures. The [] operator of the @ref cv::FileStorage class (or the getNode() function in Python) returns a @ref cv::FileNode data
type. If the node is sequential we can use the @ref cv::FileNodeIterator to iterate through the
items. In Python, the at() function can be used to address elements of the sequence and the
size() function returns the length of the sequence:
@add_toggle_cpp
@snippet cpp/tutorial_code/core/file_input_output/file_input_output.cpp readStr
@end_toggle
@add_toggle_python
@snippet python/tutorial_code/core/file_input_output/file_input_output.py readStr
@end_toggle
For maps you can use the [] operator (at() function in Python) again to access the given item (or the \&gt;\&gt; operator too):
@add_toggle_cpp
@snippet cpp/tutorial_code/core/file_input_output/file_input_output.cpp readMap
@end_toggle
@add_toggle_python
@snippet python/tutorial_code/core/file_input_output/file_input_output.py readMap
@end_toggle
</code></pre>
<p>-#  <strong>Read and write your own data structures.</strong> Suppose you have a data structure such as:<br>    @add_toggle_cpp<br>    @code{.cpp}<br>    class MyData<br>    {<br>    public:<br>          MyData() : A(0), X(0), id() {}<br>    public:   &#x2F;&#x2F; Data Members<br>       int A;<br>       double X;<br>       string id;<br>    };<br>    @endcode<br>    @end_toggle<br>    @add_toggle_python<br>    @code{.py}<br>    class MyData:<br>        def <strong>init</strong>(self):<br>            self.A &#x3D; self.X &#x3D; 0<br>            self.name &#x3D; ‘’<br>    @endcode<br>    @end_toggle<br>    In C++, it’s possible to serialize this through the OpenCV I&#x2F;O XML&#x2F;YAML interface (just as<br>    in case of the OpenCV data structures) by adding a read and a write function inside and outside of your<br>    class. In Python, you can get close to this by implementing a read and write function inside<br>    the class. For the inside part:<br>    @add_toggle_cpp<br>    @snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.cpp inside<br>    @end_toggle<br>    @add_toggle_python<br>    @snippet python&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.py inside<br>    @end_toggle<br>    @add_toggle_cpp<br>    In C++, you need to add the following functions definitions outside the class:<br>    @snippet cpp&#x2F;tutorial_code&#x2F;core&#x2F;file_input_output&#x2F;file_input_output.cpp outside<br>    @end_toggle<br>    Here you can observe that in the read section we defined what happens if the user tries to read<br>    a non-existing node. In this case we just return the default initialization value, however a<br>    more verbose solution would be to return for instance a minus one value for an object ID.</p>
<pre><code>Once you added these four functions use the \&gt;\&gt; operator for write and the \&lt;\&lt; operator for
read (or the defined input/output functions for Python):
@add_toggle_cpp
@snippet cpp/tutorial_code/core/file_input_output/file_input_output.cpp customIOi
@snippet cpp/tutorial_code/core/file_input_output/file_input_output.cpp customIOw
@snippet cpp/tutorial_code/core/file_input_output/file_input_output.cpp customIO
@end_toggle
@add_toggle_python
@snippet python/tutorial_code/core/file_input_output/file_input_output.py customIOi
@snippet python/tutorial_code/core/file_input_output/file_input_output.py customIOw
@snippet python/tutorial_code/core/file_input_output/file_input_output.py customIO
@end_toggle
Or to try out reading a non-existing read:
@add_toggle_cpp
@snippet cpp/tutorial_code/core/file_input_output/file_input_output.cpp nonexist
@end_toggle
@add_toggle_python
@snippet python/tutorial_code/core/file_input_output/file_input_output.py nonexist
@end_toggle
</code></pre>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>Well mostly we just print out the defined numbers. On the screen of your console you could see:<br>@code{.bash}<br>Write Done.</p>
<p>Reading:<br>100image1.jpg<br>Awesomeness<br>baboon.jpg<br>Two  2; One  1</p>
<p>R &#x3D; [1, 0, 0;<br>  0, 1, 0;<br>  0, 0, 1]<br>T &#x3D; [0; 0; 0]</p>
<p>MyData &#x3D;<br>{ id &#x3D; mydata1234, X &#x3D; 3.14159, A &#x3D; 97}</p>
<p>Attempt to read NonExisting (should initialize the data structure with its default).<br>NonExisting &#x3D;<br>{ id &#x3D; , X &#x3D; 0, A &#x3D; 0}</p>
<p>Tip: Open up output.xml with a text editor to see the serialized data.<br>@endcode<br>Nevertheless, it’s much more interesting what you may see in the output xml file:<br>@code{.xml}<br><?xml version="1.0"?><br><opencv_storage><br><iterationNr>100</iterationNr><br><strings><br>  image1.jpg Awesomeness baboon.jpg</strings><br><Mapping><br>  <One>1</One><br>  <Two>2</Two></Mapping><br><R type_id="opencv-matrix"><br>  <rows>3</rows><br>  <cols>3</cols><br>  <dt>u</dt><br>  <data><br>    1 0 0 0 1 0 0 0 1</data></R><br><T type_id="opencv-matrix"><br>  <rows>3</rows><br>  <cols>1</cols><br>  <dt>d</dt><br>  <data><br>    0. 0. 0.</data></T><br><MyData><br>  <A>97</A><br>  <X>3.1415926535897931e+000</X><br>  <id>mydata1234</id></MyData><br></opencv_storage><br>@endcode<br>Or the YAML file:<br>@code{.yaml}<br>%YAML:1.0<br>iterationNr: 100<br>strings:</p>
<ul>
<li>“image1.jpg”</li>
<li>Awesomeness</li>
<li>“baboon.jpg”<br>Mapping:<br>   One: 1<br>   Two: 2<br>R: !!opencv-matrix<br>   rows: 3<br>   cols: 3<br>   dt: u<br>   data: [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]<br>T: !!opencv-matrix<br>   rows: 3<br>   cols: 1<br>   dt: d<br>   data: [ 0., 0., 0. ]<br>MyData:<br>   A: 97<br>   X: 3.1415926535897931e+000<br>   id: mydata1234<br>@endcode<br>You may observe a runtime instance of this on the <a href="https://www.youtube.com/watch?v=A4yqVnByMMM">YouTube<br>here</a> .</li>
</ul>
<p>@youtube{A4yqVnByMMM}</p>
