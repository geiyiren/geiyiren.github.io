<h1 id="How-to-scan-images-lookup-tables-and-time-measurement-with-OpenCV-tutorial-how-to-scan-images"><a href="#How-to-scan-images-lookup-tables-and-time-measurement-with-OpenCV-tutorial-how-to-scan-images" class="headerlink" title="How to scan images, lookup tables and time measurement with OpenCV {#tutorial_how_to_scan_images}"></a>How to scan images, lookup tables and time measurement with OpenCV {#tutorial_how_to_scan_images}</h1><p>@prev_tutorial{tutorial_mat_the_basic_image_container}<br>@next_tutorial{tutorial_mat_mask_operations}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>We’ll seek answers for the following questions:</p>
<ul>
<li>How to go through each and every pixel of an image?</li>
<li>How are OpenCV matrix values stored?</li>
<li>How to measure the performance of our algorithm?</li>
<li>What are lookup tables and why use them?</li>
</ul>
<h2 id="Our-test-case"><a href="#Our-test-case" class="headerlink" title="Our test case"></a>Our test case</h2><p>Let us consider a simple color reduction method. By using the unsigned char C and C++ type for<br>matrix item storing, a channel of pixel may have up to 256 different values. For a three channel<br>image this can allow the formation of way too many colors (16 million to be exact). Working with so<br>many color shades may give a heavy blow to our algorithm performance. However, sometimes it is<br>enough to work with a lot less of them to get the same final result.</p>
<p>In this cases it’s common that we make a <em>color space reduction</em>. This means that we divide the<br>color space current value with a new input value to end up with fewer colors. For instance every<br>value between zero and nine takes the new value zero, every value between ten and nineteen the value<br>ten and so on.</p>
<p>When you divide an <em>uchar</em> (unsigned char - aka values between zero and 255) value with an <em>int</em><br>value the result will be also <em>char</em>. These values may only be char values. Therefore, any fraction<br>will be rounded down. Taking advantage of this fact the upper operation in the <em>uchar</em> domain may be<br>expressed as:</p>
<p>\f[I_{new} &#x3D; (\frac{I_{old}}{10}) * 10\f]</p>
<p>A simple color space reduction algorithm would consist of just passing through every pixel of an<br>image matrix and applying this formula. It’s worth noting that we do a divide and a multiplication<br>operation. These operations are bloody expensive for a system. If possible it’s worth avoiding them<br>by using cheaper operations such as a few subtractions, addition or in best case a simple<br>assignment. Furthermore, note that we only have a limited number of input values for the upper<br>operation. In case of the <em>uchar</em> system this is 256 to be exact.</p>
<p>Therefore, for larger images it would be wise to calculate all possible values beforehand and during<br>the assignment just make the assignment, by using a lookup table. Lookup tables are simple arrays<br>(having one or more dimensions) that for a given input value variation holds the final output value.<br>Its strength is that we do not need to make the calculation, we just need to read the result.</p>
<p>Our test case program (and the code sample below) will do the following: read in an image passed<br>as a command line argument (it may be either color or grayscale) and apply the reduction<br>with the given command line argument integer value. In OpenCV, at the moment there are<br>three major ways of going through an image pixel by pixel. To make things a little more interesting<br>we’ll make the scanning of the image using each of these methods, and print out how long it took.</p>
<p>You can download the full source code <a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/core/how_to_scan_images/how_to_scan_images.cpp">here
</a> or look it up in<br>the samples directory of OpenCV at the cpp tutorial code for the core section. Its basic usage is:<br>@code{.bash}<br>how_to_scan_images imageName.jpg intValueToReduce [G]<br>@endcode<br>The final argument is optional. If given the image will be loaded in grayscale format, otherwise<br>the BGR color space is used. The first thing is to calculate the lookup table.</p>
<p>@snippet how_to_scan_images.cpp dividewith</p>
<p>Here we first use the C++ <em>stringstream</em> class to convert the third command line argument from text<br>to an integer format. Then we use a simple look and the upper formula to calculate the lookup table.<br>No OpenCV specific stuff here.</p>
<p>Another issue is how do we measure time? Well OpenCV offers two simple functions to achieve this<br>cv::getTickCount() and cv::getTickFrequency() . The first returns the number of ticks of<br>your systems CPU from a certain event (like since you booted your system). The second returns how<br>many times your CPU emits a tick during a second. So, measuring amount of time elapsed between<br>two operations is as easy as:<br>@code{.cpp}<br>double t &#x3D; (double)getTickCount();<br>&#x2F;&#x2F; do something …<br>t &#x3D; ((double)getTickCount() - t)&#x2F;getTickFrequency();<br>cout &lt;&lt; “Times passed in seconds: “ &lt;&lt; t &lt;&lt; endl;<br>@endcode</p>
<h2 id="anchor-tutorial-how-to-scan-images-storingHow-is-the-image-matrix-stored-in-memory"><a href="#anchor-tutorial-how-to-scan-images-storingHow-is-the-image-matrix-stored-in-memory" class="headerlink" title="@anchor tutorial_how_to_scan_images_storingHow is the image matrix stored in memory?"></a>@anchor tutorial_how_to_scan_images_storing<br>How is the image matrix stored in memory?</h2><p>As you could already read in my @ref tutorial_mat_the_basic_image_container tutorial the size of the matrix<br>depends on the color system used. More accurately, it depends on the number of channels used. In<br>case of a grayscale image we have something like:</p>
<p><img src="/tutorial_how_matrix_stored_1.png"></p>
<p>For multichannel images the columns contain as many sub columns as the number of channels. For<br>example in case of an BGR color system:</p>
<p><img src="/tutorial_how_matrix_stored_2.png"></p>
<p>Note that the order of the channels is inverse: BGR instead of RGB. Because in many cases the memory<br>is large enough to store the rows in a successive fashion the rows may follow one after another,<br>creating a single long row. Because everything is in a single place following one after another this<br>may help to speed up the scanning process. We can use the cv::Mat::isContinuous() function to <em>ask</em><br>the matrix if this is the case. Continue on to the next section to find an example.</p>
<h2 id="The-efficient-way"><a href="#The-efficient-way" class="headerlink" title="The efficient way"></a>The efficient way</h2><p>When it comes to performance you cannot beat the classic C style operator[] (pointer) access.<br>Therefore, the most efficient method we can recommend for making the assignment is:</p>
<p>@snippet how_to_scan_images.cpp scan-c</p>
<p>Here we basically just acquire a pointer to the start of each row and go through it until it ends.<br>In the special case that the matrix is stored in a continuous manner we only need to request the<br>pointer a single time and go all the way to the end. We need to look out for color images: we have<br>three channels so we need to pass through three times more items in each row.</p>
<p>There’s another way of this. The <em>data</em> data member of a <em>Mat</em> object returns the pointer to the<br>first row, first column. If this pointer is null you have no valid input in that object. Checking<br>this is the simplest method to check if your image loading was a success. In case the storage is<br>continuous we can use this to go through the whole data pointer. In case of a grayscale image this<br>would look like:<br>@code{.cpp}<br>uchar* p &#x3D; I.data;</p>
<p>for( unsigned int i &#x3D; 0; i &lt; ncol*nrows; ++i)<br>    *p++ &#x3D; table[*p];<br>@endcode<br>You would get the same result. However, this code is a lot harder to read later on. It gets even<br>harder if you have some more advanced technique there. Moreover, in practice I’ve observed you’ll<br>get the same performance result (as most of the modern compilers will probably make this small<br>optimization trick automatically for you).</p>
<h2 id="The-iterator-safe-method"><a href="#The-iterator-safe-method" class="headerlink" title="The iterator (safe) method"></a>The iterator (safe) method</h2><p>In case of the efficient way making sure that you pass through the right amount of <em>uchar</em> fields<br>and to skip the gaps that may occur between the rows was your responsibility. The iterator method is<br>considered a safer way as it takes over these tasks from the user. All you need to do is to ask the<br>begin and the end of the image matrix and then just increase the begin iterator until you reach the<br>end. To acquire the value <em>pointed</em> by the iterator use the * operator (add it before it).</p>
<p>@snippet how_to_scan_images.cpp scan-iterator</p>
<p>In case of color images we have three uchar items per column. This may be considered a short vector<br>of uchar items, that has been baptized in OpenCV with the <em>Vec3b</em> name. To access the n-th sub<br>column we use simple operator[] access. It’s important to remember that OpenCV iterators go through<br>the columns and automatically skip to the next row. Therefore in case of color images if you use a<br>simple <em>uchar</em> iterator you’ll be able to access only the blue channel values.</p>
<h2 id="On-the-fly-address-calculation-with-reference-returning"><a href="#On-the-fly-address-calculation-with-reference-returning" class="headerlink" title="On-the-fly address calculation with reference returning"></a>On-the-fly address calculation with reference returning</h2><p>The final method isn’t recommended for scanning. It was made to acquire or modify somehow random<br>elements in the image. Its basic usage is to specify the row and column number of the item you want<br>to access. During our earlier scanning methods you could already notice that it is important through<br>what type we are looking at the image. It’s no different here as you need to manually specify what<br>type to use at the automatic lookup. You can observe this in case of the grayscale images for the<br>following source code (the usage of the + cv::Mat::at() function):</p>
<p>@snippet how_to_scan_images.cpp scan-random</p>
<p>The function takes your input type and coordinates and calculates the address of the<br>queried item. Then returns a reference to that. This may be a constant when you <em>get</em> the value and<br>non-constant when you <em>set</em> the value. As a safety step in <strong>debug mode only</strong>* there is a check<br>performed that your input coordinates are valid and do exist. If this isn’t the case you’ll get a<br>nice output message of this on the standard error output stream. Compared to the efficient way in<br>release mode the only difference in using this is that for every element of the image you’ll get a<br>new row pointer for what we use the C operator[] to acquire the column element.</p>
<p>If you need to do multiple lookups using this method for an image it may be troublesome and time<br>consuming to enter the type and the at keyword for each of the accesses. To solve this problem<br>OpenCV has a cv::Mat_ data type. It’s the same as Mat with the extra need that at definition<br>you need to specify the data type through what to look at the data matrix, however in return you can<br>use the operator() for fast access of items. To make things even better this is easily convertible<br>from and to the usual cv::Mat data type. A sample usage of this you can see in case of the<br>color images of the function above. Nevertheless, it’s important to note that the same operation<br>(with the same runtime speed) could have been done with the cv::Mat::at function. It’s just a less<br>to write for the lazy programmer trick.</p>
<h2 id="The-Core-Function"><a href="#The-Core-Function" class="headerlink" title="The Core Function"></a>The Core Function</h2><p>This is a bonus method of achieving lookup table modification in an image. In image<br>processing it’s quite common that you want to modify all of a given image values to some other value.<br>OpenCV provides a function for modifying image values, without the need to write the scanning logic<br>of the image. We use the cv::LUT() function of the core module. First we build a Mat type of the<br>lookup table:</p>
<p>@snippet how_to_scan_images.cpp table-init</p>
<p>Finally call the function (I is our input image and J the output one):</p>
<p>@snippet how_to_scan_images.cpp table-use</p>
<h2 id="Performance-Difference"><a href="#Performance-Difference" class="headerlink" title="Performance Difference"></a>Performance Difference</h2><p>For the best result compile the program and run it yourself. To make the differences more<br>clear, I’ve used a quite large (2560 X 1600) image. The performance presented here are for<br>color images. For a more accurate value I’ve averaged the value I got from the call of the function<br>for hundred times.</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Time</th>
</tr>
</thead>
<tbody><tr>
<td>Efficient Way</td>
<td>79.4717 milliseconds</td>
</tr>
<tr>
<td>Iterator</td>
<td>83.7201 milliseconds</td>
</tr>
<tr>
<td>On-The-Fly RA</td>
<td>93.7878 milliseconds</td>
</tr>
<tr>
<td>LUT function</td>
<td>32.5759 milliseconds</td>
</tr>
</tbody></table>
<p>We can conclude a couple of things. If possible, use the already made functions of OpenCV (instead<br>of reinventing these). The fastest method turns out to be the LUT function. This is because the OpenCV<br>library is multi-thread enabled via Intel Threaded Building Blocks. However, if you need to write a<br>simple image scan prefer the pointer method. The iterator is a safer bet, however quite slower.<br>Using the on-the-fly reference access method for full image scan is the most costly in debug mode.<br>In the release mode it may beat the iterator approach or not, however it surely sacrifices for this<br>the safety trait of iterators.</p>
<p>Finally, you may watch a sample run of the program on the <a href="https://www.youtube.com/watch?v=fB3AN5fjgwc">video posted</a> on our YouTube channel.</p>
<p>@youtube{fB3AN5fjgwc}</p>
