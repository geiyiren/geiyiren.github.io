<h1 id="How-to-use-the-OpenCV-parallel-for-to-parallelize-your-code-tutorial-how-to-use-OpenCV-parallel-for"><a href="#How-to-use-the-OpenCV-parallel-for-to-parallelize-your-code-tutorial-how-to-use-OpenCV-parallel-for" class="headerlink" title="How to use the OpenCV parallel_for_ to parallelize your code {#tutorial_how_to_use_OpenCV_parallel_for_}"></a>How to use the OpenCV parallel_for_ to parallelize your code {#tutorial_how_to_use_OpenCV_parallel_for_}</h1><p>@prev_tutorial{tutorial_interoperability_with_OpenCV_1}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>The goal of this tutorial is to show you how to use the OpenCV <code>parallel_for_</code> framework to easily<br>parallelize your code. To illustrate the concept, we will write a program to draw a Mandelbrot set<br>exploiting almost all the CPU load available.<br>The full tutorial code is <a href="https://github.com/opencv/opencv/blob/3.4/samples/cpp/tutorial_code/core/how_to_use_OpenCV_parallel_for_/how_to_use_OpenCV_parallel_for_.cpp">here</a>.<br>If you want more information about multithreading, you will have to refer to a reference book or course as this tutorial is intended<br>to remain simple.</p>
<h2 id="Precondition"><a href="#Precondition" class="headerlink" title="Precondition"></a>Precondition</h2><p>The first precondition is to have OpenCV built with a parallel framework.<br>In OpenCV 3.2, the following parallel frameworks are available in that order:</p>
<ol>
<li>Intel Threading Building Blocks (3rdparty library, should be explicitly enabled)</li>
<li>C&#x3D; Parallel C&#x2F;C++ Programming Language Extension (3rdparty library, should be explicitly enabled)</li>
<li>OpenMP (integrated to compiler, should be explicitly enabled)</li>
<li>APPLE GCD (system wide, used automatically (APPLE only))</li>
<li>Windows RT concurrency (system wide, used automatically (Windows RT only))</li>
<li>Windows concurrency (part of runtime, used automatically (Windows only - MSVC++ &gt;&#x3D; 10))</li>
<li>Pthreads (if available)</li>
</ol>
<p>As you can see, several parallel frameworks can be used in the OpenCV library. Some parallel libraries<br>are third party libraries and have to be explicitly built and enabled in CMake (e.g. TBB, C&#x3D;), others are<br>automatically available with the platform (e.g. APPLE GCD) but chances are that you should be enable to<br>have access to a parallel framework either directly or by enabling the option in CMake and rebuild the library.</p>
<p>The second (weak) precondition is more related to the task you want to achieve as not all computations<br>are suitable &#x2F; can be adapted to be run in a parallel way. To remain simple, tasks that can be split<br>into multiple elementary operations with no memory dependency (no possible race condition) are easily<br>parallelizable. Computer vision processing are often easily parallelizable as most of the time the processing of<br>one pixel does not depend to the state of other pixels.</p>
<h2 id="Simple-example-drawing-a-Mandelbrot-set"><a href="#Simple-example-drawing-a-Mandelbrot-set" class="headerlink" title="Simple example: drawing a Mandelbrot set"></a>Simple example: drawing a Mandelbrot set</h2><p>We will use the example of drawing a Mandelbrot set to show how from a regular sequential code you can easily adapt<br>the code to parallelize the computation.</p>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>The Mandelbrot set definition has been named in tribute to the mathematician Benoit Mandelbrot by the mathematician<br>Adrien Douady. It has been famous outside of the mathematics field as the image representation is an example of a<br>class of fractals, a mathematical set that exhibits a repeating pattern displayed at every scale (even more, a<br>Mandelbrot set is self-similar as the whole shape can be repeatedly seen at different scale). For a more in-depth<br>introduction, you can look at the corresponding <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Wikipedia article</a>.<br>Here, we will just introduce the formula to draw the Mandelbrot set (from the mentioned Wikipedia article).</p>
<blockquote>
<p>The Mandelbrot set is the set of values of \f$ c \f$ in the complex plane for which the orbit of 0 under iteration<br>of the quadratic map<br>\f[\begin{cases} z_0 &#x3D; 0 \ z_{n+1} &#x3D; z_n^2 + c \end{cases}\f]<br>remains bounded.<br>That is, a complex number \f$ c \f$ is part of the Mandelbrot set if, when starting with \f$ z_0 &#x3D; 0 \f$ and applying<br>the iteration repeatedly, the absolute value of \f$ z_n \f$ remains bounded however large \f$ n \f$ gets.<br>This can also be represented as<br>\f[\limsup_{n\to\infty}|z_{n+1}|\leqslant2\f]</p>
</blockquote>
<h2 id="Pseudocode"><a href="#Pseudocode" class="headerlink" title="Pseudocode"></a>Pseudocode</h2><p>A simple algorithm to generate a representation of the Mandelbrot set is called the<br><a href="https://en.wikipedia.org/wiki/Mandelbrot_set#Escape_time_algorithm">“escape time algorithm”</a>.<br>For each pixel in the rendered image, we test using the recurrence relation if the complex number is bounded or not<br>under a maximum number of iterations. Pixels that do not belong to the Mandelbrot set will escape quickly whereas<br>we assume that the pixel is in the set after a fixed maximum number of iterations. A high value of iterations will<br>produce a more detailed image but the computation time will increase accordingly. We use the number of iterations<br>needed to “escape” to depict the pixel value in the image.</p>
<pre><code>For each pixel (Px, Py) on the screen, do:
{
  x0 = scaled x coordinate of pixel (scaled to lie in the Mandelbrot X scale (-2, 1))
  y0 = scaled y coordinate of pixel (scaled to lie in the Mandelbrot Y scale (-1, 1))
  x = 0.0
  y = 0.0
  iteration = 0
  max_iteration = 1000
  while (x*x + y*y &lt; 2*2  AND  iteration &lt; max_iteration) {
    xtemp = x*x - y*y + x0
    y = 2*x*y + y0
    x = xtemp
    iteration = iteration + 1
  }
  color = palette[iteration]
  plot(Px, Py, color)
}
</code></pre>
<p>To relate between the pseudocode and the theory, we have:</p>
<ul>
<li>\f$ z &#x3D; x + iy \f$</li>
<li>\f$ z^2 &#x3D; x^2 + i2xy - y^2 \f$</li>
<li>\f$ c &#x3D; x_0 + iy_0 \f$</li>
</ul>
<p><img src="/images/how_to_use_OpenCV_parallel_for_640px-Mandelset_hires.png"></p>
<p>On this figure, we recall that the real part of a complex number is on the x-axis and the imaginary part on the y-axis.<br>You can see that the whole shape can be repeatedly visible if we zoom at particular locations.</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><h2 id="Escape-time-algorithm-implementation"><a href="#Escape-time-algorithm-implementation" class="headerlink" title="Escape time algorithm implementation"></a>Escape time algorithm implementation</h2><p>@snippet how_to_use_OpenCV_parallel_for_.cpp mandelbrot-escape-time-algorithm</p>
<p>Here, we used the <a href="http://en.cppreference.com/w/cpp/numeric/complex"><code>std::complex</code></a> template class to represent a<br>complex number. This function performs the test to check if the pixel is in set or not and returns the “escaped” iteration.</p>
<h2 id="Sequential-Mandelbrot-implementation"><a href="#Sequential-Mandelbrot-implementation" class="headerlink" title="Sequential Mandelbrot implementation"></a>Sequential Mandelbrot implementation</h2><p>@snippet how_to_use_OpenCV_parallel_for_.cpp mandelbrot-sequential</p>
<p>In this implementation, we sequentially iterate over the pixels in the rendered image to perform the test to check if the<br>pixel is likely to belong to the Mandelbrot set or not.</p>
<p>Another thing to do is to transform the pixel coordinate into the Mandelbrot set space with:</p>
<p>@snippet how_to_use_OpenCV_parallel_for_.cpp mandelbrot-transformation</p>
<p>Finally, to assign the grayscale value to the pixels, we use the following rule:</p>
<ul>
<li>a pixel is black if it reaches the maximum number of iterations (pixel is assumed to be in the Mandelbrot set),</li>
<li>otherwise we assign a grayscale value depending on the escaped iteration and scaled to fit the grayscale range.</li>
</ul>
<p>@snippet how_to_use_OpenCV_parallel_for_.cpp mandelbrot-grayscale-value</p>
<p>Using a linear scale transformation is not enough to perceive the grayscale variation. To overcome this, we will boost<br>the perception by using a square root scale transformation (borrowed from Jeremy D. Frens in his<br><a href="http://www.programming-during-recess.net/2016/06/26/color-schemes-for-mandelbrot-sets/">blog post</a>):<br>\f$ f \left( x \right) &#x3D; \sqrt{\frac{x}{\text{maxIter}}} \times 255 \f$</p>
<p><img src="/images/how_to_use_OpenCV_parallel_for_sqrt_scale_transformation.png"></p>
<p>The green curve corresponds to a simple linear scale transformation, the blue one to a square root scale transformation<br>and you can observe how the lowest values will be boosted when looking at the slope at these positions.</p>
<h2 id="Parallel-Mandelbrot-implementation"><a href="#Parallel-Mandelbrot-implementation" class="headerlink" title="Parallel Mandelbrot implementation"></a>Parallel Mandelbrot implementation</h2><p>When looking at the sequential implementation, we can notice that each pixel is computed independently. To optimize the<br>computation, we can perform multiple pixel calculations in parallel, by exploiting the multi-core architecture of modern<br>processor. To achieve this easily, we will use the OpenCV @ref cv::parallel_for_ framework.</p>
<p>@snippet how_to_use_OpenCV_parallel_for_.cpp mandelbrot-parallel</p>
<p>The first thing is to declare a custom class that inherits from @ref cv::ParallelLoopBody and to override the<br><code>virtual void operator ()(const cv::Range&amp; range) const</code>.</p>
<p>The range in the <code>operator ()</code> represents the subset of pixels that will be treated by an individual thread.<br>This splitting is done automatically to distribute equally the computation load. We have to convert the pixel index coordinate<br>to a 2D <code>[row, col]</code> coordinate. Also note that we have to keep a reference on the mat image to be able to modify in-place<br>the image.</p>
<p>The parallel execution is called with:</p>
<p>@snippet how_to_use_OpenCV_parallel_for_.cpp mandelbrot-parallel-call</p>
<p>Here, the range represents the total number of operations to be executed, so the total number of pixels in the image.<br>To set the number of threads, you can use: @ref cv::setNumThreads. You can also specify the number of splitting using the<br>nstripes parameter in @ref cv::parallel_for_. For instance, if your processor has 4 threads, setting <code>cv::setNumThreads(2)</code><br>or setting <code>nstripes=2</code> should be the same as by default it will use all the processor threads available but will split the<br>workload only on two threads.</p>
<p>@note<br>C++ 11 standard allows to simplify the parallel implementation by get rid of the <code>ParallelMandelbrot</code> class and replacing it with lambda expression:</p>
<p>@snippet how_to_use_OpenCV_parallel_for_.cpp mandelbrot-parallel-call-cxx11</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>You can find the full tutorial code <a href="https://github.com/opencv/opencv/blob/3.4/samples/cpp/tutorial_code/core/how_to_use_OpenCV_parallel_for_/how_to_use_OpenCV_parallel_for_.cpp">here</a>.<br>The performance of the parallel implementation depends of the type of CPU you have. For instance, on 4 cores &#x2F; 8 threads<br>CPU, you can expect a speed-up of around 6.9X. There are many factors to explain why we do not achieve a speed-up of almost 8X.<br>Main reasons should be mostly due to:</p>
<ul>
<li>the overhead to create and manage the threads,</li>
<li>background processes running in parallel,</li>
<li>the difference between 4 hardware cores with 2 logical threads for each core and 8 hardware cores.</li>
</ul>
<p>The resulting image produced by the tutorial code (you can modify the code to use more iterations and assign a pixel color<br>depending on the escaped iteration and using a color palette to get more aesthetic images):<br><img src="/images/how_to_use_OpenCV_parallel_for_Mandelbrot.png" alt="Mandelbrot set with xMin=-2.1, xMax=0.6, yMin=-1.2, yMax=1.2, maxIterations=500"></p>
