<h1 id="Interoperability-with-OpenCV-1-tutorial-interoperability-with-OpenCV-1"><a href="#Interoperability-with-OpenCV-1-tutorial-interoperability-with-OpenCV-1" class="headerlink" title="Interoperability with OpenCV 1 {#tutorial_interoperability_with_OpenCV_1}"></a>Interoperability with OpenCV 1 {#tutorial_interoperability_with_OpenCV_1}</h1><p>@prev_tutorial{tutorial_file_input_output_with_xml_yml}<br>@next_tutorial{tutorial_how_to_use_OpenCV_parallel_for_}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>For the OpenCV developer team it’s important to constantly improve the library. We are constantly<br>thinking about methods that will ease your work process, while still maintain the libraries<br>flexibility. The new C++ interface is a development of us that serves this goal. Nevertheless,<br>backward compatibility remains important. We do not want to break your code written for earlier<br>version of the OpenCV library. Therefore, we made sure that we add some functions that deal with<br>this. In the following you’ll learn:</p>
<ul>
<li>What changed with the version 2 of OpenCV in the way you use the library compared to its first<br>version</li>
<li>How to add some Gaussian noise to an image</li>
<li>What are lookup tables and why use them?</li>
</ul>
<h2 id="General"><a href="#General" class="headerlink" title="General"></a>General</h2><p>When making the switch you first need to learn some about the new data structure for images:<br>@ref tutorial_mat_the_basic_image_container, this replaces the old <em>CvMat</em> and <em>IplImage</em> ones. Switching to the new<br>functions is easier. You just need to remember a couple of new things.</p>
<p>OpenCV 2 received reorganization. No longer are all the functions crammed into a single library. We<br>have many modules, each of them containing data structures and functions relevant to certain tasks.<br>This way you do not need to ship a large library if you use just a subset of OpenCV. This means that<br>you should also include only those headers you will use. For example:<br>@code{.cpp}<br>#include &lt;opencv2&#x2F;core.hpp&gt;<br>#include &lt;opencv2&#x2F;imgproc.hpp&gt;<br>#include &lt;opencv2&#x2F;highgui.hpp&gt;<br>@endcode<br>All the OpenCV related stuff is put into the <em>cv</em> namespace to avoid name conflicts with other<br>libraries data structures and functions. Therefore, either you need to prepend the <em>cv::</em> keyword<br>before everything that comes from OpenCV or after the includes, you just add a directive to use<br>this:<br>@code{.cpp}<br>using namespace cv;  &#x2F;&#x2F; The new C++ interface API is inside this namespace. Import it.<br>@endcode<br>Because the functions are already in a namespace there is no need for them to contain the <em>cv</em><br>prefix in their name. As such all the new C++ compatible functions don’t have this and they follow<br>the camel case naming rule. This means the first letter is small (unless it’s a name, like Canny)<br>and the subsequent words start with a capital letter (like <em>copyMakeBorder</em>).</p>
<p>Now, remember that you need to link to your application all the modules you use, and in case you are<br>on Windows using the <em>DLL</em> system you will need to add, again, to the path all the binaries. For<br>more in-depth information if you’re on Windows read @ref tutorial_windows_visual_studio_opencv and for<br>Linux an example usage is explained in @ref tutorial_linux_eclipse.</p>
<p>Now for converting the <em>Mat</em> object you can use either the <em>IplImage</em> or the <em>CvMat</em> operators.<br>While in the C interface you used to work with pointers here it’s no longer the case. In the C++<br>interface we have mostly <em>Mat</em> objects. These objects may be freely converted to both <em>IplImage</em> and<br><em>CvMat</em> with simple assignment. For example:<br>@code{.cpp}<br>Mat I;<br>IplImage pI &#x3D; I;<br>CvMat    mI &#x3D; I;<br>@endcode<br>Now if you want pointers the conversion gets just a little more complicated. The compilers can no<br>longer automatically determinate what you want and as you need to explicitly specify your goal. This<br>is to call the <em>IplImage</em> and <em>CvMat</em> operators and then get their pointers. For getting the pointer<br>we use the &amp; sign:<br>@code{.cpp}<br>Mat I;<br>IplImage* pI     &#x3D; &amp;I.operator IplImage();<br>CvMat* mI        &#x3D;  &amp;I.operator CvMat();<br>@endcode<br>One of the biggest complaints of the C interface is that it leaves all the memory management to you.<br>You need to figure out when it is safe to release your unused objects and make sure you do so before<br>the program finishes or you could have troublesome memory leaks. To work around this issue in OpenCV<br>there is introduced a sort of smart pointer. This will automatically release the object when it’s no<br>longer in use. To use this declare the pointers as a specialization of the <em>Ptr</em> :<br>@code{.cpp}<br>Ptr<IplImage> piI &#x3D; &amp;I.operator IplImage();<br>@endcode<br>Converting from the C data structures to the <em>Mat</em> is done by passing these inside its constructor.<br>For example:<br>@code{.cpp}<br>Mat K(piL), L;<br>L &#x3D; Mat(pI);<br>@endcode</p>
<h2 id="A-case-study"><a href="#A-case-study" class="headerlink" title="A case study"></a>A case study</h2><p>Now that you have the basics done <a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/core/interoperability_with_OpenCV_1/interoperability_with_OpenCV_1.cpp">here’s</a><br>an example that mixes the usage of the C interface with the C++ one. You will also find it in the<br>sample directory of the OpenCV source code library at the<br><code>samples/cpp/tutorial_code/core/interoperability_with_OpenCV_1/interoperability_with_OpenCV_1.cpp</code> .<br>To further help on seeing the difference the programs supports two modes: one mixed C and C++ and<br>one pure C++. If you define the <em>DEMO_MIXED_API_USE</em> you’ll end up using the first. The program<br>separates the color planes, does some modifications on them and in the end merge them back together.</p>
<p>@snippet interoperability_with_OpenCV_1.cpp head<br>@snippet interoperability_with_OpenCV_1.cpp start</p>
<p>Here you can observe that with the new structure we have no pointer problems, although it is<br>possible to use the old functions and in the end just transform the result to a <em>Mat</em> object.</p>
<p>@snippet interoperability_with_OpenCV_1.cpp new</p>
<p>Because, we want to mess around with the images luma component we first convert from the default BGR<br>to the YUV color space and then split the result up into separate planes. Here the program splits:<br>in the first example it processes each plane using one of the three major image scanning algorithms<br>in OpenCV (C [] operator, iterator, individual element access). In a second variant we add to the<br>image some Gaussian noise and then mix together the channels according to some formula.</p>
<p>The scanning version looks like:</p>
<p>@snippet interoperability_with_OpenCV_1.cpp scanning</p>
<p>Here you can observe that we may go through all the pixels of an image in three fashions: an<br>iterator, a C pointer and an individual element access style. You can read a more in-depth<br>description of these in the @ref tutorial_how_to_scan_images tutorial. Converting from the old function<br>names is easy. Just remove the cv prefix and use the new <em>Mat</em> data structure. Here’s an example of<br>this by using the weighted addition function:</p>
<p>@snippet interoperability_with_OpenCV_1.cpp noisy</p>
<p>As you may observe the <em>planes</em> variable is of type <em>Mat</em>. However, converting from <em>Mat</em> to<br><em>IplImage</em> is easy and made automatically with a simple assignment operator.</p>
<p>@snippet interoperability_with_OpenCV_1.cpp end</p>
<p>The new <em>imshow</em> highgui function accepts both the <em>Mat</em> and <em>IplImage</em> data structures. Compile and<br>run the program and if the first image below is your input you may get either the first or second as<br>output:</p>
<p><img src="/images/outputInteropOpenCV1.jpg"></p>
<p>You may observe a runtime instance of this on the <a href="https://www.youtube.com/watch?v=qckm-zvo31w">YouTube<br>here</a> and you can <a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/core/interoperability_with_OpenCV_1/interoperability_with_OpenCV_1.cpp">download the source code from here
</a><br>or find it in the<br><code>samples/cpp/tutorial_code/core/interoperability_with_OpenCV_1/interoperability_with_OpenCV_1.cpp</code><br>of the OpenCV source code library.</p>
<p>@youtube{qckm-zvo31w}</p>
