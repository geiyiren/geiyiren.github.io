<h1 id="Mask-operations-on-matrices-tutorial-mat-mask-operations"><a href="#Mask-operations-on-matrices-tutorial-mat-mask-operations" class="headerlink" title="Mask operations on matrices {#tutorial_mat_mask_operations}"></a>Mask operations on matrices {#tutorial_mat_mask_operations}</h1><p>@prev_tutorial{tutorial_how_to_scan_images}<br>@next_tutorial{tutorial_mat_operations}</p>
<p>Mask operations on matrices are quite simple. The idea is that we recalculate each pixel’s value in<br>an image according to a mask matrix (also known as kernel). This mask holds values that will adjust<br>how much influence neighboring pixels (and the current pixel) have on the new pixel value. From a<br>mathematical point of view we make a weighted average, with our specified values.</p>
<h2 id="Our-test-case"><a href="#Our-test-case" class="headerlink" title="Our test case"></a>Our test case</h2><p>Let’s consider the issue of an image contrast enhancement method. Basically we want to apply for<br>every pixel of the image the following formula:</p>
<p>\f[I(i,j) &#x3D; 5*I(i,j) - [ I(i-1,j) + I(i+1,j) + I(i,j-1) + I(i,j+1)]\f]\f[\iff I(i,j)*M, \text{where }<br>M &#x3D; \bordermatrix{ _i\backslash ^j  &amp; -1 &amp;  0 &amp; +1 \cr<br>                     -1 &amp;  0 &amp; -1 &amp;  0 \cr<br>                      0 &amp; -1 &amp;  5 &amp; -1 \cr<br>                     +1 &amp;  0 &amp; -1 &amp;  0 \cr<br>                 }\f]</p>
<p>The first notation is by using a formula, while the second is a compacted version of the first by<br>using a mask. You use the mask by putting the center of the mask matrix (in the upper case noted by<br>the zero-zero index) on the pixel you want to calculate and sum up the pixel values multiplied with<br>the overlapped matrix values. It’s the same thing, however in case of large matrices the latter<br>notation is a lot easier to look over.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>@add_toggle_cpp<br>You can download this source code from <a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/cpp/tutorial_code/core/mat_mask_operations/mat_mask_operations.cpp">here
</a> or look in the<br>OpenCV source code libraries sample directory at<br><code>samples/cpp/tutorial_code/core/mat_mask_operations/mat_mask_operations.cpp</code>.<br>@include samples&#x2F;cpp&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.cpp<br>@end_toggle</p>
<p>@add_toggle_java<br>You can download this source code from <a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/java/tutorial_code/core/mat_mask_operations/MatMaskOperations.java">here
</a> or look in the<br>OpenCV source code libraries sample directory at<br><code>samples/java/tutorial_code/core/mat_mask_operations/MatMaskOperations.java</code>.<br>@include samples&#x2F;java&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;MatMaskOperations.java<br>@end_toggle</p>
<p>@add_toggle_python<br>You can download this source code from <a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/python/tutorial_code/core/mat_mask_operations/mat_mask_operations.py">here
</a> or look in the<br>OpenCV source code libraries sample directory at<br><code>samples/python/tutorial_code/core/mat_mask_operations/mat_mask_operations.py</code>.<br>@include samples&#x2F;python&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.py<br>@end_toggle</p>
<h2 id="The-Basic-Method"><a href="#The-Basic-Method" class="headerlink" title="The Basic Method"></a>The Basic Method</h2><p>Now let us see how we can make this happen by using the basic pixel access method or by using the<br><strong>filter2D()</strong> function.</p>
<p>Here’s a function that will do this:<br>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.cpp basic_method</p>
<p>At first we make sure that the input images data is in unsigned char format. For this we use the<br>@ref cv::CV_Assert function that throws an error when the expression inside it is false.<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.cpp 8_bit<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;MatMaskOperations.java basic_method</p>
<p>At first we make sure that the input images data in unsigned 8 bit format.<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;MatMaskOperations.java 8_bit<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.py basic_method</p>
<p>At first we make sure that the input images data in unsigned 8 bit format.<br>@code{.py}<br>my_image &#x3D; cv.cvtColor(my_image, cv.CV_8U)<br>@endcode</p>
<p>@end_toggle</p>
<p>We create an output image with the same size and the same type as our input. As you can see in the<br>@ref tutorial_how_to_scan_images_storing “storing” section, depending on the number of channels we may have one or more<br>subcolumns.</p>
<p>@add_toggle_cpp<br>We will iterate through them via pointers so the total number of elements depends on<br>this number.<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.cpp create_channels<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;MatMaskOperations.java create_channels<br>@end_toggle</p>
<p>@add_toggle_python<br>@code{.py}<br>height, width, n_channels &#x3D; my_image.shape<br>result &#x3D; np.zeros(my_image.shape, my_image.dtype)<br>@endcode<br>@end_toggle</p>
<p>@add_toggle_cpp<br>We’ll use the plain C [] operator to access pixels. Because we need to access multiple rows at the<br>same time we’ll acquire the pointers for each of them (a previous, a current and a next line). We<br>need another pointer to where we’re going to save the calculation. Then simply access the right<br>items with the [] operator. For moving the output pointer ahead we simply increase this (with one<br>byte) after each operation:<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.cpp basic_method_loop</p>
<p>On the borders of the image the upper notation results inexistent pixel locations (like minus one -<br>minus one). In these points our formula is undefined. A simple solution is to not apply the kernel<br>in these points and, for example, set the pixels on the borders to zeros:</p>
<p>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.cpp borders<br>@end_toggle</p>
<p>@add_toggle_java<br>We need to access multiple rows and columns which can be done by adding or subtracting 1 to the current center (i,j).<br>Then we apply the sum and put the new value in the Result matrix.<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;MatMaskOperations.java basic_method_loop</p>
<p>On the borders of the image the upper notation results in inexistent pixel locations (like (-1,-1)).<br>In these points our formula is undefined. A simple solution is to not apply the kernel<br>in these points and, for example, set the pixels on the borders to zeros:</p>
<p>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;MatMaskOperations.java borders<br>@end_toggle</p>
<p>@add_toggle_python<br>We need to access multiple rows and columns which can be done by adding or subtracting 1 to the current center (i,j).<br>Then we apply the sum and put the new value in the Result matrix.<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.py basic_method_loop<br>@end_toggle</p>
<h2 id="The-filter2D-function"><a href="#The-filter2D-function" class="headerlink" title="The filter2D function"></a>The filter2D function</h2><p>Applying such filters are so common in image processing that in OpenCV there is a function that<br>will take care of applying the mask (also called a kernel in some places). For this you first need<br>to define an object that holds the mask:</p>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.cpp kern<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;MatMaskOperations.java kern<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.py kern<br>@end_toggle</p>
<p>Then call the <strong>filter2D()</strong> function specifying the input, the output image and the kernel to<br>use:</p>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.cpp filter2D<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;MatMaskOperations.java filter2D<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;core&#x2F;mat_mask_operations&#x2F;mat_mask_operations.py filter2D<br>@end_toggle</p>
<p>The function even has a fifth optional argument to specify the center of the kernel, a sixth<br>for adding an optional value to the filtered pixels before storing them in K and a seventh one<br>for determining what to do in the regions where the operation is undefined (borders).</p>
<p>This function is shorter, less verbose and, because there are some optimizations, it is usually faster<br>than the <em>hand-coded method</em>. For example in my test while the second one took only 13<br>milliseconds the first took around 31 milliseconds. Quite some difference.</p>
<p>For example:</p>
<p><img src="/images/resultMatMaskFilter2D.png"></p>
<p>@add_toggle_cpp<br>Check out an instance of running the program on our <a href="http://www.youtube.com/watch?v=7PF1tAU9se4">YouTube<br>channel</a> .<br>@youtube{7PF1tAU9se4}<br>@end_toggle</p>
