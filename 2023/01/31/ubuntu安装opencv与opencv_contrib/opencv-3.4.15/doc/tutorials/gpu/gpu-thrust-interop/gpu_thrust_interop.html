<h1 id="Using-a-cv-cuda-GpuMat-with-thrust-tutorial-gpu-thrust-interop"><a href="#Using-a-cv-cuda-GpuMat-with-thrust-tutorial-gpu-thrust-interop" class="headerlink" title="Using a cv::cuda::GpuMat with thrust {#tutorial_gpu_thrust_interop}"></a>Using a cv::cuda::GpuMat with thrust {#tutorial_gpu_thrust_interop}</h1><p>@prev_tutorial{tutorial_gpu_basics_similarity}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>Thrust is an extremely powerful library for various cuda accelerated algorithms.  However thrust is designed<br>to work with vectors and not pitched matricies.  The following tutorial will discuss wrapping cv::cuda::GpuMat’s<br>into thrust iterators that can be used with thrust algorithms.</p>
<p>This tutorial should show you how to:</p>
<ul>
<li>Wrap a GpuMat into a thrust iterator</li>
<li>Fill a GpuMat with random numbers</li>
<li>Sort a column of a GpuMat in place</li>
<li>Copy values greater than 0 to a new gpu matrix</li>
<li>Use streams with thrust</li>
</ul>
<h2 id="Wrapping-a-GpuMat-into-a-thrust-iterator"><a href="#Wrapping-a-GpuMat-into-a-thrust-iterator" class="headerlink" title="Wrapping a GpuMat into a thrust iterator"></a>Wrapping a GpuMat into a thrust iterator</h2><p>The following code will produce an iterator for a GpuMat</p>
<p>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;gpu&#x2F;gpu-thrust-interop&#x2F;Thrust_interop.hpp begin_itr<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;gpu&#x2F;gpu-thrust-interop&#x2F;Thrust_interop.hpp end_itr</p>
<p>Our goal is to have an iterator that will start at the beginning of the matrix, and increment correctly to access continuous matrix elements.  This is trivial for a continuous row, but how about for a column of a pitched matrix?  To do this we need the iterator to be aware of the matrix dimensions and step.  This information is embedded in the step_functor.<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;gpu&#x2F;gpu-thrust-interop&#x2F;Thrust_interop.hpp step_functor<br>The step functor takes in an index value and returns the appropriate<br>offset from the beginning of the matrix.  The counting iterator simply increments over the range of pixel elements.  Combined into the transform_iterator we have an iterator that counts from 0 to M*N and correctly<br>increments to account for the pitched memory of a GpuMat.  Unfortunately this does not include any memory location information, for that we need a thrust::device_ptr.  By combining a device pointer with the transform_iterator we can point thrust to the first element of our matrix and have it step accordingly.</p>
<h2 id="Fill-a-GpuMat-with-random-numbers"><a href="#Fill-a-GpuMat-with-random-numbers" class="headerlink" title="Fill a GpuMat with random numbers"></a>Fill a GpuMat with random numbers</h2><p>Now that we have some nice functions for making iterators for thrust, lets use them to do some things OpenCV can’t do.  Unfortunately at the time of this writing, OpenCV doesn’t have any Gpu random number generation.<br>Thankfully thrust does and it’s now trivial to interop between the two.<br>Example taken from <a href="http://stackoverflow.com/questions/12614164/generating-a-random-number-vector-between-0-and-1-0-using-thrust">http://stackoverflow.com/questions/12614164/generating-a-random-number-vector-between-0-and-1-0-using-thrust</a></p>
<p>First we need to write a functor that will produce our random values.<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;gpu&#x2F;gpu-thrust-interop&#x2F;main.cu prg</p>
<p>This will take in an integer value and output a value between a and b.<br>Now we will populate our matrix with values between 0 and 10 with a thrust transform.<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;gpu&#x2F;gpu-thrust-interop&#x2F;main.cu random</p>
<h2 id="Sort-a-column-of-a-GpuMat-in-place"><a href="#Sort-a-column-of-a-GpuMat-in-place" class="headerlink" title="Sort a column of a GpuMat in place"></a>Sort a column of a GpuMat in place</h2><p>Lets fill matrix elements with random values and an index.  Afterwards we will sort the random numbers and the indecies.<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;gpu&#x2F;gpu-thrust-interop&#x2F;main.cu sort</p>
<h2 id="Copy-values-greater-than-0-to-a-new-gpu-matrix-while-using-streams"><a href="#Copy-values-greater-than-0-to-a-new-gpu-matrix-while-using-streams" class="headerlink" title="Copy values greater than 0 to a new gpu matrix while using streams"></a>Copy values greater than 0 to a new gpu matrix while using streams</h2><p>In this example we’re going to see how cv::cuda::Streams can be used with thrust.  Unfortunately this specific example uses functions that must return results to the CPU so it isn’t the optimal use of streams.</p>
<p>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;gpu&#x2F;gpu-thrust-interop&#x2F;main.cu copy_greater</p>
<p>First we will populate a GPU mat with randomly generated data between -1 and 1 on a stream.</p>
<p>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;gpu&#x2F;gpu-thrust-interop&#x2F;main.cu random_gen_stream</p>
<p>Notice the use of thrust::system::cuda::par.on(…), this creates an execution policy for executing thrust code on a stream.<br>There is a bug in the version of thrust distributed with the cuda toolkit, as of version 7.5 this has not been fixed.  This bug causes code to not execute on streams.<br>The bug can however be fixed by using the newest version of thrust from the git repository. (<a href="http://github.com/thrust/thrust.git">http://github.com/thrust/thrust.git</a>)<br>Next we will determine how many values are greater than 0 by using thrust::count_if with the following predicate:</p>
<p>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;gpu&#x2F;gpu-thrust-interop&#x2F;main.cu pred_greater</p>
<p>We will use those results to create an output buffer for storing the copied values, we will then use copy_if with the same predicate to populate the output buffer.<br>Lastly we will download the values into a CPU mat for viewing.</p>
