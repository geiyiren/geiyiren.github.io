<h1 id="Smoothing-Images-tutorial-gausian-median-blur-bilateral-filter"><a href="#Smoothing-Images-tutorial-gausian-median-blur-bilateral-filter" class="headerlink" title="Smoothing Images {#tutorial_gausian_median_blur_bilateral_filter}"></a>Smoothing Images {#tutorial_gausian_median_blur_bilateral_filter}</h1><p>@prev_tutorial{tutorial_random_generator_and_text}<br>@next_tutorial{tutorial_erosion_dilatation}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this tutorial you will learn how to apply diverse linear filters to smooth images using OpenCV<br>functions such as:</p>
<ul>
<li><strong>blur()</strong></li>
<li><strong>GaussianBlur()</strong></li>
<li><strong>medianBlur()</strong></li>
<li><strong>bilateralFilter()</strong></li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>@note The explanation below belongs to the book <a href="http://szeliski.org/Book/">Computer Vision: Algorithms and<br>Applications</a> by Richard Szeliski and to <em>LearningOpenCV</em></p>
<ul>
<li><p><em>Smoothing</em>, also called <em>blurring</em>, is a simple and frequently used image processing<br>operation.</p>
</li>
<li><p>There are many reasons for smoothing. In this tutorial we will focus on smoothing in order to<br>reduce noise (other uses will be seen in the following tutorials).</p>
</li>
<li><p>To perform a smoothing operation we will apply a <em>filter</em> to our image. The most common type<br>of filters are <em>linear</em>, in which an output pixel’s value (i.e. \f$g(i,j)\f$) is determined as a<br>weighted sum of input pixel values (i.e. \f$f(i+k,j+l)\f$) :</p>
<p>\f[g(i,j) &#x3D; \sum_{k,l} f(i+k, j+l) h(k,l)\f]</p>
<p>\f$h(k,l)\f$ is called the <em>kernel</em>, which is nothing more than the coefficients of the filter.</p>
<p>It helps to visualize a <em>filter</em> as a window of coefficients sliding across the image.</p>
</li>
<li><p>There are many kind of filters, here we will mention the most used:</p>
</li>
</ul>
<h3 id="Normalized-Box-Filter"><a href="#Normalized-Box-Filter" class="headerlink" title="Normalized Box Filter"></a>Normalized Box Filter</h3><ul>
<li><p>This filter is the simplest of all! Each output pixel is the <em>mean</em> of its kernel neighbors (<br>all of them contribute with equal weights)</p>
</li>
<li><p>The kernel is below:</p>
<p>\f[K &#x3D; \dfrac{1}{K_{width} \cdot K_{height}} \begin{bmatrix}<br>1 &amp; 1 &amp; 1 &amp; … &amp; 1 \<br>1 &amp; 1 &amp; 1 &amp; … &amp; 1 \<br>. &amp; . &amp; . &amp; … &amp; 1 \<br>. &amp; . &amp; . &amp; … &amp; 1 \<br>1 &amp; 1 &amp; 1 &amp; … &amp; 1<br>   \end{bmatrix}\f]</p>
</li>
</ul>
<h3 id="Gaussian-Filter"><a href="#Gaussian-Filter" class="headerlink" title="Gaussian Filter"></a>Gaussian Filter</h3><ul>
<li><p>Probably the most useful filter (although not the fastest). Gaussian filtering is done by<br>convolving each point in the input array with a <em>Gaussian kernel</em> and then summing them all to<br>produce the output array.</p>
</li>
<li><p>Just to make the picture clearer, remember how a 1D Gaussian kernel look like?</p>
<p><img src="/images/Smoothing_Tutorial_theory_gaussian_0.jpg"></p>
<p>Assuming that an image is 1D, you can notice that the pixel located in the middle would have the<br>biggest weight. The weight of its neighbors decreases as the spatial distance between them and<br>the center pixel increases.</p>
<p>@note<br>Remember that a 2D Gaussian can be represented as :<br>\f[G_{0}(x, y) &#x3D; A  e^{ \dfrac{ -(x - \mu_{x})^{2} }{ 2\sigma^{2}<em>{x} } +  \dfrac{ -(y - \mu</em>{y})^{2} }{ 2\sigma^{2}_{y} } }\f]<br>where \f$\mu\f$ is the mean (the peak) and \f$\sigma^{2}\f$ represents the variance (per each of the<br>variables \f$x\f$ and \f$y\f$)</p>
</li>
</ul>
<h3 id="Median-Filter"><a href="#Median-Filter" class="headerlink" title="Median Filter"></a>Median Filter</h3><p>The median filter run through each element of the signal (in this case the image) and replace each<br>pixel with the <strong>median</strong> of its neighboring pixels (located in a square neighborhood around the<br>evaluated pixel).</p>
<h3 id="Bilateral-Filter"><a href="#Bilateral-Filter" class="headerlink" title="Bilateral Filter"></a>Bilateral Filter</h3><ul>
<li>So far, we have explained some filters which main goal is to <em>smooth</em> an input image. However,<br>sometimes the filters do not only dissolve the noise, but also smooth away the <em>edges</em>. To avoid<br>this (at certain extent at least), we can use a bilateral filter.</li>
<li>In an analogous way as the Gaussian filter, the bilateral filter also considers the neighboring<br>pixels with weights assigned to each of them. These weights have two components, the first of<br>which is the same weighting used by the Gaussian filter. The second component takes into account<br>the difference in intensity between the neighboring pixels and the evaluated one.</li>
<li>For a more detailed explanation you can check <a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html">this<br>link</a></li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><ul>
<li><strong>What does this program do?</strong><ul>
<li>Loads an image</li>
<li>Applies 4 different kinds of filters (explained in Theory) and show the filtered images<br>sequentially</li>
</ul>
</li>
</ul>
<p>@add_toggle_cpp</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/cpp/tutorial_code/ImgProc/Smoothing/Smoothing.cpp">here</a></p>
</li>
<li><p><strong>Code at glance:</strong><br>@include samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Smoothing&#x2F;Smoothing.cpp<br>@end_toggle</p>
</li>
</ul>
<p>@add_toggle_java</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/java/tutorial_code/ImgProc/Smoothing/Smoothing.java">here</a></p>
</li>
<li><p><strong>Code at glance:</strong><br>@include samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Smoothing&#x2F;Smoothing.java<br>@end_toggle</p>
</li>
</ul>
<p>@add_toggle_python</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/python/tutorial_code/imgProc/Smoothing/smoothing.py">here</a></p>
</li>
<li><p><strong>Code at glance:</strong><br>@include samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Smoothing&#x2F;smoothing.py<br>@end_toggle</p>
</li>
</ul>
<h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><p>Let’s check the OpenCV functions that involve only the smoothing procedure, since the rest is<br>already known by now.</p>
<h4 id="Normalized-Block-Filter"><a href="#Normalized-Block-Filter" class="headerlink" title="Normalized Block Filter:"></a>Normalized Block Filter:</h4><ul>
<li>OpenCV offers the function <strong>blur()</strong> to perform smoothing with this filter.<br>We specify 4 arguments (more details, check the Reference):<ul>
<li><em>src</em>: Source image</li>
<li><em>dst</em>: Destination image</li>
<li><em>Size( w, h )</em>: Defines the size of the kernel to be used ( of width <em>w</em> pixels and height<br><em>h</em> pixels)</li>
<li><em>Point(-1, -1)</em>: Indicates where the anchor point (the pixel evaluated) is located with<br>respect to the neighborhood. If there is a negative value, then the center of the kernel is<br>considered the anchor point.</li>
</ul>
</li>
</ul>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Smoothing&#x2F;Smoothing.cpp blur<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Smoothing&#x2F;Smoothing.java blur<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Smoothing&#x2F;smoothing.py blur<br>@end_toggle</p>
<h4 id="Gaussian-Filter-1"><a href="#Gaussian-Filter-1" class="headerlink" title="Gaussian Filter:"></a>Gaussian Filter:</h4><ul>
<li>It is performed by the function <strong>GaussianBlur()</strong> :<br>Here we use 4 arguments (more details, check the OpenCV reference):<ul>
<li><em>src</em>: Source image</li>
<li><em>dst</em>: Destination image</li>
<li><em>Size(w, h)</em>: The size of the kernel to be used (the neighbors to be considered). \f$w\f$ and<br>\f$h\f$ have to be odd and positive numbers otherwise the size will be calculated using the<br>\f$\sigma_{x}\f$ and \f$\sigma_{y}\f$ arguments.</li>
<li>\f$\sigma_{x}\f$: The standard deviation in x. Writing \f$0\f$ implies that \f$\sigma_{x}\f$ is<br>calculated using kernel size.</li>
<li>\f$\sigma_{y}\f$: The standard deviation in y. Writing \f$0\f$ implies that \f$\sigma_{y}\f$ is<br>calculated using kernel size.</li>
</ul>
</li>
</ul>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Smoothing&#x2F;Smoothing.cpp gaussianblur<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Smoothing&#x2F;Smoothing.java gaussianblur<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Smoothing&#x2F;smoothing.py gaussianblur<br>@end_toggle</p>
<h4 id="Median-Filter-1"><a href="#Median-Filter-1" class="headerlink" title="Median Filter:"></a>Median Filter:</h4><ul>
<li>This filter is provided by the <strong>medianBlur()</strong> function:<br>We use three arguments:<ul>
<li><em>src</em>: Source image</li>
<li><em>dst</em>: Destination image, must be the same type as <em>src</em></li>
<li><em>i</em>: Size of the kernel (only one because we use a square window). Must be odd.</li>
</ul>
</li>
</ul>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Smoothing&#x2F;Smoothing.cpp medianblur<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Smoothing&#x2F;Smoothing.java medianblur<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Smoothing&#x2F;smoothing.py medianblur<br>@end_toggle</p>
<h4 id="Bilateral-Filter-1"><a href="#Bilateral-Filter-1" class="headerlink" title="Bilateral Filter"></a>Bilateral Filter</h4><ul>
<li>Provided by OpenCV function <strong>bilateralFilter()</strong><br>We use 5 arguments:<ul>
<li><em>src</em>: Source image</li>
<li><em>dst</em>: Destination image</li>
<li><em>d</em>: The diameter of each pixel neighborhood.</li>
<li>\f$\sigma_{Color}\f$: Standard deviation in the color space.</li>
<li>\f$\sigma_{Space}\f$: Standard deviation in the coordinate space (in pixel terms)</li>
</ul>
</li>
</ul>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Smoothing&#x2F;Smoothing.cpp bilateralfilter<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Smoothing&#x2F;Smoothing.java bilateralfilter<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Smoothing&#x2F;smoothing.py bilateralfilter<br>@end_toggle</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><ul>
<li><p>The code opens an image (in this case <a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/data/lena.jpg">lena.jpg</a>)<br>and display it under the effects of the 4 filters explained.</p>
</li>
<li><p>Here is a snapshot of the image smoothed using <em>medianBlur</em>:</p>
<p><img src="/images/Smoothing_Tutorial_Result_Median_Filter.jpg"></p>
</li>
</ul>
