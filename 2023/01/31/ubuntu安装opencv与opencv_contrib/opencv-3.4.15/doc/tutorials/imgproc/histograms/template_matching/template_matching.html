<h1 id="Template-Matching-tutorial-template-matching"><a href="#Template-Matching-tutorial-template-matching" class="headerlink" title="Template Matching {#tutorial_template_matching}"></a>Template Matching {#tutorial_template_matching}</h1><p>@prev_tutorial{tutorial_back_projection}<br>@next_tutorial{tutorial_find_contours}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this tutorial you will learn how to:</p>
<ul>
<li>Use the OpenCV function <strong>matchTemplate()</strong> to search for matches between an image patch and<br>an input image</li>
<li>Use the OpenCV function <strong>minMaxLoc()</strong> to find the maximum and minimum values (as well as<br>their positions) in a given array.</li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><h3 id="What-is-template-matching"><a href="#What-is-template-matching" class="headerlink" title="What is template matching?"></a>What is template matching?</h3><p>Template matching is a technique for finding areas of an image that match (are similar) to a<br>template image (patch).</p>
<p>While the patch must be a rectangle it may be that not all of the<br>rectangle is relevant.  In such a case, a mask can be used to isolate the portion of the patch<br>that should be used to find the match.</p>
<h3 id="How-does-it-work"><a href="#How-does-it-work" class="headerlink" title="How does it work?"></a>How does it work?</h3><ul>
<li><p>We need two primary components:</p>
<p>-#  <strong>Source image (I):</strong> The image in which we expect to find a match to the template image<br>-#  <strong>Template image (T):</strong> The patch image which will be compared to the source image</p>
<p>our goal is to detect the highest matching area:</p>
<p><img src="/images/Template_Matching_Template_Theory_Summary.jpg"></p>
</li>
<li><p>To identify the matching area, we have to <em>compare</em> the template image against the source image<br>by sliding it:</p>
<p><img src="/images/Template_Matching_Template_Theory_Sliding.jpg"></p>
</li>
<li><p>By <strong>sliding</strong>, we mean moving the patch one pixel at a time (left to right, up to down). At<br>each location, a metric is calculated so it represents how “good” or “bad” the match at that<br>location is (or how similar the patch is to that particular area of the source image).</p>
</li>
<li><p>For each location of <strong>T</strong> over <strong>I</strong>, you <em>store</em> the metric in the <em>result matrix</em> <strong>R</strong>.<br>Each location \f$(x,y)\f$ in <strong>R</strong> contains the match metric:</p>
<p><img src="/images/Template_Matching_Template_Theory_Result.jpg"></p>
<p>the image above is the result <strong>R</strong> of sliding the patch with a metric <strong>TM_CCORR_NORMED</strong>.<br>The brightest locations indicate the highest matches. As you can see, the location marked by the<br>red circle is probably the one with the highest value, so that location (the rectangle formed by<br>that point as a corner and width and height equal to the patch image) is considered the match.</p>
</li>
<li><p>In practice, we locate the highest value (or lower, depending of the type of matching method) in<br>the <em>R</em> matrix, using the function <strong>minMaxLoc()</strong></p>
</li>
</ul>
<h3 id="How-does-the-mask-work"><a href="#How-does-the-mask-work" class="headerlink" title="How does the mask work?"></a>How does the mask work?</h3><ul>
<li><p>If masking is needed for the match, three components are required:</p>
<p>  -#  <strong>Source image (I):</strong> The image in which we expect to find a match to the template image<br>  -#  <strong>Template image (T):</strong> The patch image which will be compared to the source image<br>  -#  <strong>Mask image (M):</strong> The mask, a grayscale image that masks the template</p>
</li>
<li><p>Only two matching methods currently accept a mask: TM_SQDIFF and TM_CCORR_NORMED (see<br>below for explanation of all the matching methods available in opencv).</p>
</li>
<li><p>The mask must have the same dimensions as the template</p>
</li>
<li><p>The mask should have a CV_8U or CV_32F depth and the same number of channels<br>as the template image. In CV_8U case, the mask values are treated as binary,<br>i.e. zero and non-zero. In CV_32F case, the values should fall into [0..1]<br>range and the template pixels will be multiplied by the corresponding mask pixel<br>values. Since the input images in the sample have the CV_8UC3 type, the mask<br>is also read as color image.</p>
<p><img src="/images/Template_Matching_Mask_Example.jpg"></p>
</li>
</ul>
<h3 id="Which-are-the-matching-methods-available-in-OpenCV"><a href="#Which-are-the-matching-methods-available-in-OpenCV" class="headerlink" title="Which are the matching methods available in OpenCV?"></a>Which are the matching methods available in OpenCV?</h3><p>Good question. OpenCV implements Template matching in the function <strong>matchTemplate()</strong>. The<br>available methods are 6:</p>
<p>-#  <strong>method&#x3D;TM_SQDIFF</strong></p>
<pre><code>\f[R(x,y)= \sum _{x&#39;,y&#39;} (T(x&#39;,y&#39;)-I(x+x&#39;,y+y&#39;))^2\f]
</code></pre>
<p>-#  <strong>method&#x3D;TM_SQDIFF_NORMED</strong></p>
<pre><code>\f[R(x,y)= \frac{\sum_{x&#39;,y&#39;} (T(x&#39;,y&#39;)-I(x+x&#39;,y+y&#39;))^2}{\sqrt{\sum_{x&#39;,y&#39;}T(x&#39;,y&#39;)^2 \cdot \sum_{x&#39;,y&#39;} I(x+x&#39;,y+y&#39;)^2}}\f]
</code></pre>
<p>-#  <strong>method&#x3D;TM_CCORR</strong></p>
<pre><code>\f[R(x,y)= \sum _{x&#39;,y&#39;} (T(x&#39;,y&#39;)  \cdot I(x+x&#39;,y+y&#39;))\f]
</code></pre>
<p>-#  <strong>method&#x3D;TM_CCORR_NORMED</strong></p>
<pre><code>\f[R(x,y)= \frac{\sum_{x&#39;,y&#39;} (T(x&#39;,y&#39;) \cdot I(x+x&#39;,y+y&#39;))}{\sqrt{\sum_{x&#39;,y&#39;}T(x&#39;,y&#39;)^2 \cdot \sum_{x&#39;,y&#39;} I(x+x&#39;,y+y&#39;)^2}}\f]
</code></pre>
<p>-#  <strong>method&#x3D;TM_CCOEFF</strong></p>
<pre><code>\f[R(x,y)= \sum _{x&#39;,y&#39;} (T&#39;(x&#39;,y&#39;)  \cdot I&#39;(x+x&#39;,y+y&#39;))\f]

where

\f[\begin{array}{l} T&#39;(x&#39;,y&#39;)=T(x&#39;,y&#39;) - 1/(w  \cdot h)  \cdot \sum _{x&#39;&#39;,y&#39;&#39;} T(x&#39;&#39;,y&#39;&#39;) \\ I&#39;(x+x&#39;,y+y&#39;)=I(x+x&#39;,y+y&#39;) - 1/(w  \cdot h)  \cdot \sum _{x&#39;&#39;,y&#39;&#39;} I(x+x&#39;&#39;,y+y&#39;&#39;) \end{array}\f]
</code></pre>
<p>-#  <strong>method&#x3D;TM_CCOEFF_NORMED</strong></p>
<pre><code>\f[R(x,y)= \frac{ \sum_{x&#39;,y&#39;} (T&#39;(x&#39;,y&#39;) \cdot I&#39;(x+x&#39;,y+y&#39;)) }{ \sqrt{\sum_{x&#39;,y&#39;}T&#39;(x&#39;,y&#39;)^2 \cdot \sum_{x&#39;,y&#39;} I&#39;(x+x&#39;,y+y&#39;)^2} }\f]
</code></pre>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><ul>
<li><strong>What does this program do?</strong><ul>
<li>Loads an input image, an image patch (<em>template</em>), and optionally a mask</li>
<li>Perform a template matching procedure by using the OpenCV function <strong>matchTemplate()</strong><br>with any of the 6 matching methods described before. The user can choose the method by<br>entering its selection in the Trackbar.  If a mask is supplied, it will only be used for<br>the methods that support masking</li>
<li>Normalize the output of the matching procedure</li>
<li>Localize the location with higher matching probability</li>
<li>Draw a rectangle around the area corresponding to the highest match</li>
</ul>
</li>
</ul>
<p>@add_toggle_cpp</p>
<ul>
<li><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/Histograms_Matching/MatchTemplate_Demo.cpp">here</a></li>
<li><strong>Code at glance:</strong><br>@include samples&#x2F;cpp&#x2F;tutorial_code&#x2F;Histograms_Matching&#x2F;MatchTemplate_Demo.cpp</li>
</ul>
<p>@end_toggle</p>
<p>@add_toggle_java</p>
<ul>
<li><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/java/tutorial_code/ImgProc/tutorial_template_matching/MatchTemplateDemo.java">here</a></li>
<li><strong>Code at glance:</strong><br>@include samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;tutorial_template_matching&#x2F;MatchTemplateDemo.java</li>
</ul>
<p>@end_toggle</p>
<p>@add_toggle_python</p>
<ul>
<li><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/python/tutorial_code/imgProc/match_template/match_template.py">here</a></li>
<li><strong>Code at glance:</strong><br>@include samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;match_template&#x2F;match_template.py</li>
</ul>
<p>@end_toggle</p>
<h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><ul>
<li><p>Declare some global variables, such as the image, template and result matrices, as well as the<br> match method and the window names:</p>
<p> @add_toggle_cpp<br> @snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;Histograms_Matching&#x2F;MatchTemplate_Demo.cpp declare<br> @end_toggle</p>
<p> @add_toggle_java<br> @snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;tutorial_template_matching&#x2F;MatchTemplateDemo.java declare<br> @end_toggle</p>
<p> @add_toggle_python<br> @snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;match_template&#x2F;match_template.py global_variables<br> @end_toggle</p>
</li>
<li><p>Load the source image, template, and optionally, if supported for the matching method, a mask:</p>
<p> @add_toggle_cpp<br> @snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;Histograms_Matching&#x2F;MatchTemplate_Demo.cpp load_image<br> @end_toggle</p>
<p> @add_toggle_java<br> @snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;tutorial_template_matching&#x2F;MatchTemplateDemo.java load_image<br> @end_toggle</p>
<p> @add_toggle_python<br> @snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;match_template&#x2F;match_template.py load_image<br> @end_toggle</p>
</li>
<li><p>Create the Trackbar to enter the kind of matching method to be used. When a change is detected<br> the callback function is called.</p>
<p> @add_toggle_cpp<br> @snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;Histograms_Matching&#x2F;MatchTemplate_Demo.cpp create_trackbar<br> @end_toggle</p>
<p> @add_toggle_java<br> @snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;tutorial_template_matching&#x2F;MatchTemplateDemo.java create_trackbar<br> @end_toggle</p>
<p> @add_toggle_python<br> @snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;match_template&#x2F;match_template.py create_trackbar<br> @end_toggle</p>
</li>
<li><p>Let’s check out the callback function. First, it makes a copy of the source image:</p>
<p> @add_toggle_cpp<br> @snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;Histograms_Matching&#x2F;MatchTemplate_Demo.cpp copy_source<br> @end_toggle</p>
<p> @add_toggle_java<br> @snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;tutorial_template_matching&#x2F;MatchTemplateDemo.java copy_source<br> @end_toggle</p>
<p> @add_toggle_python<br> @snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;match_template&#x2F;match_template.py copy_source<br> @end_toggle</p>
</li>
<li><p>Perform the template matching operation. The arguments are naturally the input image <strong>I</strong>,<br> the template <strong>T</strong>, the result <strong>R</strong> and the match_method (given by the Trackbar),<br> and optionally the mask image <strong>M</strong>.</p>
<p> @add_toggle_cpp<br> @snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;Histograms_Matching&#x2F;MatchTemplate_Demo.cpp match_template<br> @end_toggle</p>
<p> @add_toggle_java<br> @snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;tutorial_template_matching&#x2F;MatchTemplateDemo.java match_template<br> @end_toggle</p>
<p> @add_toggle_python<br> @snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;match_template&#x2F;match_template.py match_template<br> @end_toggle</p>
</li>
<li><p>We normalize the results:</p>
<p> @add_toggle_cpp<br> @snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;Histograms_Matching&#x2F;MatchTemplate_Demo.cpp normalize<br> @end_toggle</p>
<p> @add_toggle_java<br> @snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;tutorial_template_matching&#x2F;MatchTemplateDemo.java normalize<br> @end_toggle</p>
<p> @add_toggle_python<br> @snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;match_template&#x2F;match_template.py normalize<br> @end_toggle</p>
</li>
<li><p>We localize the minimum and maximum values in the result matrix <strong>R</strong> by using <strong>minMaxLoc()</strong>.</p>
<p> @add_toggle_cpp<br> @snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;Histograms_Matching&#x2F;MatchTemplate_Demo.cpp best_match<br> @end_toggle</p>
<p> @add_toggle_java<br> @snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;tutorial_template_matching&#x2F;MatchTemplateDemo.java best_match<br> @end_toggle</p>
<p> @add_toggle_python<br> @snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;match_template&#x2F;match_template.py best_match<br> @end_toggle</p>
</li>
<li><p>For the first two methods ( TM_SQDIFF and MT_SQDIFF_NORMED ) the best match are the lowest<br> values. For all the others, higher values represent better matches. So, we save the<br> corresponding value in the <strong>matchLoc</strong> variable:</p>
<p> @add_toggle_cpp<br> @snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;Histograms_Matching&#x2F;MatchTemplate_Demo.cpp match_loc<br> @end_toggle</p>
<p> @add_toggle_java<br> @snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;tutorial_template_matching&#x2F;MatchTemplateDemo.java match_loc<br> @end_toggle</p>
<p> @add_toggle_python<br> @snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;match_template&#x2F;match_template.py match_loc<br> @end_toggle</p>
</li>
<li><p>Display the source image and the result matrix. Draw a rectangle around the highest possible<br> matching area:</p>
<p> @add_toggle_cpp<br> @snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;Histograms_Matching&#x2F;MatchTemplate_Demo.cpp imshow<br> @end_toggle</p>
<p> @add_toggle_java<br> @snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;tutorial_template_matching&#x2F;MatchTemplateDemo.java imshow<br> @end_toggle</p>
<p> @add_toggle_python<br> @snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;match_template&#x2F;match_template.py imshow<br> @end_toggle</p>
</li>
</ul>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>-#  Testing our program with an input image such as:</p>
<pre><code>![](images/Template_Matching_Original_Image.jpg)

and a template image:

![](images/Template_Matching_Template_Image.jpg)
</code></pre>
<p>-#  Generate the following result matrices (first row are the standard methods SQDIFF, CCORR and<br>    CCOEFF, second row are the same methods in its normalized version). In the first column, the<br>    darkest is the better match, for the other two columns, the brighter a location, the higher the<br>    match.<br>    <img src="/images/Template_Matching_Correl_Result_0.jpg" alt="Result_0"><br>    <img src="/images/Template_Matching_Correl_Result_1.jpg" alt="Result_1"><br>    <img src="/images/Template_Matching_Correl_Result_2.jpg" alt="Result_2"><br>    <img src="/images/Template_Matching_Correl_Result_3.jpg" alt="Result_3"><br>    <img src="/images/Template_Matching_Correl_Result_4.jpg" alt="Result_4"><br>    <img src="/images/Template_Matching_Correl_Result_5.jpg" alt="Result_5"></p>
<p>-#  The right match is shown below (black rectangle around the face of the guy at the right). Notice<br>    that CCORR and CCDEFF gave erroneous best matches, however their normalized version did it<br>    right, this may be due to the fact that we are only considering the “highest match” and not the<br>    other possible high matches.</p>
<pre><code>![](images/Template_Matching_Image_Result.jpg)
</code></pre>
