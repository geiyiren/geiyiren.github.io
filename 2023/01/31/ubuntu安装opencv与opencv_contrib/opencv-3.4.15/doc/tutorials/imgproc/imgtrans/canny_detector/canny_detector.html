<h1 id="Canny-Edge-Detector-tutorial-canny-detector"><a href="#Canny-Edge-Detector-tutorial-canny-detector" class="headerlink" title="Canny Edge Detector {#tutorial_canny_detector}"></a>Canny Edge Detector {#tutorial_canny_detector}</h1><p>@prev_tutorial{tutorial_laplace_operator}<br>@next_tutorial{tutorial_hough_lines}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this tutorial you will learn how to:</p>
<ul>
<li>Use the OpenCV function @ref cv::Canny to implement the Canny Edge Detector.</li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>The <em>Canny Edge detector</em> @cite Canny86 was developed by John F. Canny in 1986. Also known to many as the<br><em>optimal detector</em>, the Canny algorithm aims to satisfy three main criteria:</p>
<ul>
<li><strong>Low error rate:</strong> Meaning a good detection of only existent edges.</li>
<li><strong>Good localization:</strong> The distance between edge pixels detected and real edge pixels have<br>to be minimized.</li>
<li><strong>Minimal response:</strong> Only one detector response per edge.</li>
</ul>
<h3 id="Steps"><a href="#Steps" class="headerlink" title="Steps"></a>Steps</h3><p>-#  Filter out any noise. The Gaussian filter is used for this purpose. An example of a Gaussian<br>    kernel of \f$size &#x3D; 5\f$ that might be used is shown below:</p>
<pre><code>\f[K = \dfrac{1}{159}\begin{bmatrix}
          2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \\
          4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \\
          5 &amp; 12 &amp; 15 &amp; 12 &amp; 5 \\
          4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \\
          2 &amp; 4 &amp; 5 &amp; 4 &amp; 2
                  \end{bmatrix}\f]
</code></pre>
<p>-#  Find the intensity gradient of the image. For this, we follow a procedure analogous to Sobel:<br>    -#  Apply a pair of convolution masks (in \f$x\f$ and \f$y\f$ directions:<br>        \f[G_{x} &#x3D; \begin{bmatrix}<br>        -1 &amp; 0 &amp; +1  \<br>        -2 &amp; 0 &amp; +2  \<br>        -1 &amp; 0 &amp; +1<br>        \end{bmatrix}\f]\f[G_{y} &#x3D; \begin{bmatrix}<br>        -1 &amp; -2 &amp; -1  \<br>        0 &amp; 0 &amp; 0  \<br>        +1 &amp; +2 &amp; +1<br>        \end{bmatrix}\f]</p>
<pre><code>-#  Find the gradient strength and direction with:
    \f[\begin{array}{l}
    G = \sqrt{ G_{x}^{2} + G_{y}^{2} } \\
    \theta = \arctan(\dfrac{ G_{y} }{ G_{x} })
    \end{array}\f]
    The direction is rounded to one of four possible angles (namely 0, 45, 90 or 135)
</code></pre>
<p>-#  <em>Non-maximum</em> suppression is applied. This removes pixels that are not considered to be part of<br>    an edge. Hence, only thin lines (candidate edges) will remain.<br>-#  <em>Hysteresis</em>: The final step. Canny does use two thresholds (upper and lower):</p>
<pre><code>-#  If a pixel gradient is higher than the *upper* threshold, the pixel is accepted as an edge
-#  If a pixel gradient value is below the *lower* threshold, then it is rejected.
-#  If the pixel gradient is between the two thresholds, then it will be accepted only if it is
    connected to a pixel that is above the *upper* threshold.

Canny recommended a *upper*:*lower* ratio between 2:1 and 3:1.
</code></pre>
<p>-#  For more details, you can always consult your favorite Computer Vision book.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>@add_toggle_cpp</p>
<ul>
<li>The tutorial code’s is shown lines below. You can also download it from<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/ImgTrans/CannyDetector_Demo.cpp">here</a><br>@include samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp<br>@end_toggle</li>
</ul>
<p>@add_toggle_java</p>
<ul>
<li>The tutorial code’s is shown lines below. You can also download it from<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/java/tutorial_code/ImgTrans/canny_detector/CannyDetectorDemo.java">here</a><br>@include samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;canny_detector&#x2F;CannyDetectorDemo.java<br>@end_toggle</li>
</ul>
<p>@add_toggle_python</p>
<ul>
<li><p>The tutorial code’s is shown lines below. You can also download it from<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/python/tutorial_code/ImgTrans/canny_detector/CannyDetector_Demo.py">here</a><br>@include samples&#x2F;python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;canny_detector&#x2F;CannyDetector_Demo.py<br>@end_toggle</p>
</li>
<li><p><strong>What does this program do?</strong></p>
<ul>
<li>Asks the user to enter a numerical value to set the lower threshold for our <em>Canny Edge<br>Detector</em> (by means of a Trackbar).</li>
<li>Applies the <em>Canny Detector</em> and generates a <strong>mask</strong> (bright lines representing the edges<br>on a black background).</li>
<li>Applies the mask obtained on the original image and display it in a window.</li>
</ul>
</li>
</ul>
<h2 id="Explanation-C-code"><a href="#Explanation-C-code" class="headerlink" title="Explanation (C++ code)"></a>Explanation (C++ code)</h2><p>-#  Create some needed variables:<br>    @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp variables</p>
<pre><code>Note the following:

-#  We establish a ratio of lower:upper threshold of 3:1 (with the variable *ratio*).
-#  We set the kernel size of \f$3\f$ (for the Sobel operations to be performed internally by the
    Canny function).
-#  We set a maximum value for the lower Threshold of \f$100\f$.
</code></pre>
<p>-#  Loads the source image:<br>    @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp load</p>
<p>-#  Create a matrix of the same type and size of <em>src</em> (to be <em>dst</em>):<br>    @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp create_mat<br>-#  Convert the image to grayscale (using the function @ref cv::cvtColor ):<br>    @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp convert_to_gray<br>-#  Create a window to display the results:<br>    @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp create_window<br>-#  Create a Trackbar for the user to enter the lower threshold for our Canny detector:<br>    @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp create_trackbar<br>    Observe the following:</p>
<pre><code>-#  The variable to be controlled by the Trackbar is *lowThreshold* with a limit of
    *max_lowThreshold* (which we set to 100 previously)
-#  Each time the Trackbar registers an action, the callback function *CannyThreshold* will be
    invoked.
</code></pre>
<p>-#  Let’s check the <em>CannyThreshold</em> function, step by step:<br>    -#  First, we blur the image with a filter of kernel size 3:<br>        @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp reduce_noise<br>    -#  Second, we apply the OpenCV function @ref cv::Canny :<br>        @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp canny<br>        where the arguments are:</p>
<pre><code>    -   *detected_edges*: Source image, grayscale
    -   *detected_edges*: Output of the detector (can be the same as the input)
    -   *lowThreshold*: The value entered by the user moving the Trackbar
    -   *highThreshold*: Set in the program as three times the lower threshold (following
        Canny&#39;s recommendation)
    -   *kernel_size*: We defined it to be 3 (the size of the Sobel kernel to be used
        internally)
</code></pre>
<p>-#  We fill a <em>dst</em> image with zeros (meaning the image is completely black).<br>    @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp fill<br>-#  Finally, we will use the function @ref cv::Mat::copyTo to map only the areas of the image that are<br>    identified as edges (on a black background).<br>    @ref cv::Mat::copyTo copy the <em>src</em> image onto <em>dst</em>. However, it will only copy the pixels in the<br>    locations where they have non-zero values. Since the output of the Canny detector is the edge<br>    contours on a black background, the resulting <em>dst</em> will be black in all the area but the<br>    detected edges.<br>    @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp copyto<br>-#  We display our result:<br>    @snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;CannyDetector_Demo.cpp display</p>
<h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><ul>
<li><p>After compiling the code above, we can run it giving as argument the path to an image. For<br>example, using as an input the following image:</p>
<p><img src="/images/Canny_Detector_Tutorial_Original_Image.jpg"></p>
</li>
<li><p>Moving the slider, trying different threshold, we obtain the following result:</p>
<p><img src="/images/Canny_Detector_Tutorial_Result.jpg"></p>
</li>
<li><p>Notice how the image is superposed to the black background on the edge regions.</p>
</li>
</ul>
