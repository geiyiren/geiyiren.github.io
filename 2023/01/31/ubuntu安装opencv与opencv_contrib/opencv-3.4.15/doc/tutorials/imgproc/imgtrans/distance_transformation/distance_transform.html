<h1 id="Image-Segmentation-with-Distance-Transform-and-Watershed-Algorithm-tutorial-distance-transform"><a href="#Image-Segmentation-with-Distance-Transform-and-Watershed-Algorithm-tutorial-distance-transform" class="headerlink" title="Image Segmentation with Distance Transform and Watershed Algorithm {#tutorial_distance_transform}"></a>Image Segmentation with Distance Transform and Watershed Algorithm {#tutorial_distance_transform}</h1><p>@prev_tutorial{tutorial_point_polygon_test}<br>@next_tutorial{tutorial_out_of_focus_deblur_filter}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this tutorial you will learn how to:</p>
<ul>
<li>Use the OpenCV function @ref cv::filter2D in order to perform some laplacian filtering for image sharpening</li>
<li>Use the OpenCV function @ref cv::distanceTransform in order to obtain the derived representation of a binary image, where the value of each pixel is replaced by its distance to the nearest background pixel</li>
<li>Use the OpenCV function @ref cv::watershed in order to isolate objects in the image from the background</li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>@add_toggle_cpp<br>This tutorial code’s is shown lines below. You can also download it from<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/ImgTrans/imageSegmentation.cpp">here</a>.<br>@include samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;imageSegmentation.cpp<br>@end_toggle</p>
<p>@add_toggle_java<br>This tutorial code’s is shown lines below. You can also download it from<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/java/tutorial_code/ImgTrans/distance_transformation/ImageSegmentationDemo.java">here</a><br>@include samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;ImageSegmentationDemo.java<br>@end_toggle</p>
<p>@add_toggle_python<br>This tutorial code’s is shown lines below. You can also download it from<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/python/tutorial_code/ImgTrans/distance_transformation/imageSegmentation.py">here</a><br>@include samples&#x2F;python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;imageSegmentation.py<br>@end_toggle</p>
<h2 id="Explanation-x2F-Result"><a href="#Explanation-x2F-Result" class="headerlink" title="Explanation &#x2F; Result"></a>Explanation &#x2F; Result</h2><ul>
<li>Load the source image and check if it is loaded without any problem, then show it:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;imageSegmentation.cpp load_image<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;ImageSegmentationDemo.java load_image<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;imageSegmentation.py load_image<br>@end_toggle</p>
<p><img src="/images/source.jpeg"></p>
<ul>
<li>Then if we have an image with a white background, it is good to transform it to black. This will help us to discriminate the foreground objects easier when we will apply the Distance Transform:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;imageSegmentation.cpp black_bg<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;ImageSegmentationDemo.java black_bg<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;imageSegmentation.py black_bg<br>@end_toggle</p>
<p><img src="/images/black_bg.jpeg"></p>
<ul>
<li>Afterwards we will sharpen our image in order to acute the edges of the foreground objects. We will apply a laplacian filter with a quite strong filter (an approximation of second derivative):</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;imageSegmentation.cpp sharp<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;ImageSegmentationDemo.java sharp<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;imageSegmentation.py sharp<br>@end_toggle</p>
<p><img src="/images/laplace.jpeg"><br><img src="/images/sharp.jpeg"></p>
<ul>
<li>Now we transform our new sharpened source image to a grayscale and a binary one, respectively:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;imageSegmentation.cpp bin<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;ImageSegmentationDemo.java bin<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;imageSegmentation.py bin<br>@end_toggle</p>
<p><img src="/images/bin.jpeg"></p>
<ul>
<li>We are ready now to apply the Distance Transform on the binary image. Moreover, we normalize the output image in order to be able visualize and threshold the result:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;imageSegmentation.cpp dist<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;ImageSegmentationDemo.java dist<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;imageSegmentation.py dist<br>@end_toggle</p>
<p><img src="/images/dist_transf.jpeg"></p>
<ul>
<li>We threshold the <em>dist</em> image and then perform some morphology operation (i.e. dilation) in order to extract the peaks from the above image:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;imageSegmentation.cpp peaks<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;ImageSegmentationDemo.java peaks<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;imageSegmentation.py peaks<br>@end_toggle</p>
<p><img src="/images/peaks.jpeg"></p>
<ul>
<li>From each blob then we create a seed&#x2F;marker for the watershed algorithm with the help of the @ref cv::findContours function:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;imageSegmentation.cpp seeds<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;ImageSegmentationDemo.java seeds<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;imageSegmentation.py seeds<br>@end_toggle</p>
<p><img src="/images/markers.jpeg"></p>
<ul>
<li>Finally, we can apply the watershed algorithm, and visualize the result:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;imageSegmentation.cpp watershed<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;ImageSegmentationDemo.java watershed<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet samples&#x2F;python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;distance_transformation&#x2F;imageSegmentation.py watershed<br>@end_toggle</p>
<p><img src="/images/final.jpeg"></p>
