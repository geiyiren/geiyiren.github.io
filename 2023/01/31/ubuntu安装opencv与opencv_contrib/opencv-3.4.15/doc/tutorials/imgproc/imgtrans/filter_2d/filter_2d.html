<h1 id="Making-your-own-linear-filters-tutorial-filter-2d"><a href="#Making-your-own-linear-filters-tutorial-filter-2d" class="headerlink" title="Making your own linear filters! {#tutorial_filter_2d}"></a>Making your own linear filters! {#tutorial_filter_2d}</h1><p>@prev_tutorial{tutorial_threshold_inRange}<br>@next_tutorial{tutorial_copyMakeBorder}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this tutorial you will learn how to:</p>
<ul>
<li>Use the OpenCV function <strong>filter2D()</strong> to create your own linear filters.</li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>@note The explanation below belongs to the book <strong>Learning OpenCV</strong> by Bradski and Kaehler.</p>
<h3 id="Correlation"><a href="#Correlation" class="headerlink" title="Correlation"></a>Correlation</h3><p>In a very general sense, correlation is an operation between every part of an image and an operator<br>(kernel).</p>
<h3 id="What-is-a-kernel"><a href="#What-is-a-kernel" class="headerlink" title="What is a kernel?"></a>What is a kernel?</h3><p>A kernel is essentially a fixed size array of numerical coefficients along with an <em>anchor point</em> in<br>that array, which is typically located at the center.</p>
<p><img src="/images/filter_2d_tutorial_kernel_theory.png"></p>
<h3 id="How-does-correlation-with-a-kernel-work"><a href="#How-does-correlation-with-a-kernel-work" class="headerlink" title="How does correlation with a kernel work?"></a>How does correlation with a kernel work?</h3><p>Assume you want to know the resulting value of a particular location in the image. The value of the<br>correlation is calculated in the following way:</p>
<p>-#  Place the kernel anchor on top of a determined pixel, with the rest of the kernel overlaying the<br>    corresponding local pixels in the image.<br>-#  Multiply the kernel coefficients by the corresponding image pixel values and sum the result.<br>-#  Place the result to the location of the <em>anchor</em> in the input image.<br>-#  Repeat the process for all pixels by scanning the kernel over the entire image.</p>
<p>Expressing the procedure above in the form of an equation we would have:</p>
<p>\f[H(x,y) &#x3D; \sum_{i&#x3D;0}^{M_{i} - 1} \sum_{j&#x3D;0}^{M_{j}-1} I(x+i - a_{i}, y + j - a_{j})K(i,j)\f]</p>
<p>Fortunately, OpenCV provides you with the function <strong>filter2D()</strong> so you do not have to code all<br>these operations.</p>
<h3 id="What-does-this-program-do"><a href="#What-does-this-program-do" class="headerlink" title="What does this program do?"></a>What does this program do?</h3><ul>
<li>Loads an image</li>
<li>Performs a <em>normalized box filter</em>. For instance, for a kernel of size \f$size &#x3D; 3\f$, the<br>kernel would be:</li>
</ul>
<p>\f[K &#x3D; \dfrac{1}{3 \cdot 3} \begin{bmatrix}<br>1 &amp; 1 &amp; 1  \<br>        1 &amp; 1 &amp; 1  \<br>        1 &amp; 1 &amp; 1<br>\end{bmatrix}\f]</p>
<p>The program will perform the filter operation with kernels of sizes 3, 5, 7, 9 and 11.</p>
<ul>
<li>The filter output (with each kernel) will be shown during 500 milliseconds</li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>The tutorial code’s is shown in the lines below.</p>
<p>@add_toggle_cpp<br>You can also download it from<br><a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/cpp/tutorial_code/ImgTrans/filter2D_demo.cpp">here</a><br>@include cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;filter2D_demo.cpp<br>@end_toggle</p>
<p>@add_toggle_java<br>You can also download it from<br><a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/java/tutorial_code/ImgTrans/Filter2D/Filter2D_Demo.java">here</a><br>@include java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;Filter2D&#x2F;Filter2D_Demo.java<br>@end_toggle</p>
<p>@add_toggle_python<br>You can also download it from<br><a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/python/tutorial_code/ImgTrans/Filter2D/filter2D.py">here</a><br>@include python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;Filter2D&#x2F;filter2D.py<br>@end_toggle</p>
<h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><h4 id="Load-an-image"><a href="#Load-an-image" class="headerlink" title="Load an image"></a>Load an image</h4><p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;filter2D_demo.cpp load<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;Filter2D&#x2F;Filter2D_Demo.java load<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;Filter2D&#x2F;filter2D.py load<br>@end_toggle</p>
<h4 id="Initialize-the-arguments"><a href="#Initialize-the-arguments" class="headerlink" title="Initialize the arguments"></a>Initialize the arguments</h4><p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;filter2D_demo.cpp init_arguments<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;Filter2D&#x2F;Filter2D_Demo.java init_arguments<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;Filter2D&#x2F;filter2D.py init_arguments<br>@end_toggle</p>
<h5 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a>Loop</h5><p>Perform an infinite loop updating the kernel size and applying our linear filter to the input<br>image. Let’s analyze that more in detail:</p>
<ul>
<li>First we define the kernel our filter is going to use. Here it is:</li>
</ul>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;filter2D_demo.cpp update_kernel<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;Filter2D&#x2F;Filter2D_Demo.java update_kernel<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;Filter2D&#x2F;filter2D.py update_kernel<br>@end_toggle</p>
<p>The first line is to update the <em>kernel_size</em> to odd values in the range: \f$[3,11]\f$.<br>The second line actually builds the kernel by setting its value to a matrix filled with<br>\f$1’s\f$ and normalizing it by dividing it between the number of elements.</p>
<ul>
<li>After setting the kernel, we can generate the filter by using the function <strong>filter2D()</strong> :</li>
</ul>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;filter2D_demo.cpp apply_filter<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;Filter2D&#x2F;Filter2D_Demo.java apply_filter<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;ImgTrans&#x2F;Filter2D&#x2F;filter2D.py apply_filter<br>@end_toggle</p>
<ul>
<li><p>The arguments denote:<br>-  <em>src</em>: Source image<br>-  <em>dst</em>: Destination image<br>-  <em>ddepth</em>: The depth of <em>dst</em>. A negative value (such as \f$-1\f$) indicates that the depth is<br> the same as the source.<br>-  <em>kernel</em>: The kernel to be scanned through the image<br>-  <em>anchor</em>: The position of the anchor relative to its kernel. The location <em>Point(-1, -1)</em><br>indicates the center by default.<br>-  <em>delta</em>: A value to be added to each pixel during the correlation. By default it is \f$0\f$<br>-  <em>BORDER_DEFAULT</em>: We let this value by default (more details in the following tutorial)</p>
</li>
<li><p>Our program will effectuate a <em>while</em> loop, each 500 ms the kernel size of our filter will be<br> updated in the range indicated.</p>
</li>
</ul>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>-#  After compiling the code above, you can execute it giving as argument the path of an image. The<br>    result should be a window that shows an image blurred by a normalized filter. Each 0.5 seconds<br>    the kernel size should change, as can be seen in the series of snapshots below:</p>
<p><img src="/images/filter_2d_tutorial_result.jpg"></p>
