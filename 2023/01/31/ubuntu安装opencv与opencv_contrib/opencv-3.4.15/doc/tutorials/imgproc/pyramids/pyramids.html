<h1 id="Image-Pyramids-tutorial-pyramids"><a href="#Image-Pyramids-tutorial-pyramids" class="headerlink" title="Image Pyramids {#tutorial_pyramids}"></a>Image Pyramids {#tutorial_pyramids}</h1><p>@prev_tutorial{tutorial_morph_lines_detection}<br>@next_tutorial{tutorial_threshold}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this tutorial you will learn how to:</p>
<ul>
<li>Use the OpenCV functions <strong>pyrUp()</strong> and <strong>pyrDown()</strong> to downsample or upsample a given<br>image.</li>
</ul>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><p>@note The explanation below belongs to the book <strong>Learning OpenCV</strong> by Bradski and Kaehler.</p>
<ul>
<li>Usually we need to convert an image to a size different than its original. For this, there are<br>two possible options:<br>-#  <em>Upsize</em> the image (zoom in) or<br>-#  <em>Downsize</em> it (zoom out).</li>
<li>Although there is a <em>geometric transformation</em> function in OpenCV that -literally- resize an<br>image (<strong>resize</strong> , which we will show in a future tutorial), in this section we analyze<br>first the use of <strong>Image Pyramids</strong>, which are widely applied in a huge range of vision<br>applications.</li>
</ul>
<h3 id="Image-Pyramid"><a href="#Image-Pyramid" class="headerlink" title="Image Pyramid"></a>Image Pyramid</h3><ul>
<li>An image pyramid is a collection of images - all arising from a single original image - that are<br>successively downsampled until some desired stopping point is reached.</li>
<li>There are two common kinds of image pyramids:<ul>
<li><strong>Gaussian pyramid:</strong> Used to downsample images</li>
<li><strong>Laplacian pyramid:</strong> Used to reconstruct an upsampled image from an image lower in the<br>pyramid (with less resolution)</li>
</ul>
</li>
<li>In this tutorial we’ll use the <em>Gaussian pyramid</em>.</li>
</ul>
<h4 id="Gaussian-Pyramid"><a href="#Gaussian-Pyramid" class="headerlink" title="Gaussian Pyramid"></a>Gaussian Pyramid</h4><ul>
<li><p>Imagine the pyramid as a set of layers in which the higher the layer, the smaller the size.</p>
<p><img src="/images/Pyramids_Tutorial_Pyramid_Theory.png"></p>
</li>
<li><p>Every layer is numbered from bottom to top, so layer \f$(i+1)\f$ (denoted as \f$G_{i+1}\f$ is smaller<br>than layer \f$i\f$ (\f$G_{i}\f$).</p>
</li>
<li><p>To produce layer \f$(i+1)\f$ in the Gaussian pyramid, we do the following:</p>
<ul>
<li><p>Convolve \f$G_{i}\f$ with a Gaussian kernel:</p>
<p>\f[\frac{1}{16} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1  \ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6  \ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix}\f]</p>
</li>
<li><p>Remove every even-numbered row and column.</p>
</li>
</ul>
</li>
<li><p>You can easily notice that the resulting image will be exactly one-quarter the area of its<br>predecessor. Iterating this process on the input image \f$G_{0}\f$ (original image) produces the<br>entire pyramid.</p>
</li>
<li><p>The procedure above was useful to downsample an image. What if we want to make it bigger?:<br>columns filled with zeros (\f$0 \f$)</p>
<ul>
<li>First, upsize the image to twice the original in each dimension, with the new even rows and</li>
<li>Perform a convolution with the same kernel shown above (multiplied by 4) to approximate the<br>values of the “missing pixels”</li>
</ul>
</li>
<li><p>These two procedures (downsampling and upsampling as explained above) are implemented by the<br>OpenCV functions <strong>pyrUp()</strong> and <strong>pyrDown()</strong> , as we will see in an example with the<br>code below:</p>
</li>
</ul>
<p>@note When we reduce the size of an image, we are actually <em>losing</em> information of the image.</p>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>This tutorial code’s is shown lines below.</p>
<p>@add_toggle_cpp<br>You can also download it from<br><a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/cpp/tutorial_code/ImgProc/Pyramids/Pyramids.cpp">here</a><br>@include samples&#x2F;cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.cpp<br>@end_toggle</p>
<p>@add_toggle_java<br>You can also download it from<br><a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/java/tutorial_code/ImgProc/Pyramids/Pyramids.java">here</a><br>@include samples&#x2F;java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.java<br>@end_toggle</p>
<p>@add_toggle_python<br>You can also download it from<br><a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/python/tutorial_code/imgProc/Pyramids/pyramids.py">here</a><br>@include samples&#x2F;python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Pyramids&#x2F;pyramids.py<br>@end_toggle</p>
<h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><p>Let’s check the general structure of the program:</p>
<h4 id="Load-an-image"><a href="#Load-an-image" class="headerlink" title="Load an image"></a>Load an image</h4><p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.cpp load<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.java load<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Pyramids&#x2F;pyramids.py load<br>@end_toggle</p>
<h4 id="Create-window"><a href="#Create-window" class="headerlink" title="Create window"></a>Create window</h4><p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.cpp show_image<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.java show_image<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Pyramids&#x2F;pyramids.py show_image<br>@end_toggle</p>
<h4 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a>Loop</h4><p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.cpp loop<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.java loop<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Pyramids&#x2F;pyramids.py loop<br>@end_toggle</p>
<p>Perform an infinite loop waiting for user input.<br>Our program exits if the user presses <strong>ESC</strong>. Besides, it has two options:</p>
<ul>
<li><p><strong>Perform upsampling - Zoom ‘i’n (after pressing ‘i’)</strong></p>
<p>We use the function <strong>pyrUp()</strong> with three arguments:<br>-   <em>src</em>: The current and destination image (to be shown on screen, supposedly the double of the<br>    input image)<br>-   <em>Size( tmp.cols</em>2, tmp.rows*2 )* : The destination size. Since we are upsampling,<br>    <strong>pyrUp()</strong> expects a size double than the input image (in this case <em>src</em>).</p>
</li>
</ul>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.cpp pyrup<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.java pyrup<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Pyramids&#x2F;pyramids.py pyrup<br>@end_toggle</p>
<ul>
<li><p><strong>Perform downsampling - Zoom ‘o’ut (after pressing ‘o’)</strong></p>
<p>We use the function <strong>pyrDown()</strong> with three arguments (similarly to <strong>pyrUp()</strong>):<br>    -   <em>src</em>: The current and destination image  (to be shown on screen, supposedly half the input<br>        image)<br>    -   <em>Size( tmp.cols&#x2F;2, tmp.rows&#x2F;2 )</em> : The destination size. Since we are downsampling,<br>        <strong>pyrDown()</strong> expects half the size the input image (in this case <em>src</em>).</p>
</li>
</ul>
<p>@add_toggle_cpp<br>@snippet cpp&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.cpp pyrdown<br>@end_toggle</p>
<p>@add_toggle_java<br>@snippet java&#x2F;tutorial_code&#x2F;ImgProc&#x2F;Pyramids&#x2F;Pyramids.java pyrdown<br>@end_toggle</p>
<p>@add_toggle_python<br>@snippet python&#x2F;tutorial_code&#x2F;imgProc&#x2F;Pyramids&#x2F;pyramids.py pyrdown<br>@end_toggle</p>
<p>Notice that it is important that the input image can be divided by a factor of two (in both dimensions).<br>Otherwise, an error will be shown.</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><ul>
<li><p>The program calls by default an image <a href="https://raw.githubusercontent.com/opencv/opencv/3.4/samples/data/chicky_512.png">chicky_512.png</a><br>that comes in the <code>samples/data</code> folder. Notice that this image is \f$512 \times 512\f$,<br>hence a downsample won’t generate any error (\f$512 &#x3D; 2^{9}\f$). The original image is shown below:</p>
<p><img src="/images/Pyramids_Tutorial_Original_Image.jpg"></p>
</li>
<li><p>First we apply two successive <strong>pyrDown()</strong> operations by pressing ‘d’. Our output is:</p>
<p><img src="/images/Pyramids_Tutorial_PyrDown_Result.jpg"></p>
</li>
<li><p>Note that we should have lost some resolution due to the fact that we are diminishing the size<br>of the image. This is evident after we apply <strong>pyrUp()</strong> twice (by pressing ‘u’). Our output<br>is now:</p>
<p><img src="/images/Pyramids_Tutorial_PyrUp_Result.jpg"></p>
</li>
</ul>
