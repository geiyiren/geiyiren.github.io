<h1 id="Introduction-to-OpenCV-Development-with-Clojure-tutorial-clojure-dev-intro"><a href="#Introduction-to-OpenCV-Development-with-Clojure-tutorial-clojure-dev-intro" class="headerlink" title="Introduction to OpenCV Development with Clojure {#tutorial_clojure_dev_intro}"></a>Introduction to OpenCV Development with Clojure {#tutorial_clojure_dev_intro}</h1><p>@prev_tutorial{tutorial_java_eclipse}<br>@next_tutorial{tutorial_android_dev_intro}</p>
<p>As of OpenCV 2.4.4, OpenCV supports desktop Java development using nearly the same interface as for<br>Android development.</p>
<p><a href="http://clojure.org/">Clojure</a> is a contemporary LISP dialect hosted by the Java Virtual Machine and<br>it offers a complete interoperability with the underlying JVM. This means that we should even be<br>able to use the Clojure REPL (Read Eval Print Loop) as and interactive programmable interface to the<br>underlying OpenCV engine.</p>
<h2 id="What-we’ll-do-in-this-tutorial"><a href="#What-we’ll-do-in-this-tutorial" class="headerlink" title="What we’ll do in this tutorial"></a>What we’ll do in this tutorial</h2><p>This tutorial will help you in setting up a basic Clojure environment for interactively learning<br>OpenCV within the fully programmable CLojure REPL.</p>
<h3 id="Tutorial-source-code"><a href="#Tutorial-source-code" class="headerlink" title="Tutorial source code"></a>Tutorial source code</h3><h2 id="You-can-find-a-runnable-source-code-of-the-sample-in-the-samples-java-clojure-simple-sample-folderof-the-OpenCV-repository-After-having-installed-OpenCV-and-Clojure-as-explained-in-the-tutorial-issue-the-following-command-to-run-the-sample-from-the-command-line-code-bash-cd-path-x2F-to-x2F-samples-x2F-java-x2F-clojure-x2F-simple-samplelein-run-endcodePreamble"><a href="#You-can-find-a-runnable-source-code-of-the-sample-in-the-samples-java-clojure-simple-sample-folderof-the-OpenCV-repository-After-having-installed-OpenCV-and-Clojure-as-explained-in-the-tutorial-issue-the-following-command-to-run-the-sample-from-the-command-line-code-bash-cd-path-x2F-to-x2F-samples-x2F-java-x2F-clojure-x2F-simple-samplelein-run-endcodePreamble" class="headerlink" title="You can find a runnable source code of the sample in the samples/java/clojure/simple-sample folderof the OpenCV repository. After having installed OpenCV and Clojure as explained in the tutorial,issue the following command to run the sample from the command line.@code{.bash}cd path&#x2F;to&#x2F;samples&#x2F;java&#x2F;clojure&#x2F;simple-samplelein run@endcodePreamble"></a>You can find a runnable source code of the sample in the <code>samples/java/clojure/simple-sample</code> folder<br>of the OpenCV repository. After having installed OpenCV and Clojure as explained in the tutorial,<br>issue the following command to run the sample from the command line.<br>@code{.bash}<br>cd path&#x2F;to&#x2F;samples&#x2F;java&#x2F;clojure&#x2F;simple-sample<br>lein run<br>@endcode<br>Preamble</h2><p>For detailed instruction on installing OpenCV with desktop Java support refer to the @ref tutorial_java_dev_intro “corresponding<br>tutorial”.</p>
<p>If you are in hurry, here is a minimum quick start guide to install OpenCV on Mac OS X:</p>
<p>@note<br>I’m assuming you already installed <a href="https://developer.apple.com/xcode/">xcode</a>,<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">jdk</a> and<br><a href="http://www.cmake.org/cmake/resources/software.html">Cmake</a>.</p>
<h2 id="code-bash-cd-x2F-mkdir-optgit-clone-https-github-com-opencv-opencv-gitcd-opencvgit-checkout-2-4mkdir-buildcd-buildcmake-DBUILD-SHARED-LIBS-x3D-OFF-……make-j8-optional-make-install-endcodeInstall-Leiningen"><a href="#code-bash-cd-x2F-mkdir-optgit-clone-https-github-com-opencv-opencv-gitcd-opencvgit-checkout-2-4mkdir-buildcd-buildcmake-DBUILD-SHARED-LIBS-x3D-OFF-……make-j8-optional-make-install-endcodeInstall-Leiningen" class="headerlink" title="@code{.bash}cd ~&#x2F;mkdir optgit clone https://github.com/opencv/opencv.gitcd opencvgit checkout 2.4mkdir buildcd buildcmake -DBUILD_SHARED_LIBS&#x3D;OFF ..……make -j8# optional# make install@endcodeInstall Leiningen"></a>@code{.bash}<br>cd ~&#x2F;<br>mkdir opt<br>git clone <a href="https://github.com/opencv/opencv.git">https://github.com/opencv/opencv.git</a><br>cd opencv<br>git checkout 2.4<br>mkdir build<br>cd build<br>cmake -DBUILD_SHARED_LIBS&#x3D;OFF ..<br>…<br>…<br>make -j8<br># optional<br># make install<br>@endcode<br>Install Leiningen</h2><p>Once you installed OpenCV with desktop java support the only other requirement is to install<br><a href="https://github.com/technomancy/leiningen">Leiningeng</a> which allows you to manage the entire life<br>cycle of your CLJ projects.</p>
<p>The available <a href="https://github.com/technomancy/leiningen#installation">installation guide</a> is very<br>easy to be followed:</p>
<p>-#  <a href="https://raw.github.com/technomancy/leiningen/stable/bin/lein">Download the script</a><br>-#  Place it on your $PATH (cf. ~&#x2F;bin is a good choice if it is on your path.)<br>-#  Set the script to be executable. (i.e. chmod 755 ~&#x2F;bin&#x2F;lein).</p>
<p>If you work on Windows, follow <a href="https://github.com/technomancy/leiningen#windows">this instruction</a></p>
<p>You now have both the OpenCV library and a fully installed basic Clojure environment. What is now<br>needed is to configure the Clojure environment to interact with the OpenCV library.</p>
<h2 id="Install-the-localrepo-Leiningen-plugin"><a href="#Install-the-localrepo-Leiningen-plugin" class="headerlink" title="Install the localrepo Leiningen plugin"></a>Install the localrepo Leiningen plugin</h2><p>The set of commands (tasks in Leiningen parlance) natively supported by Leiningen can be very easily<br>extended by various plugins. One of them is the<br><a href="https://github.com/kumarshantanu/lein-localrepo">lein-localrepo</a> plugin which allows to install any<br>jar lib as an artifact in the local maven repository of your machine (typically in the<br>~&#x2F;.m2&#x2F;repository directory of your username).</p>
<p>We’re going to use this lein plugin to add to the local maven repository the opencv components<br>needed by Java and Clojure to use the opencv lib.</p>
<p>Generally speaking, if you want to use a plugin on project base only, it can be added directly to a<br>CLJ project created by lein.</p>
<p>Instead, when you want a plugin to be available to any CLJ project in your username space, you can<br>add it to the profiles.clj in the ~&#x2F;.lein&#x2F; directory.</p>
<p>The lein-localrepo plugin will be useful to me in other CLJ projects where I need to call native<br>libs wrapped by a Java interface. So I decide to make it available to any CLJ project:<br>@code{.bash}<br>mkdir <del>&#x2F;.lein<br>@endcode<br>Create a file named profiles.clj in the \</del>&#x2F;.lein directory and copy into it the following content:<br>@code{.clojure}<br>{:user {:plugins [[lein-localrepo “0.5.2”]]}}<br>@endcode<br>Here we’re saying that the version release “0.5.2” of the lein-localrepo plugin will be available to<br>the :user profile for any CLJ project created by lein.</p>
<p>You do not need to do anything else to install the plugin because it will be automatically<br>downloaded from a remote repository the very first time you issue any lein task.</p>
<h2 id="Install-the-java-specific-libs-as-local-repository"><a href="#Install-the-java-specific-libs-as-local-repository" class="headerlink" title="Install the java specific libs as local repository"></a>Install the java specific libs as local repository</h2><p>If you followed the standard documentation for installing OpenCV on your computer, you should find<br>the following two libs under the directory where you built OpenCV:</p>
<ul>
<li>the build&#x2F;bin&#x2F;opencv-247.jar java lib</li>
<li>the build&#x2F;lib&#x2F;libopencv_java247.dylib native lib (or .so in you built OpenCV a GNU&#x2F;Linux OS)</li>
</ul>
<p>They are the only opencv libs needed by the JVM to interact with OpenCV.</p>
<h3 id="Take-apart-the-needed-opencv-libs"><a href="#Take-apart-the-needed-opencv-libs" class="headerlink" title="Take apart the needed opencv libs"></a>Take apart the needed opencv libs</h3><p>Create a new directory to store in the above two libs. Start by copying into it the opencv-247.jar<br>lib.<br>@code{.bash}<br>cd ~&#x2F;opt<br>mkdir clj-opencv<br>cd clj-opencv<br>cp ~&#x2F;opt&#x2F;opencv&#x2F;build&#x2F;bin&#x2F;opencv-247.jar .<br>@endcode<br>First lib done.</p>
<p>Now, to be able to add the libopencv_java247.dylib shared native lib to the local maven repository,<br>we first need to package it as a jar file.</p>
<p>The native lib has to be copied into a directories layout which mimics the names of your operating<br>system and architecture. I’m using a Mac OS X with a X86 64 bit architecture. So my layout will be<br>the following:<br>@code{.bash}<br>mkdir -p native&#x2F;macosx&#x2F;x86_64<br>@endcode<br>Copy into the x86_64 directory the libopencv_java247.dylib lib.<br>@code{.bash}<br>cp ~&#x2F;opt&#x2F;opencv&#x2F;build&#x2F;lib&#x2F;libopencv_java247.dylib native&#x2F;macosx&#x2F;x86_64&#x2F;<br>@endcode<br>If you’re running OpenCV from a different OS&#x2F;Architecture pair, here is a summary of the mapping you<br>can choose from.<br>@code{.bash}<br>OS</p>
<p>Mac OS X -&gt; macosx<br>Windows  -&gt; windows<br>Linux    -&gt; linux<br>SunOS    -&gt; solaris</p>
<p>Architectures</p>
<p>amd64    -&gt; x86_64<br>x86_64   -&gt; x86_64<br>x86      -&gt; x86<br>i386     -&gt; x86<br>arm      -&gt; arm<br>sparc    -&gt; sparc<br>@endcode</p>
<h3 id="Package-the-native-lib-as-a-jar"><a href="#Package-the-native-lib-as-a-jar" class="headerlink" title="Package the native lib as a jar"></a>Package the native lib as a jar</h3><p>Next you need to package the native lib in a jar file by using the jar command to create a new jar<br>file from a directory.<br>@code{.bash}<br>jar -cMf opencv-native-247.jar native<br>@endcode<br>Note that ehe M option instructs the jar command to not create a MANIFEST file for the artifact.</p>
<p>Your directories layout should look like the following:<br>@code{.bash}<br>tree<br>.<br>|__ native<br>|   |__ macosx<br>|       |__ x86_64<br>|           |__ libopencv_java247.dylib<br>|<br>|__ opencv-247.jar<br>|__ opencv-native-247.jar</p>
<p>3 directories, 3 files<br>@endcode</p>
<h3 id="Locally-install-the-jars"><a href="#Locally-install-the-jars" class="headerlink" title="Locally install the jars"></a>Locally install the jars</h3><p>We are now ready to add the two jars as artifacts to the local maven repository with the help of the<br>lein-localrepo plugin.<br>@code{.bash}<br>lein localrepo install opencv-247.jar opencv&#x2F;opencv 2.4.7<br>@endcode<br>Here the localrepo install task creates the 2.4.7. release of the opencv&#x2F;opencv maven artifact from<br>the opencv-247.jar lib and then installs it into the local maven repository. The opencv&#x2F;opencv<br>artifact will then be available to any maven compliant project (Leiningen is internally based on<br>maven).</p>
<p>Do the same thing with the native lib previously wrapped in a new jar file.<br>@code{.bash}<br>lein localrepo install opencv-native-247.jar opencv&#x2F;opencv-native 2.4.7<br>@endcode<br>Note that the groupId, opencv, of the two artifacts is the same. We are now ready to create a new<br>CLJ project to start interacting with OpenCV.</p>
<h3 id="Create-a-project"><a href="#Create-a-project" class="headerlink" title="Create a project"></a>Create a project</h3><p>Create a new CLJ project by using the lein new task from the terminal.<br>@code{.bash}</p>
<h1 id="cd-in-the-directory-where-you-work-with-your-development-projects-e-g-x2F-devel"><a href="#cd-in-the-directory-where-you-work-with-your-development-projects-e-g-x2F-devel" class="headerlink" title="cd in the directory where you work with your development projects (e.g. ~&#x2F;devel)"></a>cd in the directory where you work with your development projects (e.g. ~&#x2F;devel)</h1><p>lein new simple-sample<br>Generating a project called simple-sample based on the ‘default’ template.<br>To see other templates (app, lein plugin, etc), try <code>lein help new</code>.<br>@endcode<br>The above task creates the following simple-sample directories layout:<br>@code{.bash}<br>tree simple-sample&#x2F;<br>simple-sample&#x2F;<br>|__ LICENSE<br>|__ README.md<br>|__ doc<br>|   |__ intro.md<br>|<br>|__ project.clj<br>|__ resources<br>|__ src<br>|   |__ simple_sample<br>|       |__ core.clj<br>|__ test<br>    |__ simple_sample<br>        |__ core_test.clj</p>
<p>6 directories, 6 files<br>@endcode<br>We need to add the two opencv artifacts as dependencies of the newly created project. Open the<br>project.clj and modify its dependencies section as follows:<br>@code{.bash}<br>(defproject simple-sample “0.1.0-SNAPSHOT”<br>description “FIXME: write description”<br>url “<a href="http://example.com/FIXME&quot;">http://example.com/FIXME&quot;</a><br>license {:name “Eclipse Public License”<br>url “<a href="http://www.eclipse.org/legal/epl-v10.html&quot;%7D">http://www.eclipse.org/legal/epl-v10.html&quot;}</a><br>dependencies [[org.clojure&#x2F;clojure “1.5.1”]<br>                 [opencv&#x2F;opencv “2.4.7”] ; added line<br>                 [opencv&#x2F;opencv-native “2.4.7”]]) ;added line<br>@endcode<br>Note that The Clojure Programming Language is a jar artifact too. This is why Clojure is called an<br>hosted language.</p>
<p>To verify that everything went right issue the lein deps task. The very first time you run a lein<br>task it will take sometime to download all the required dependencies before executing the task<br>itself.<br>@code{.bash}<br>cd simple-sample<br>lein deps<br>…<br>@endcode<br>The deps task reads and merges from the project.clj and the ~&#x2F;.lein&#x2F;profiles.clj files all the<br>dependencies of the simple-sample project and verifies if they have already been cached in the local<br>maven repository. If the task returns without messages about not being able to retrieve the two new<br>artifacts your installation is correct, otherwise go back and double check that you did everything<br>right.</p>
<h3 id="REPLing-with-OpenCV"><a href="#REPLing-with-OpenCV" class="headerlink" title="REPLing with OpenCV"></a>REPLing with OpenCV</h3><p>Now cd in the simple-sample directory and issue the following lein task:<br>@code{.bash}<br>cd simple-sample<br>lein repl<br>…<br>…<br>nREPL server started on port 50907 on host 127.0.0.1<br>REPL-y 0.3.0<br>Clojure 1.5.1<br>    Docs: (doc function-name-here)<br>          (find-doc “part-of-name-here”)<br>  Source: (source function-name-here)<br> Javadoc: (javadoc java-object-or-class-here)<br>    Exit: Control+D or (exit) or (quit)<br> Results: Stored in vars *1, *2, *3, an exception in *e</p>
<p>user&#x3D;&gt;<br>@endcode<br>You can immediately interact with the REPL by issuing any CLJ expression to be evaluated.<br>@code{.clojure}<br>user&#x3D;&gt; (+ 41 1)<br>42<br>user&#x3D;&gt; (println “Hello, OpenCV!”)<br>Hello, OpenCV!<br>nil<br>user&#x3D;&gt; (defn foo [] (str “bar”))<br>#’user&#x2F;foo<br>user&#x3D;&gt; (foo)<br>“bar”<br>@endcode<br>When ran from the home directory of a lein based project, even if the lein repl task automatically<br>loads all the project dependencies, you still need to load the opencv native library to be able to<br>interact with the OpenCV.<br>@code{.clojure}<br>user&#x3D;&gt; (clojure.lang.RT&#x2F;loadLibrary org.opencv.core.Core&#x2F;NATIVE_LIBRARY_NAME)<br>nil<br>@endcode<br>Then you can start interacting with OpenCV by just referencing the fully qualified names of its<br>classes.</p>
<p>@note<br><a href="https://docs.opencv.org/3.4/javadoc/index.html">Here</a> you can find the full OpenCV Java API.</p>
<p>@code{.clojure}<br>user&#x3D;&gt; (org.opencv.core.Point. 0 0)<br>#&lt;Point {0.0, 0.0}&gt;<br>@endcode<br>Here we created a two dimensions opencv Point instance. Even if all the java packages included<br>within the java interface to OpenCV are immediately available from the CLJ REPL, it’s very annoying<br>to prefix the Point. instance constructors with the fully qualified package name.</p>
<p>Fortunately CLJ offer a very easy way to overcome this annoyance by directly importing the Point<br>class.<br>@code{.clojure}<br>user&#x3D;&gt; (import ‘org.opencv.core.Point)<br>org.opencv.core.Point<br>user&#x3D;&gt; (def p1 (Point. 0 0))<br>#’user&#x2F;p1<br>user&#x3D;&gt; p1<br>#&lt;Point {0.0, 0.0}&gt;<br>user&#x3D;&gt; (def p2 (Point. 100 100))<br>#’user&#x2F;p2<br>@endcode<br>We can even inspect the class of an instance and verify if the value of a symbol is an instance of a<br>Point java class.<br>@code{.clojure}<br>user&#x3D;&gt; (class p1)<br>org.opencv.core.Point<br>user&#x3D;&gt; (instance? org.opencv.core.Point p1)<br>true<br>@endcode<br>If we now want to use the opencv Rect class to create a rectangle, we again have to fully qualify<br>its constructor even if it leaves in the same org.opencv.core package of the Point class.<br>@code{.clojure}<br>user&#x3D;&gt; (org.opencv.core.Rect. p1 p2)<br>#&lt;Rect {0, 0, 100x100}&gt;<br>@endcode<br>Again, the CLJ importing facilities is very handy and let you to map more symbols in one shot.<br>@code{.clojure}<br>user&#x3D;&gt; (import ‘[org.opencv.core Point Rect Size])<br>org.opencv.core.Size<br>user&#x3D;&gt; (def r1 (Rect. p1 p2))<br>#’user&#x2F;r1<br>user&#x3D;&gt; r1<br>#&lt;Rect {0, 0, 100x100}&gt;<br>user&#x3D;&gt; (class r1)<br>org.opencv.core.Rect<br>user&#x3D;&gt; (instance? org.opencv.core.Rect r1)<br>true<br>user&#x3D;&gt; (Size. 100 100)<br>#&lt;Size 100x100&gt;<br>user&#x3D;&gt; (def sq-100 (Size. 100 100))<br>#’user&#x2F;sq-100<br>user&#x3D;&gt; (class sq-100)<br>org.opencv.core.Size<br>user&#x3D;&gt; (instance? org.opencv.core.Size sq-100)<br>true<br>@endcode<br>Obviously you can call methods on instances as well.<br>@code{.clojure}<br>user&#x3D;&gt; (.area r1)<br>10000.0<br>user&#x3D;&gt; (.area sq-100)<br>10000.0<br>@endcode<br>Or modify the value of a member field.<br>@code{.clojure}<br>user&#x3D;&gt; (set! (.x p1) 10)<br>10<br>user&#x3D;&gt; p1<br>#&lt;Point {10.0, 0.0}&gt;<br>user&#x3D;&gt; (set! (.width sq-100) 10)<br>10<br>user&#x3D;&gt; (set! (.height sq-100) 10)<br>10<br>user&#x3D;&gt; (.area sq-100)<br>100.0<br>@endcode<br>If you find yourself not remembering a OpenCV class behavior, the REPL gives you the opportunity to<br>easily search the corresponding javadoc documentation:<br>@code{.clojure}<br>user&#x3D;&gt; (javadoc Rect)<br>“<a href="http://www.google.com/search?btnI=I%27m%20Feeling%20Lucky&amp;q=allinurl:org/opencv/core/Rect.html&quot;">http://www.google.com/search?btnI=I%27m%20Feeling%20Lucky&amp;q=allinurl:org/opencv/core/Rect.html&quot;</a><br>@endcode</p>
<h3 id="Mimic-the-OpenCV-Java-Tutorial-Sample-in-the-REPL"><a href="#Mimic-the-OpenCV-Java-Tutorial-Sample-in-the-REPL" class="headerlink" title="Mimic the OpenCV Java Tutorial Sample in the REPL"></a>Mimic the OpenCV Java Tutorial Sample in the REPL</h3><p>Let’s now try to port to Clojure the @ref tutorial_java_dev_intro “OpenCV Java tutorial sample”.<br>Instead of writing it in a source file we’re going to evaluate it at the REPL.</p>
<p>Following is the original Java source code of the cited sample.<br>@code{.java}<br>import org.opencv.core.Mat;<br>import org.opencv.core.CvType;<br>import org.opencv.core.Scalar;</p>
<p>class SimpleSample {</p>
<p>  static{ System.loadLibrary(“opencv_java244”); }</p>
<p>  public static void main(String[] args) {<br>    Mat m &#x3D; new Mat(5, 10, CvType.CV_8UC1, new Scalar(0));<br>    System.out.println(“OpenCV Mat: “ + m);<br>    Mat mr1 &#x3D; m.row(1);<br>    mr1.setTo(new Scalar(1));<br>    Mat mc5 &#x3D; m.col(5);<br>    mc5.setTo(new Scalar(5));<br>    System.out.println(“OpenCV Mat data:\n” + m.dump());<br>  }</p>
<p>}<br>@endcode</p>
<h3 id="Add-injections-to-the-project"><a href="#Add-injections-to-the-project" class="headerlink" title="Add injections to the project"></a>Add injections to the project</h3><p>Before start coding, we’d like to eliminate the boring need of interactively loading the native<br>opencv lib any time we start a new REPL to interact with it.</p>
<p>First, stop the REPL by evaluating the (exit) expression at the REPL prompt.<br>@code{.clojure}<br>user&#x3D;&gt; (exit)<br>Bye for now!<br>@endcode<br>Then open your project.clj file and edit it as follows:<br>@code{.clojure}<br>(defproject simple-sample “0.1.0-SNAPSHOT”<br>  …<br>injections [(clojure.lang.RT&#x2F;loadLibrary org.opencv.core.Core&#x2F;NATIVE_LIBRARY_NAME)])<br>@endcode<br>Here we’re saying to load the opencv native lib anytime we run the REPL in such a way that we have<br>not anymore to remember to manually do it.</p>
<p>Rerun the lein repl task<br>@code{.bash}<br>lein repl<br>nREPL server started on port 51645 on host 127.0.0.1<br>REPL-y 0.3.0<br>Clojure 1.5.1<br>    Docs: (doc function-name-here)<br>          (find-doc “part-of-name-here”)<br>  Source: (source function-name-here)<br> Javadoc: (javadoc java-object-or-class-here)<br>    Exit: Control+D or (exit) or (quit)<br> Results: Stored in vars *1, *2, *3, an exception in *e</p>
<p>user&#x3D;&gt;<br>@endcode<br>Import the interested OpenCV java interfaces.<br>@code{.clojure}<br>user&#x3D;&gt; (import ‘[org.opencv.core Mat CvType Scalar])<br>org.opencv.core.Scalar<br>@endcode<br>We’re going to mimic almost verbatim the original OpenCV java tutorial to:</p>
<ul>
<li>create a 5x10 matrix with all its elements initialized to 0</li>
<li>change the value of every element of the second row to 1</li>
<li>change the value of every element of the 6th column to 5</li>
<li>print the content of the obtained matrix</li>
</ul>
<p>@code{.clojure}<br>user&#x3D;&gt; (def m (Mat. 5 10 CvType&#x2F;CV_8UC1 (Scalar. 0 0)))<br>#’user&#x2F;m<br>user&#x3D;&gt; (def mr1 (.row m 1))<br>#’user&#x2F;mr1<br>user&#x3D;&gt; (.setTo mr1 (Scalar. 1 0))<br>#&lt;Mat Mat [ 1*10*CV_8UC1, isCont&#x3D;true, isSubmat&#x3D;true, nativeObj&#x3D;0x7fc9dac49880, dataAddr&#x3D;0x7fc9d9c98d5a ]&gt;<br>user&#x3D;&gt; (def mc5 (.col m 5))<br>#’user&#x2F;mc5<br>user&#x3D;&gt; (.setTo mc5 (Scalar. 5 0))<br>#&lt;Mat Mat [ 5*1*CV_8UC1, isCont&#x3D;false, isSubmat&#x3D;true, nativeObj&#x3D;0x7fc9d9c995a0, dataAddr&#x3D;0x7fc9d9c98d55 ]&gt;<br>user&#x3D;&gt; (println (.dump m))<br>[0, 0, 0, 0, 0, 5, 0, 0, 0, 0;<br>  1, 1, 1, 1, 1, 5, 1, 1, 1, 1;<br>  0, 0, 0, 0, 0, 5, 0, 0, 0, 0;<br>  0, 0, 0, 0, 0, 5, 0, 0, 0, 0;<br>  0, 0, 0, 0, 0, 5, 0, 0, 0, 0]<br>nil<br>@endcode</p>
<p>If you are accustomed to a functional language all those abused and mutating nouns are going to<br>irritate your preference for verbs. Even if the CLJ interop syntax is very handy and complete, there<br>is still an impedance mismatch between any OOP language and any FP language (bein Scala a mixed<br>paradigms programming language).</p>
<p>To exit the REPL type (exit), ctr-D or (quit) at the REPL prompt.<br>@code{.clojure}<br>user&#x3D;&gt; (exit)<br>Bye for now!<br>@endcode</p>
<h3 id="Interactively-load-and-blur-an-image"><a href="#Interactively-load-and-blur-an-image" class="headerlink" title="Interactively load and blur an image"></a>Interactively load and blur an image</h3><p>In the next sample you will learn how to interactively load and blur and image from the REPL by<br>using the following OpenCV methods:</p>
<ul>
<li>the imread static method from the Highgui class to read an image from a file</li>
<li>the imwrite static method from the Highgui class to write an image to a file</li>
<li>the GaussianBlur static method from the Imgproc class to apply to blur the original image</li>
</ul>
<p>We’re also going to use the Mat class which is returned from the imread method and accepted as the<br>main argument to both the GaussianBlur and the imwrite methods.</p>
<h3 id="Add-an-image-to-the-project"><a href="#Add-an-image-to-the-project" class="headerlink" title="Add an image to the project"></a>Add an image to the project</h3><p>First we want to add an image file to a newly create directory for storing static resources of the<br>project.</p>
<p><img src="/images/lena.png"><br>@code{.bash}<br>mkdir -p resources&#x2F;images<br>cp ~&#x2F;opt&#x2F;opencv&#x2F;doc&#x2F;tutorials&#x2F;introduction&#x2F;desktop_java&#x2F;images&#x2F;lena.png resource&#x2F;images&#x2F;<br>@endcode</p>
<h3 id="Read-the-image"><a href="#Read-the-image" class="headerlink" title="Read the image"></a>Read the image</h3><p>Now launch the REPL as usual and start by importing all the OpenCV classes we’re going to use:<br>@code{.clojure}<br>lein repl<br>nREPL server started on port 50624 on host 127.0.0.1<br>REPL-y 0.3.0<br>Clojure 1.5.1<br>    Docs: (doc function-name-here)<br>          (find-doc “part-of-name-here”)<br>  Source: (source function-name-here)<br> Javadoc: (javadoc java-object-or-class-here)<br>    Exit: Control+D or (exit) or (quit)<br> Results: Stored in vars *1, *2, *3, an exception in *e</p>
<p>user&#x3D;&gt; (import ‘[org.opencv.core Mat Size CvType]<br>               ‘[org.opencv.imgcodecs Imgcodecs]<br>               ‘[org.opencv.imgproc Imgproc])<br>org.opencv.imgproc.Imgproc<br>@endcode<br>Now read the image from the resources&#x2F;images&#x2F;lena.png file.<br>@code{.clojure}<br>user&#x3D;&gt; (def lena (Highgui&#x2F;imread “resources&#x2F;images&#x2F;lena.png”))<br>#’user&#x2F;lena<br>user&#x3D;&gt; lena<br>#&lt;Mat Mat [ 512*512*CV_8UC3, isCont&#x3D;true, isSubmat&#x3D;false, nativeObj&#x3D;0x7f9ab3054c40, dataAddr&#x3D;0x19fea9010 ]&gt;<br>@endcode<br>As you see, by simply evaluating the lena symbol we know that lena.png is a 512x512 matrix of<br>CV_8UC3 elements type. Let’s create a new Mat instance of the same dimensions and elements type.<br>@code{.clojure}<br>user&#x3D;&gt; (def blurred (Mat. 512 512 CvType&#x2F;CV_8UC3))<br>#’user&#x2F;blurred<br>user&#x3D;&gt;<br>@endcode<br>Now apply a GaussianBlur filter using lena as the source matrix and blurred as the destination<br>matrix.<br>@code{.clojure}<br>user&#x3D;&gt; (Imgproc&#x2F;GaussianBlur lena blurred (Size. 5 5) 3 3)<br>nil<br>@endcode<br>As a last step just save the blurred matrix in a new image file.<br>@code{.clojure}<br>user&#x3D;&gt; (Highgui&#x2F;imwrite “resources&#x2F;images&#x2F;blurred.png” blurred)<br>true<br>user&#x3D;&gt; (exit)<br>Bye for now!<br>@endcode<br>Following is the new blurred image of Lena.</p>
<p><img src="/images/blurred.png"></p>
<h2 id="Next-Steps"><a href="#Next-Steps" class="headerlink" title="Next Steps"></a>Next Steps</h2><p>This tutorial only introduces the very basic environment set up to be able to interact with OpenCV<br>in a CLJ REPL.</p>
<p>I recommend any Clojure newbie to read the <a href="http://clojure.org/java_interop">Clojure Java Interop<br>chapter</a> to get all you need to know to interoperate with any plain<br>java lib that has not been wrapped in Clojure to make it usable in a more idiomatic and functional<br>way within Clojure.</p>
<p>The OpenCV Java API does not wrap the highgui module functionalities depending on Qt (e.g.<br>namedWindow and imshow. If you want to create windows and show images into them while interacting<br>with OpenCV from the REPL, at the moment you’re left at your own. You could use Java Swing to fill<br>the gap.</p>
<h3 id="License"><a href="#License" class="headerlink" title="License"></a>License</h3><p>Copyright © 2013 Giacomo (Mimmo) Cosenza aka Magomimmo</p>
<p>Distributed under the BSD 3-clause License, the same of OpenCV.</p>
