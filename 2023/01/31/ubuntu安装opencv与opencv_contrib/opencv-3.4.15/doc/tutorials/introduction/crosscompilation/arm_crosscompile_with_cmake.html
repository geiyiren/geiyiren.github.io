<h1 id="Cross-compilation-for-ARM-based-Linux-systems-tutorial-arm-crosscompile-with-cmake"><a href="#Cross-compilation-for-ARM-based-Linux-systems-tutorial-arm-crosscompile-with-cmake" class="headerlink" title="Cross compilation for ARM based Linux systems {#tutorial_arm_crosscompile_with_cmake}"></a>Cross compilation for ARM based Linux systems {#tutorial_arm_crosscompile_with_cmake}</h1><p>@prev_tutorial{tutorial_ios_install}<br>@next_tutorial{tutorial_building_tegra_cuda}</p>
<p>This steps are tested on Ubuntu Linux 12.04, but should work for other Linux distributions. I case<br>of other distributions package names and names of cross compilation tools may differ. There are<br>several popular EABI versions that are used on ARM platform. This tutorial is written for <em>gnueabi</em><br>and <em>gnueabihf</em>, but other variants should work with minimal changes.</p>
<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><ul>
<li>Host computer with Linux;</li>
<li>Git;</li>
<li>CMake 2.6 or higher;</li>
<li>Cross compilation tools for ARM: gcc, libstc++, etc. Depending on target platform you need to<br>choose <em>gnueabi</em> or <em>gnueabihf</em> tools. Install command for <em>gnueabi</em>:<br>@code{.bash}<br>sudo apt-get install gcc-arm-linux-gnueabi<br>@endcode<br>Install command for <em>gnueabihf</em>:<br>@code{.bash}<br>sudo apt-get install gcc-arm-linux-gnueabihf<br>@endcode</li>
<li>pkgconfig;</li>
<li>Python 2.6 for host system;</li>
<li>[optional] ffmpeg or libav development packages for armeabi(hf): libavcodec-dev,<br>libavformat-dev, libswscale-dev;</li>
<li>[optional] GTK+2.x or higher, including headers (libgtk2.0-dev) for armeabi(hf);</li>
<li>[optional] libdc1394 2.x;</li>
<li>[optional] libjpeg-dev, libpng-dev, libtiff-dev, libjasper-dev for armeabi(hf).</li>
</ul>
<h2 id="Getting-OpenCV-Source-Code"><a href="#Getting-OpenCV-Source-Code" class="headerlink" title="Getting OpenCV Source Code"></a>Getting OpenCV Source Code</h2><p>You can use the latest stable OpenCV version available in <em>sourceforge</em> or you can grab the latest<br>snapshot from our <a href="https://github.com/opencv/opencv.git">Git repository</a>.</p>
<h3 id="Getting-the-Latest-Stable-OpenCV-Version"><a href="#Getting-the-Latest-Stable-OpenCV-Version" class="headerlink" title="Getting the Latest Stable OpenCV Version"></a>Getting the Latest Stable OpenCV Version</h3><ul>
<li>Go to our <a href="http://sourceforge.net/projects/opencvlibrary">page on Sourceforge</a>;</li>
<li>Download the source tarball and unpack it.</li>
</ul>
<h3 id="Getting-the-Cutting-edge-OpenCV-from-the-Git-Repository"><a href="#Getting-the-Cutting-edge-OpenCV-from-the-Git-Repository" class="headerlink" title="Getting the Cutting-edge OpenCV from the Git Repository"></a>Getting the Cutting-edge OpenCV from the Git Repository</h3><p>Launch Git client and clone <a href="http://github.com/opencv/opencv">OpenCV repository</a></p>
<p>In Linux it can be achieved with the following command in Terminal:<br>@code{.bash}<br>cd ~&#x2F;<my_working _directory><br>git clone <a href="https://github.com/opencv/opencv.git">https://github.com/opencv/opencv.git</a><br>@endcode</p>
<h2 id="Building-OpenCV"><a href="#Building-OpenCV" class="headerlink" title="Building OpenCV"></a>Building OpenCV</h2><p>-#  Create a build directory, make it current and run the following command:<br>    @code{.bash}<br>    cmake [<some optional parameters>] -DCMAKE_TOOLCHAIN_FILE&#x3D;<path to the OpenCV source directory>&#x2F;platforms&#x2F;linux&#x2F;arm-gnueabi.toolchain.cmake <path to the OpenCV source directory><br>    @endcode<br>    Toolchain uses <em>gnueabihf</em> EABI convention by default. Add -DSOFTFP&#x3D;ON cmake argument to switch<br>    on softfp compiler.<br>    @code{.bash}<br>    cmake [<some optional parameters>] -DSOFTFP&#x3D;ON -DCMAKE_TOOLCHAIN_FILE&#x3D;<path to the OpenCV source directory>&#x2F;platforms&#x2F;linux&#x2F;arm-gnueabi.toolchain.cmake <path to the OpenCV source directory><br>    @endcode<br>    For example:<br>    @code{.bash}<br>    cd ~&#x2F;opencv&#x2F;platforms&#x2F;linux<br>    mkdir -p build_hardfp<br>    cd build_hardfp</p>
<pre><code>cmake -DCMAKE_TOOLCHAIN_FILE=../arm-gnueabi.toolchain.cmake ../../..
@endcode
</code></pre>
<p>-#  Run make in build (&lt;cmake_binary_dir&gt;) directory:<br>    @code{.bash}<br>    make<br>    @endcode</p>
<p>@note<br>Optionally you can strip symbols info from the created library via install&#x2F;strip make target.<br>This option produces smaller binary (~ twice smaller) but makes further debugging harder.</p>
<h3 id="Enable-hardware-optimizations"><a href="#Enable-hardware-optimizations" class="headerlink" title="Enable hardware optimizations"></a>Enable hardware optimizations</h3><p>Depending on target platform architecture different instruction sets can be used. By default<br>compiler generates code for armv5l without VFPv3 and NEON extensions. Add -DENABLE_VFPV3&#x3D;ON to<br>cmake command line to enable code generation for VFPv3 and -DENABLE_NEON&#x3D;ON for using NEON SIMD<br>extensions.</p>
<p>TBB is supported on multi core ARM SoCs also. Add -DWITH_TBB&#x3D;ON and -DBUILD_TBB&#x3D;ON to enable it.<br>Cmake scripts download TBB sources from official project site<br><a href="http://threadingbuildingblocks.org/">http://threadingbuildingblocks.org/</a> and build it.</p>
