<h1 id="OpenCV-iOS-Image-Processing-tutorial-image-manipulation"><a href="#OpenCV-iOS-Image-Processing-tutorial-image-manipulation" class="headerlink" title="OpenCV iOS - Image Processing {#tutorial_image_manipulation}"></a>OpenCV iOS - Image Processing {#tutorial_image_manipulation}</h1><p>@prev_tutorial{tutorial_hello}<br>@next_tutorial{tutorial_video_processing}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this tutorial we will learn how to do basic image processing using OpenCV in iOS.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In <em>OpenCV</em> all the image processing operations are usually carried out on the <em>Mat</em> structure. In<br>iOS however, to render an image on screen it have to be an instance of the <em>UIImage</em> class. To<br>convert an <em>OpenCV Mat</em> to an <em>UIImage</em> we use the <em>Core Graphics</em> framework available in iOS. Below<br>is the code needed to covert back and forth between Mat’s and UIImage’s.<br>@code{.m}</p>
<ul>
<li><p>(cv::Mat)cvMatFromUIImage:(UIImage *)image<br>{<br>CGColorSpaceRef colorSpace &#x3D; CGImageGetColorSpace(image.CGImage);<br>CGFloat cols &#x3D; image.size.width;<br>CGFloat rows &#x3D; image.size.height;</p>
<p>cv::Mat cvMat(rows, cols, CV_8UC4); &#x2F;&#x2F; 8 bits per component, 4 channels (color channels + alpha)</p>
<p>CGContextRef contextRef &#x3D; CGBitmapContextCreate(cvMat.data,                 &#x2F;&#x2F; Pointer to  data<br>                                           cols,                       &#x2F;&#x2F; Width of bitmap<br>                                           rows,                       &#x2F;&#x2F; Height of bitmap<br>                                           8,                          &#x2F;&#x2F; Bits per component<br>                                           cvMat.step[0],              &#x2F;&#x2F; Bytes per row<br>                                           colorSpace,                 &#x2F;&#x2F; Colorspace<br>                                           kCGImageAlphaNoneSkipLast |<br>                                           kCGBitmapByteOrderDefault); &#x2F;&#x2F; Bitmap info flags<br>CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), image.CGImage);<br>CGContextRelease(contextRef);</p>
<p>return cvMat;</p>
</li>
</ul>
<p>}<br>@endcode<br>@code{.m}</p>
<ul>
<li><p>(cv::Mat)cvMatGrayFromUIImage:(UIImage *)image<br>{<br>CGColorSpaceRef colorSpace &#x3D; CGImageGetColorSpace(image.CGImage);<br>CGFloat cols &#x3D; image.size.width;<br>CGFloat rows &#x3D; image.size.height;</p>
<p>cv::Mat cvMat(rows, cols, CV_8UC1); &#x2F;&#x2F; 8 bits per component, 1 channels</p>
<p>CGContextRef contextRef &#x3D; CGBitmapContextCreate(cvMat.data,                 &#x2F;&#x2F; Pointer to data<br>                                           cols,                       &#x2F;&#x2F; Width of bitmap<br>                                           rows,                       &#x2F;&#x2F; Height of bitmap<br>                                           8,                          &#x2F;&#x2F; Bits per component<br>                                           cvMat.step[0],              &#x2F;&#x2F; Bytes per row<br>                                           colorSpace,                 &#x2F;&#x2F; Colorspace<br>                                           kCGImageAlphaNoneSkipLast |<br>                                           kCGBitmapByteOrderDefault); &#x2F;&#x2F; Bitmap info flags<br>CGContextDrawImage(contextRef, CGRectMake(0, 0, cols, rows), image.CGImage);<br>CGContextRelease(contextRef);</p>
<p>return cvMat;</p>
</li>
</ul>
<p> }<br>@endcode<br>After the processing we need to convert it back to UIImage. The code below can handle both<br>gray-scale and color image conversions (determined by the number of channels in the <em>if</em> statement).<br>@code{.m}<br>cv::Mat greyMat;<br>cv::cvtColor(inputMat, greyMat, COLOR_BGR2GRAY);<br>@endcode<br>After the processing we need to convert it back to UIImage.<br>@code{.m}<br>-(UIImage *)UIImageFromCVMat:(cv::Mat)cvMat<br>{<br>  NSData *data &#x3D; [NSData dataWithBytes:cvMat.data length:cvMat.elemSize()*cvMat.total()];<br>  CGColorSpaceRef colorSpace;</p>
<p>  if (cvMat.elemSize() &#x3D;&#x3D; 1) {<br>      colorSpace &#x3D; CGColorSpaceCreateDeviceGray();<br>  } else {<br>      colorSpace &#x3D; CGColorSpaceCreateDeviceRGB();<br>  }</p>
<p>  CGDataProviderRef provider &#x3D; CGDataProviderCreateWithCFData((__bridge CFDataRef)data);</p>
<p>  &#x2F;&#x2F; Creating CGImage from cv::Mat<br>  CGImageRef imageRef &#x3D; CGImageCreate(cvMat.cols,                                 &#x2F;&#x2F;width<br>                                     cvMat.rows,                                 &#x2F;&#x2F;height<br>                                     8,                                          &#x2F;&#x2F;bits per component<br>                                     8 * cvMat.elemSize(),                       &#x2F;&#x2F;bits per pixel<br>                                     cvMat.step[0],                            &#x2F;&#x2F;bytesPerRow<br>                                     colorSpace,                                 &#x2F;&#x2F;colorspace<br>                                     kCGImageAlphaNone|kCGBitmapByteOrderDefault,&#x2F;&#x2F; bitmap info<br>                                     provider,                                   &#x2F;&#x2F;CGDataProviderRef<br>                                     NULL,                                       &#x2F;&#x2F;decode<br>                                     false,                                      &#x2F;&#x2F;should interpolate<br>                                     kCGRenderingIntentDefault                   &#x2F;&#x2F;intent<br>                                     );</p>
<p>  &#x2F;&#x2F; Getting UIImage from CGImage<br>  UIImage *finalImage &#x3D; [UIImage imageWithCGImage:imageRef];<br>  CGImageRelease(imageRef);<br>  CGDataProviderRelease(provider);<br>  CGColorSpaceRelease(colorSpace);</p>
<p>  return finalImage;<br> }<br>@endcode</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p><img src="/images/output.jpg"></p>
<p>Check out an instance of running code with more Image Effects on<br><a href="http://www.youtube.com/watch?v=Ko3K_xdhJ1I">YouTube</a> .</p>
<p>@youtube{Ko3K_xdhJ1I}</p>
