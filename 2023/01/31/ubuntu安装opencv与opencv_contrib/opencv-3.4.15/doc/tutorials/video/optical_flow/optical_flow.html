<h1 id="Optical-Flow-tutorial-optical-flow"><a href="#Optical-Flow-tutorial-optical-flow" class="headerlink" title="Optical Flow {#tutorial_optical_flow}"></a>Optical Flow {#tutorial_optical_flow}</h1><p>@prev_tutorial{tutorial_meanshift}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this chapter,<br>    -   We will understand the concepts of optical flow and its estimation using Lucas-Kanade<br>        method.<br>    -   We will use functions like <strong>cv.calcOpticalFlowPyrLK()</strong> to track feature points in a<br>        video.<br>    -   We will create a dense optical flow field using the <strong>cv.calcOpticalFlowFarneback()</strong> method.</p>
<h2 id="Optical-Flow"><a href="#Optical-Flow" class="headerlink" title="Optical Flow"></a>Optical Flow</h2><p>Optical flow is the pattern of apparent motion of image objects between two consecutive frames<br>caused by the movement of object or camera. It is 2D vector field where each vector is a<br>displacement vector showing the movement of points from first frame to second. Consider the image<br>below (Image Courtesy: <a href="http://en.wikipedia.org/wiki/Optical_flow">Wikipedia article on Optical Flow</a>).</p>
<p><img src="/images/optical_flow_basic1.jpg" alt="image"></p>
<p>It shows a ball moving in 5 consecutive frames. The arrow shows its displacement vector. Optical<br>flow has many applications in areas like :</p>
<ul>
<li>Structure from Motion</li>
<li>Video Compression</li>
<li>Video Stabilization …</li>
</ul>
<p>Optical flow works on several assumptions:</p>
<p>-#  The pixel intensities of an object do not change between consecutive frames.<br>2.  Neighbouring pixels have similar motion.</p>
<p>Consider a pixel \f$I(x,y,t)\f$ in first frame (Check a new dimension, time, is added here. Earlier we<br>were working with images only, so no need of time). It moves by distance \f$(dx,dy)\f$ in next frame<br>taken after \f$dt\f$ time. So since those pixels are the same and intensity does not change, we can say,</p>
<p>\f[I(x,y,t) &#x3D; I(x+dx, y+dy, t+dt)\f]</p>
<p>Then take taylor series approximation of right-hand side, remove common terms and divide by \f$dt\f$ to<br>get the following equation:</p>
<p>\f[f_x u + f_y v + f_t &#x3D; 0 ;\f]</p>
<p>where:</p>
<p>\f[f_x &#x3D; \frac{\partial f}{\partial x} ; ; ; f_y &#x3D; \frac{\partial f}{\partial y}\f]\f[u &#x3D; \frac{dx}{dt} ; ; ; v &#x3D; \frac{dy}{dt}\f]</p>
<p>Above equation is called Optical Flow equation. In it, we can find \f$f_x\f$ and \f$f_y\f$, they are image<br>gradients. Similarly \f$f_t\f$ is the gradient along time. But \f$(u,v)\f$ is unknown. We cannot solve this<br>one equation with two unknown variables. So several methods are provided to solve this problem and<br>one of them is Lucas-Kanade.</p>
<h3 id="Lucas-Kanade-method"><a href="#Lucas-Kanade-method" class="headerlink" title="Lucas-Kanade method"></a>Lucas-Kanade method</h3><p>We have seen an assumption before, that all the neighbouring pixels will have similar motion.<br>Lucas-Kanade method takes a 3x3 patch around the point. So all the 9 points have the same motion. We<br>can find \f$(f_x, f_y, f_t)\f$ for these 9 points. So now our problem becomes solving 9 equations with<br>two unknown variables which is over-determined. A better solution is obtained with least square fit<br>method. Below is the final solution which is two equation-two unknown problem and solve to get the<br>solution.</p>
<p>\f[\begin{bmatrix} u \ v \end{bmatrix} &#x3D;<br>\begin{bmatrix}<br>    \sum_{i}{f_{x_i}}^2  &amp;  \sum_{i}{f_{x_i} f_{y_i} } \<br>    \sum_{i}{f_{x_i} f_{y_i}} &amp; \sum_{i}{f_{y_i}}^2<br>\end{bmatrix}^{-1}<br>\begin{bmatrix}<br>    - \sum_{i}{f_{x_i} f_{t_i}} \<br>    - \sum_{i}{f_{y_i} f_{t_i}}<br>\end{bmatrix}\f]</p>
<p>( Check similarity of inverse matrix with Harris corner detector. It denotes that corners are better<br>points to be tracked.)</p>
<p>So from the user point of view, the idea is simple, we give some points to track, we receive the optical<br>flow vectors of those points. But again there are some problems. Until now, we were dealing with<br>small motions, so it fails when there is a large motion. To deal with this we use pyramids. When we go up in<br>the pyramid, small motions are removed and large motions become small motions. So by applying<br>Lucas-Kanade there, we get optical flow along with the scale.</p>
<h2 id="Lucas-Kanade-Optical-Flow-in-OpenCV"><a href="#Lucas-Kanade-Optical-Flow-in-OpenCV" class="headerlink" title="Lucas-Kanade Optical Flow in OpenCV"></a>Lucas-Kanade Optical Flow in OpenCV</h2><p>OpenCV provides all these in a single function, <strong>cv.calcOpticalFlowPyrLK()</strong>. Here, we create a<br>simple application which tracks some points in a video. To decide the points, we use<br><strong>cv.goodFeaturesToTrack()</strong>. We take the first frame, detect some Shi-Tomasi corner points in it,<br>then we iteratively track those points using Lucas-Kanade optical flow. For the function<br><strong>cv.calcOpticalFlowPyrLK()</strong> we pass the previous frame, previous points and next frame. It<br>returns next points along with some status numbers which has a value of 1 if next point is found,<br>else zero. We iteratively pass these next points as previous points in next step. See the code<br>below:</p>
<p>@add_toggle_cpp</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/video/optical_flow/optical_flow.cpp">here</a></p>
</li>
<li><p><strong>Code at glance:</strong><br>@include samples&#x2F;cpp&#x2F;tutorial_code&#x2F;video&#x2F;optical_flow&#x2F;optical_flow.cpp<br>@end_toggle</p>
</li>
</ul>
<p>@add_toggle_python</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/python/tutorial_code/video/optical_flow/optical_flow.py">here</a></p>
</li>
<li><p><strong>Code at glance:</strong><br>@include samples&#x2F;python&#x2F;tutorial_code&#x2F;video&#x2F;optical_flow&#x2F;optical_flow.py<br>@end_toggle</p>
</li>
</ul>
<p>@add_toggle_java</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/java/tutorial_code/video/optical_flow/OpticalFlowDemo.java">here</a></p>
</li>
<li><p><strong>Code at glance:</strong><br>@include samples&#x2F;java&#x2F;tutorial_code&#x2F;video&#x2F;optical_flow&#x2F;OpticalFlowDemo.java<br>@end_toggle</p>
</li>
</ul>
<p>(This code doesn’t check how correct are the next keypoints. So even if any feature point disappears<br>in image, there is a chance that optical flow finds the next point which may look close to it. So<br>actually for a robust tracking, corner points should be detected in particular intervals. OpenCV<br>samples comes up with such a sample which finds the feature points at every 5 frames. It also run a<br>backward-check of the optical flow points got to select only good ones. Check<br>samples&#x2F;python&#x2F;lk_track.py).</p>
<p>See the results we got:</p>
<p><img src="/images/opticalflow_lk.jpg" alt="image"></p>
<h2 id="Dense-Optical-Flow-in-OpenCV"><a href="#Dense-Optical-Flow-in-OpenCV" class="headerlink" title="Dense Optical Flow in OpenCV"></a>Dense Optical Flow in OpenCV</h2><p>Lucas-Kanade method computes optical flow for a sparse feature set (in our example, corners detected<br>using Shi-Tomasi algorithm). OpenCV provides another algorithm to find the dense optical flow. It<br>computes the optical flow for all the points in the frame. It is based on Gunner Farneback’s<br>algorithm which is explained in “Two-Frame Motion Estimation Based on Polynomial Expansion” by<br>Gunner Farneback in 2003.</p>
<p>Below sample shows how to find the dense optical flow using above algorithm. We get a 2-channel<br>array with optical flow vectors, \f$(u,v)\f$. We find their magnitude and direction. We color code the<br>result for better visualization. Direction corresponds to Hue value of the image. Magnitude<br>corresponds to Value plane. See the code below:</p>
<p>@add_toggle_cpp</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/video/optical_flow/optical_flow_dense.cpp">here</a></p>
</li>
<li><p><strong>Code at glance:</strong><br>@include samples&#x2F;cpp&#x2F;tutorial_code&#x2F;video&#x2F;optical_flow&#x2F;optical_flow_dense.cpp<br>@end_toggle</p>
</li>
</ul>
<p>@add_toggle_python</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/python/tutorial_code/video/optical_flow/optical_flow_dense.py">here</a></p>
</li>
<li><p><strong>Code at glance:</strong><br>@include samples&#x2F;python&#x2F;tutorial_code&#x2F;video&#x2F;optical_flow&#x2F;optical_flow_dense.py<br>@end_toggle</p>
</li>
</ul>
<p>@add_toggle_java</p>
<ul>
<li><p><strong>Downloadable code</strong>: Click<br><a href="https://github.com/opencv/opencv/tree/3.4/samples/java/tutorial_code/video/optical_flow/OpticalFlowDenseDemo.java">here</a></p>
</li>
<li><p><strong>Code at glance:</strong><br>@include samples&#x2F;java&#x2F;tutorial_code&#x2F;video&#x2F;optical_flow&#x2F;OpticalFlowDenseDemo.java<br>@end_toggle</p>
</li>
</ul>
<p>See the result below:</p>
<p><img src="/images/opticalfb.jpg" alt="image"></p>
