<h1 id="Creating-a-video-with-OpenCV-tutorial-video-write"><a href="#Creating-a-video-with-OpenCV-tutorial-video-write" class="headerlink" title="Creating a video with OpenCV {#tutorial_video_write}"></a>Creating a video with OpenCV {#tutorial_video_write}</h1><p>@prev_tutorial{tutorial_video_input_psnr_ssim}<br>@next_tutorial{tutorial_kinect_openni}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>Whenever you work with video feeds you may eventually want to save your image processing result in a<br>form of a new video file. For simple video outputs you can use the OpenCV built-in @ref cv::VideoWriter<br>class, designed for this.</p>
<ul>
<li>How to create a video file with OpenCV</li>
<li>What type of video files you can create with OpenCV</li>
<li>How to extract a given color channel from a video</li>
</ul>
<p>As a simple demonstration I’ll just extract one of the BGR color channels of an input video file<br>into a new video. You can control the flow of the application from its console line arguments:</p>
<ul>
<li>The first argument points to the video file to work on</li>
<li>The second argument may be one of the characters: R G B. This will specify which of the channels<br>to extract.</li>
<li>The last argument is the character Y (Yes) or N (No). If this is no, the codec used for the<br>input video file will be the same as for the output. Otherwise, a window will pop up and allow<br>you to select yourself the codec to use.</li>
</ul>
<h2 id="For-example-a-valid-command-line-would-look-like-code-bash-video-write-exe-video-x2F-Megamind-avi-R-Y-endcodeThe-source-code"><a href="#For-example-a-valid-command-line-would-look-like-code-bash-video-write-exe-video-x2F-Megamind-avi-R-Y-endcodeThe-source-code" class="headerlink" title="For example, a valid command line would look like:@code{.bash}video-write.exe video&#x2F;Megamind.avi R Y@endcodeThe source code"></a>For example, a valid command line would look like:<br>@code{.bash}<br>video-write.exe video&#x2F;Megamind.avi R Y<br>@endcode<br>The source code</h2><p>You may also find the source code and these video file in the<br><code>samples/cpp/tutorial_code/videoio/video-write/</code> folder of the OpenCV source library or <a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/videoio/video-write/video-write.cpp">download it<br>from here </a>.</p>
<p>@include cpp&#x2F;tutorial_code&#x2F;videoio&#x2F;video-write&#x2F;video-write.cpp</p>
<h2 id="The-structure-of-a-video"><a href="#The-structure-of-a-video" class="headerlink" title="The structure of a video"></a>The structure of a video</h2><p>For start, you should have an idea of just how a video file looks. Every video file in itself is a<br>container. The type of the container is expressed in the files extension (for example <em>avi</em>, <em>mov</em><br>or <em>mkv</em>). This contains multiple elements like: video feeds, audio feeds or other tracks (like for<br>example subtitles). How these feeds are stored is determined by the codec used for each one of them.<br>In case of the audio tracks commonly used codecs are <em>mp3</em> or <em>aac</em>. For the video files the list is<br>somehow longer and includes names such as <em>XVID</em>, <em>DIVX</em>, <em>H264</em> or <em>LAGS</em> (<em>Lagarith Lossless<br>Codec</em>). The full list of codecs you may use on a system depends on just what one you have<br>installed.</p>
<p><img src="/images/videoFileStructure.png"></p>
<p>As you can see things can get really complicated with videos. However, OpenCV is mainly a computer<br>vision library, not a video stream, codec and write one. Therefore, the developers tried to keep<br>this part as simple as possible. Due to this OpenCV for video containers supports only the <em>avi</em><br>extension, its first version. A direct limitation of this is that you cannot save a video file<br>larger than 2 GB. Furthermore you can only create and expand a single video track inside the<br>container. No audio or other track editing support here. Nevertheless, any video codec present on<br>your system might work. If you encounter some of these limitations you will need to look into more<br>specialized video writing libraries such as <em>FFmpeg</em> or codecs as <em>HuffYUV</em>, <em>CorePNG</em> and <em>LCL</em>. As<br>an alternative, create the video track with OpenCV and expand it with sound tracks or convert it to<br>other formats by using video manipulation programs such as <em>VirtualDub</em> or <em>AviSynth</em>.</p>
<h2 id="The-VideoWriter-class"><a href="#The-VideoWriter-class" class="headerlink" title="The VideoWriter class"></a>The VideoWriter class</h2><p>The content written here builds on the assumption you<br>already read the @ref tutorial_video_input_psnr_ssim tutorial and you know how to read video files. To create a<br>video file you just need to create an instance of the @ref cv::VideoWriter class. You can specify<br>its properties either via parameters in the constructor or later on via the @ref cv::VideoWriter::open function.<br>Either way, the parameters are the same: 1. The name of the output that contains the container type<br>in its extension. At the moment only <em>avi</em> is supported. We construct this from the input file, add<br>to this the name of the channel to use, and finish it off with the container extension.<br>@code{.cpp}<br>const string source      &#x3D; argv[1];            &#x2F;&#x2F; the source file name<br>string::size_type pAt &#x3D; source.find_last_of(‘.’);   &#x2F;&#x2F; Find extension point<br>const string NAME &#x3D; source.substr(0, pAt) + argv[2][0] + “.avi”;   &#x2F;&#x2F; Form the new name with container<br>@endcode<br>-#  The codec to use for the video track. Now all the video codecs have a unique short name of<br>    maximum four characters. Hence, the <em>XVID</em>, <em>DIVX</em> or <em>H264</em> names. This is called a four<br>    character code. You may also ask this from an input video by using its <em>get</em> function. Because<br>    the <em>get</em> function is a general function it always returns double values. A double value is<br>    stored on 64 bits. Four characters are four bytes, meaning 32 bits. These four characters are<br>    coded in the lower 32 bits of the <em>double</em>. A simple way to throw away the upper 32 bits would<br>    be to just convert this value to <em>int</em>:<br>    @code{.cpp}<br>    VideoCapture inputVideo(source);                                &#x2F;&#x2F; Open input<br>    int ex &#x3D; static_cast<int>(inputVideo.get(CAP_PROP_FOURCC));     &#x2F;&#x2F; Get Codec Type- Int form<br>    @endcode<br>    OpenCV internally works with this integer type and expect this as its second parameter. Now to<br>    convert from the integer form to string we may use two methods: a bitwise operator and a union<br>    method. The first one extracting from an int the characters looks like (an “and” operation, some<br>    shifting and adding a 0 at the end to close the string):<br>    @code{.cpp}<br>    char EXT[] &#x3D; {ex &amp; 0XFF , (ex &amp; 0XFF00) &gt;&gt; 8,(ex &amp; 0XFF0000) &gt;&gt; 16,(ex &amp; 0XFF000000) &gt;&gt; 24, 0};<br>    @endcode<br>    You can do the same thing with the <em>union</em> as:<br>    @code{.cpp}<br>    union { int v; char c[5];} uEx ;<br>    uEx.v &#x3D; ex;                              &#x2F;&#x2F; From Int to char via union<br>    uEx.c[4]&#x3D;’\0’;<br>    @endcode<br>    The advantage of this is that the conversion is done automatically after assigning, while for<br>    the bitwise operator you need to do the operations whenever you change the codec type. In case<br>    you know the codecs four character code beforehand, you can use the <em>CV_FOURCC</em> macro to build<br>    the integer:<br>    @code{.cpp}<br>    CV_FOURCC(‘P’,’I’,’M,’1’) &#x2F;&#x2F; this is an MPEG1 codec from the characters to integer<br>    @endcode<br>    If you pass for this argument minus one then a window will pop up at runtime that contains all<br>    the codec installed on your system and ask you to select the one to use:</p>
<pre><code>![](images/videoCompressSelect.png)
</code></pre>
<p>-#  The frame per second for the output video. Again, here I keep the input videos frame per second<br>    by using the <em>get</em> function.<br>-#  The size of the frames for the output video. Here too I keep the input videos frame size per<br>    second by using the <em>get</em> function.<br>-#  The final argument is an optional one. By default is true and says that the output will be a<br>    colorful one (so for write you will send three channel images). To create a gray scale video<br>    pass a false parameter here.</p>
<p>Here it is, how I use it in the sample:<br>@code{.cpp}<br>VideoWriter outputVideo;<br>Size S &#x3D; Size((int) inputVideo.get(CAP_PROP_FRAME_WIDTH),    &#x2F;&#x2F;Acquire input size<br>              (int) inputVideo.get(CAP_PROP_FRAME_HEIGHT));<br>outputVideo.open(NAME , ex, inputVideo.get(CAP_PROP_FPS),S, true);<br>@endcode<br>Afterwards, you use the @ref cv::VideoWriter::isOpened() function to find out if the open operation succeeded or<br>not. The video file automatically closes when the <em>VideoWriter</em> object is destroyed. After you open<br>the object with success you can send the frames of the video in a sequential order by using the<br>@ref cv::VideoWriter::write function of the class. Alternatively, you can use its overloaded operator &lt;&lt; :<br>@code{.cpp}<br>outputVideo.write(res);  &#x2F;&#x2F;or<br>outputVideo &lt;&lt; res;<br>@endcode<br>Extracting a color channel from an BGR image means to set to zero the BGR values of the other<br>channels. You can either do this with image scanning operations or by using the split and merge<br>operations. You first split the channels up into different images, set the other channels to zero<br>images of the same size and type and finally merge them back:<br>@code{.cpp}<br>split(src, spl);                 &#x2F;&#x2F; process - extract only the correct channel<br>for( int i &#x3D;0; i &lt; 3; ++i)<br>   if (i !&#x3D; channel)<br>      spl[i] &#x3D; Mat::zeros(S, spl[0].type());<br>merge(spl, res);<br>@endcode<br>Put all this together and you’ll get the upper source code, whose runtime result will show something<br>around the idea:</p>
<p><img src="/images/resultOutputWideoWrite.png"></p>
<p>You may observe a runtime instance of this on the <a href="https://www.youtube.com/watch?v=jpBwHxsl1_0">YouTube<br>here</a>.</p>
<p>@youtube{jpBwHxsl1_0}</p>
