<h1 id="Transformations-tutorial-transformations"><a href="#Transformations-tutorial-transformations" class="headerlink" title="Transformations {#tutorial_transformations}"></a>Transformations {#tutorial_transformations}</h1><p>@prev_tutorial{tutorial_widget_pose}<br>@next_tutorial{tutorial_creating_widgets}</p>
<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>In this tutorial you will learn how to</p>
<ul>
<li>How to use makeTransformToGlobal to compute pose</li>
<li>How to use makeCameraPose and Viz3d::setViewerPose</li>
<li>How to visualize camera position by axes and by viewing frustum</li>
</ul>
<h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><p>You can download the code from <a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code/viz/transformations.cpp">here </a>.<br>@include samples&#x2F;cpp&#x2F;tutorial_code&#x2F;viz&#x2F;transformations.cpp</p>
<h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><p>Here is the general structure of the program:</p>
<ul>
<li><p>Create a visualization window.<br>@code{.cpp}<br>&#x2F;&#x2F;&#x2F; Create a window<br>viz::Viz3d myWindow(“Transformations”);<br>@endcode</p>
</li>
<li><p>Get camera pose from camera position, camera focal point and y direction.<br>@code{.cpp}<br>&#x2F;&#x2F;&#x2F; Let’s assume camera has the following properties<br>Point3f cam_pos(3.0f,3.0f,3.0f), cam_focal_point(3.0f,3.0f,2.0f), cam_y_dir(-1.0f,0.0f,0.0f);</p>
<p>&#x2F;&#x2F;&#x2F; We can get the pose of the cam using makeCameraPose<br>Affine3f cam_pose &#x3D; viz::makeCameraPose(cam_pos, cam_focal_point, cam_y_dir);<br>@endcode</p>
</li>
<li><p>Obtain transform matrix knowing the axes of camera coordinate system.<br>@code{.cpp}<br>&#x2F;&#x2F;&#x2F; We can get the transformation matrix from camera coordinate system to global using<br>&#x2F;&#x2F;&#x2F; - makeTransformToGlobal. We need the axes of the camera<br>Affine3f transform &#x3D; viz::makeTransformToGlobal(Vec3f(0.0f,-1.0f,0.0f), Vec3f(-1.0f,0.0f,0.0f), Vec3f(0.0f,0.0f,-1.0f), cam_pos);<br>@endcode</p>
</li>
<li><p>Create a cloud widget from bunny.ply file<br>@code{.cpp}<br>&#x2F;&#x2F;&#x2F; Create a cloud widget.<br>Mat bunny_cloud &#x3D; cvcloud_load();<br>viz::WCloud cloud_widget(bunny_cloud, viz::Color::green());<br>@endcode</p>
</li>
<li><p>Given the pose in camera coordinate system, estimate the global pose.<br>@code{.cpp}<br>&#x2F;&#x2F;&#x2F; Pose of the widget in camera frame<br>Affine3f cloud_pose &#x3D; Affine3f().translate(Vec3f(0.0f,0.0f,3.0f));<br>&#x2F;&#x2F;&#x2F; Pose of the widget in global frame<br>Affine3f cloud_pose_global &#x3D; transform * cloud_pose;<br>@endcode</p>
</li>
<li><p>If the view point is set to be global, visualize camera coordinate frame and viewing frustum.<br>@code{.cpp}<br>&#x2F;&#x2F;&#x2F; Visualize camera frame<br>if (!camera_pov)<br>{<br>viz::WCameraPosition cpw(0.5); &#x2F;&#x2F; Coordinate axes<br>viz::WCameraPosition cpw_frustum(Vec2f(0.889484, 0.523599)); &#x2F;&#x2F; Camera frustum<br>myWindow.showWidget(“CPW”, cpw, cam_pose);<br>myWindow.showWidget(“CPW_FRUSTUM”, cpw_frustum, cam_pose);<br>}<br>@endcode</p>
</li>
<li><p>Visualize the cloud widget with the estimated global pose<br>@code{.cpp}<br>&#x2F;&#x2F;&#x2F; Visualize widget<br>myWindow.showWidget(“bunny”, cloud_widget, cloud_pose_global);<br>@endcode</p>
</li>
<li><p>If the view point is set to be camera’s, set viewer pose to <strong>cam_pose</strong>.<br>@code{.cpp}<br>&#x2F;&#x2F;&#x2F; Set the viewer pose to that of camera<br>if (camera_pov)<br>myWindow.setViewerPose(cam_pose);<br>@endcode</p>
</li>
</ul>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p>-#  Here is the result from the camera point of view.</p>
<pre><code>![](images/camera_view_point.png)
</code></pre>
<p>-#  Here is the result from global point of view.</p>
<pre><code>![](images/global_view_point.png)
</code></pre>
