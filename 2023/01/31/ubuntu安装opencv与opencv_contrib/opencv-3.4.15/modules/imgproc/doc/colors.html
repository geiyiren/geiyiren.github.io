<h1 id="Color-conversions-imgproc-color-conversions"><a href="#Color-conversions-imgproc-color-conversions" class="headerlink" title="Color conversions {#imgproc_color_conversions}"></a>Color conversions {#imgproc_color_conversions}</h1><p>See cv::cvtColor and cv::ColorConversionCodes<br>@todo document other conversion modes</p>
<h2 id="anchor-color-convert-rgb-grayRGB-f-leftrightarrow-f-GRAY"><a href="#anchor-color-convert-rgb-grayRGB-f-leftrightarrow-f-GRAY" class="headerlink" title="@anchor color_convert_rgb_grayRGB \f$\leftrightarrow\f$ GRAY"></a>@anchor color_convert_rgb_gray<br>RGB \f$\leftrightarrow\f$ GRAY</h2><p>Transformations within RGB space like adding&#x2F;removing the alpha channel, reversing the channel<br>order, conversion to&#x2F;from 16-bit RGB color (R5:G6:B5 or R5:G5:B5), as well as conversion<br>to&#x2F;from grayscale using:<br>\f[\text{RGB[A] to Gray:} \quad Y  \leftarrow 0.299  \cdot R + 0.587  \cdot G + 0.114  \cdot B\f]<br>and<br>\f[\text{Gray to RGB[A]:} \quad R  \leftarrow Y, G  \leftarrow Y, B  \leftarrow Y, A  \leftarrow \max (ChannelRange)\f]<br>The conversion from a RGB image to gray is done with:<br>@code<br>    cvtColor(src, bwsrc, cv::COLOR_RGB2GRAY);<br>@endcode<br>More advanced channel reordering can also be done with cv::mixChannels.<br>@see cv::COLOR_BGR2GRAY, cv::COLOR_RGB2GRAY, cv::COLOR_GRAY2BGR, cv::COLOR_GRAY2RGB</p>
<h2 id="anchor-color-convert-rgb-xyzRGB-f-leftrightarrow-f-CIE-XYZ-Rec-709-with-D65-white-point"><a href="#anchor-color-convert-rgb-xyzRGB-f-leftrightarrow-f-CIE-XYZ-Rec-709-with-D65-white-point" class="headerlink" title="@anchor color_convert_rgb_xyzRGB \f$\leftrightarrow\f$ CIE XYZ.Rec 709 with D65 white point"></a>@anchor color_convert_rgb_xyz<br>RGB \f$\leftrightarrow\f$ CIE XYZ.Rec 709 with D65 white point</h2><p>\f[\begin{bmatrix} X  \ Y  \ Z<br>  \end{bmatrix} \leftarrow \begin{bmatrix} 0.412453 &amp; 0.357580 &amp; 0.180423 \ 0.212671 &amp; 0.715160 &amp; 0.072169 \ 0.019334 &amp; 0.119193 &amp; 0.950227<br>  \end{bmatrix} \cdot \begin{bmatrix} R  \ G  \ B<br>  \end{bmatrix}\f]<br>\f[\begin{bmatrix} R  \ G  \ B<br>  \end{bmatrix} \leftarrow \begin{bmatrix} 3.240479 &amp; -1.53715 &amp; -0.498535 \ -0.969256 &amp;  1.875991 &amp; 0.041556 \ 0.055648 &amp; -0.204043 &amp; 1.057311<br>  \end{bmatrix} \cdot \begin{bmatrix} X  \ Y  \ Z<br>  \end{bmatrix}\f]<br>\f$X\f$, \f$Y\f$ and \f$Z\f$ cover the whole value range (in case of floating-point images, \f$Z\f$ may exceed 1).</p>
<p>@see cv::COLOR_BGR2XYZ, cv::COLOR_RGB2XYZ, cv::COLOR_XYZ2BGR, cv::COLOR_XYZ2RGB</p>
<h2 id="anchor-color-convert-rgb-ycrcbRGB-f-leftrightarrow-f-YCrCb-JPEG-or-YCC"><a href="#anchor-color-convert-rgb-ycrcbRGB-f-leftrightarrow-f-YCrCb-JPEG-or-YCC" class="headerlink" title="@anchor color_convert_rgb_ycrcbRGB \f$\leftrightarrow\f$ YCrCb JPEG (or YCC)"></a>@anchor color_convert_rgb_ycrcb<br>RGB \f$\leftrightarrow\f$ YCrCb JPEG (or YCC)</h2><p>\f[Y  \leftarrow 0.299  \cdot R + 0.587  \cdot G + 0.114  \cdot B\f]<br>\f[Cr  \leftarrow (R-Y)  \cdot 0.713 + delta\f]<br>\f[Cb  \leftarrow (B-Y)  \cdot 0.564 + delta\f]<br>\f[R  \leftarrow Y + 1.403  \cdot (Cr - delta)\f]<br>\f[G  \leftarrow Y - 0.714  \cdot (Cr - delta) - 0.344  \cdot (Cb - delta)\f]<br>\f[B  \leftarrow Y + 1.773  \cdot (Cb - delta)\f]<br>where<br>\f[delta &#x3D;  \left { \begin{array}{l l} 128 &amp;  \mbox{for 8-bit images} \ 32768 &amp;  \mbox{for 16-bit images} \ 0.5 &amp;  \mbox{for floating-point images} \end{array} \right .\f]<br>Y, Cr, and Cb cover the whole value range.<br>@see cv::COLOR_BGR2YCrCb, cv::COLOR_RGB2YCrCb, cv::COLOR_YCrCb2BGR, cv::COLOR_YCrCb2RGB</p>
<h2 id="anchor-color-convert-rgb-hsvRGB-f-leftrightarrow-f-HSV"><a href="#anchor-color-convert-rgb-hsvRGB-f-leftrightarrow-f-HSV" class="headerlink" title="@anchor color_convert_rgb_hsvRGB \f$\leftrightarrow\f$ HSV"></a>@anchor color_convert_rgb_hsv<br>RGB \f$\leftrightarrow\f$ HSV</h2><p>In case of 8-bit and 16-bit images, R, G, and B are converted to the floating-point format and<br>scaled to fit the 0 to 1 range.</p>
<p>\f[V  \leftarrow max(R,G,B)\f]<br>\f[S  \leftarrow \fork{\frac{V-min(R,G,B)}{V}}{if (V \neq 0)}{0}{otherwise}\f]<br>\f[H  \leftarrow \forkfour{{60(G - B)}&#x2F;{(V-min(R,G,B))}}{if (V&#x3D;R)}<br>  {{120+60(B - R)}&#x2F;{(V-min(R,G,B))}}{if (V&#x3D;G)}<br>  {{240+60(R - G)}&#x2F;{(V-min(R,G,B))}}{if (V&#x3D;B)}<br>  {0}{if  (R&#x3D;G&#x3D;B)}\f]<br>If \f$H&lt;0\f$ then \f$H \leftarrow H+360\f$ . On output \f$0 \leq V \leq 1\f$, \f$0 \leq S \leq 1\f$,<br>\f$0 \leq H \leq 360\f$ .</p>
<p>The values are then converted to the destination data type:</p>
<ul>
<li>8-bit images: \f$V  \leftarrow 255 V, S  \leftarrow 255 S, H  \leftarrow H&#x2F;2  \text{(to fit to 0 to 255)}\f$</li>
<li>16-bit images: (currently not supported) \f$V &lt;- 65535 V, S &lt;- 65535 S, H &lt;- H\f$</li>
<li>32-bit images: H, S, and V are left as is</li>
</ul>
<p>@see cv::COLOR_BGR2HSV, cv::COLOR_RGB2HSV, cv::COLOR_HSV2BGR, cv::COLOR_HSV2RGB</p>
<h2 id="anchor-color-convert-rgb-hlsRGB-f-leftrightarrow-f-HLS"><a href="#anchor-color-convert-rgb-hlsRGB-f-leftrightarrow-f-HLS" class="headerlink" title="@anchor color_convert_rgb_hlsRGB \f$\leftrightarrow\f$ HLS"></a>@anchor color_convert_rgb_hls<br>RGB \f$\leftrightarrow\f$ HLS</h2><p>In case of 8-bit and 16-bit images, R, G, and B are converted to the floating-point format and<br>scaled to fit the 0 to 1 range.</p>
<p>\f[V_{max}  \leftarrow {max}(R,G,B)\f]<br>\f[V_{min}  \leftarrow {min}(R,G,B)\f]<br>\f[L  \leftarrow \frac{V_{max} + V_{min}}{2}\f]<br>\f[S  \leftarrow \fork { \frac{V_{max} - V_{min}}{V_{max} + V_{min}} }{if  (L &lt; 0.5) }<br>    { \frac{V_{max} - V_{min}}{2 - (V_{max} + V_{min})} }{if  (L \ge 0.5) }\f]<br>\f[H  \leftarrow \forkfour {{60(G - B)}&#x2F;{(V_{max}-V_{min})}}{if  (V_{max}&#x3D;R) }<br>  {{120+60(B - R)}&#x2F;{(V_{max}-V_{min})}}{if  (V_{max}&#x3D;G) }<br>  {{240+60(R - G)}&#x2F;{(V_{max}-V_{min})}}{if  (V_{max}&#x3D;B) }<br>  {0}{if  (R&#x3D;G&#x3D;B) }\f]<br>If \f$H&lt;0\f$ then \f$H \leftarrow H+360\f$ . On output \f$0 \leq L \leq 1\f$, \f$0 \leq S \leq<br>1\f$, \f$0 \leq H \leq 360\f$ .</p>
<p>The values are then converted to the destination data type:</p>
<ul>
<li>8-bit images:  \f$V  \leftarrow 255 \cdot V, S  \leftarrow 255 \cdot S, H  \leftarrow H&#x2F;2 ; \text{(to fit to 0 to 255)}\f$</li>
<li>16-bit images: (currently not supported)  \f$V &lt;- 65535 \cdot V, S &lt;- 65535 \cdot S, H &lt;- H\f$</li>
<li>32-bit images: H, S, V are left as is</li>
</ul>
<p>@see cv::COLOR_BGR2HLS, cv::COLOR_RGB2HLS, cv::COLOR_HLS2BGR, cv::COLOR_HLS2RGB</p>
<h2 id="anchor-color-convert-rgb-labRGB-f-leftrightarrow-f-CIE-L-a-b"><a href="#anchor-color-convert-rgb-labRGB-f-leftrightarrow-f-CIE-L-a-b" class="headerlink" title="@anchor color_convert_rgb_labRGB \f$\leftrightarrow\f$ CIE L*a*b*"></a>@anchor color_convert_rgb_lab<br>RGB \f$\leftrightarrow\f$ CIE L*a*b*</h2><p>In case of 8-bit and 16-bit images, R, G, and B are converted to the floating-point format and<br>scaled to fit the 0 to 1 range.</p>
<p>\f[\vecthree{X}{Y}{Z} \leftarrow \vecthreethree{0.412453}{0.357580}{0.180423}{0.212671}{0.715160}{0.072169}{0.019334}{0.119193}{0.950227} \cdot \vecthree{R}{G}{B}\f]<br>\f[X  \leftarrow X&#x2F;X_n,  \text{where} X_n &#x3D; 0.950456\f]<br>\f[Z  \leftarrow Z&#x2F;Z_n,  \text{where} Z_n &#x3D; 1.088754\f]<br>\f[L  \leftarrow \fork{116<em>Y^{1&#x2F;3}-16}{for (Y&gt;0.008856)}{903.3</em>Y}{for (Y \le 0.008856)}\f]<br>\f[a  \leftarrow 500 (f(X)-f(Y)) + delta\f]<br>\f[b  \leftarrow 200 (f(Y)-f(Z)) + delta\f]<br>where<br>\f[f(t)&#x3D; \fork{t^{1&#x2F;3}}{for (t&gt;0.008856)}{7.787 t+16&#x2F;116}{for (t\leq 0.008856)}\f]<br>and<br>\f[delta &#x3D;  \fork{128}{for 8-bit images}{0}{for floating-point images}\f]</p>
<p>This outputs \f$0 \leq L \leq 100\f$, \f$-127 \leq a \leq 127\f$, \f$-127 \leq b \leq 127\f$ . The values<br>are then converted to the destination data type:</p>
<ul>
<li>8-bit images:  \f$L  \leftarrow L*255&#x2F;100, ; a  \leftarrow a + 128, ; b  \leftarrow b + 128\f$</li>
<li>16-bit images:  (currently not supported)</li>
<li>32-bit images:  L, a, and b are left as is</li>
</ul>
<p>@see cv::COLOR_BGR2Lab, cv::COLOR_RGB2Lab, cv::COLOR_Lab2BGR, cv::COLOR_Lab2RGB</p>
<h2 id="anchor-color-convert-rgb-luvRGB-f-leftrightarrow-f-CIE-L-u-v"><a href="#anchor-color-convert-rgb-luvRGB-f-leftrightarrow-f-CIE-L-u-v" class="headerlink" title="@anchor color_convert_rgb_luvRGB \f$\leftrightarrow\f$ CIE L*u*v*"></a>@anchor color_convert_rgb_luv<br>RGB \f$\leftrightarrow\f$ CIE L*u*v*</h2><p>In case of 8-bit and 16-bit images, R, G, and B are converted to the floating-point format and<br>scaled to fit 0 to 1 range.</p>
<p>\f[\vecthree{X}{Y}{Z} \leftarrow \vecthreethree{0.412453}{0.357580}{0.180423}{0.212671}{0.715160}{0.072169}{0.019334}{0.119193}{0.950227} \cdot \vecthree{R}{G}{B}\f]<br>\f[L  \leftarrow \fork{116<em>Y^{1&#x2F;3} - 16}{for (Y&gt;0.008856)}{903.3 Y}{for (Y\leq 0.008856)}\f]<br>\f[u’  \leftarrow 4</em>X&#x2F;(X + 15<em>Y + 3 Z)\f]<br>\f[v’  \leftarrow 9</em>Y&#x2F;(X + 15<em>Y + 3 Z)\f]<br>\f[u  \leftarrow 13</em>L*(u’ - u_n)  \quad \text{where} \quad u_n&#x3D;0.19793943\f]<br>\f[v  \leftarrow 13<em>L</em>(v’ - v_n)  \quad \text{where} \quad v_n&#x3D;0.46831096\f]</p>
<p>This outputs \f$0 \leq L \leq 100\f$, \f$-134 \leq u \leq 220\f$, \f$-140 \leq v \leq 122\f$ .</p>
<p>The values are then converted to the destination data type:</p>
<ul>
<li>8-bit images:  \f$L  \leftarrow 255&#x2F;100 L, ; u  \leftarrow 255&#x2F;354 (u + 134), ; v  \leftarrow 255&#x2F;262 (v + 140)\f$</li>
<li>16-bit images:   (currently not supported)</li>
<li>32-bit images:   L, u, and v are left as is</li>
</ul>
<p>Note that when converting integer Luv images to RGB the intermediate X, Y and Z values are truncated to \f$ [0, 2] \f$ range to fit white point limitations. It may lead to incorrect representation of colors with odd XYZ values.</p>
<p>The above formulae for converting RGB to&#x2F;from various color spaces have been taken from multiple<br>sources on the web, primarily from the Charles Poynton site <a href="http://www.poynton.com/ColorFAQ.html">http://www.poynton.com/ColorFAQ.html</a></p>
<p>@see cv::COLOR_BGR2Luv, cv::COLOR_RGB2Luv, cv::COLOR_Luv2BGR, cv::COLOR_Luv2RGB</p>
<h2 id="anchor-color-convert-bayerBayer-f-rightarrow-f-RGB"><a href="#anchor-color-convert-bayerBayer-f-rightarrow-f-RGB" class="headerlink" title="@anchor color_convert_bayerBayer \f$\rightarrow\f$ RGB"></a>@anchor color_convert_bayer<br>Bayer \f$\rightarrow\f$ RGB</h2><p>The Bayer pattern is widely used in CCD and CMOS cameras. It enables you to get color pictures<br>from a single plane where R,G, and B pixels (sensors of a particular component) are interleaved<br>as follows:</p>
<p><img src="/pics/bayer.png" alt="Bayer pattern"></p>
<p>The output RGB components of a pixel are interpolated from 1, 2, or 4 neighbors of the pixel<br>having the same color. There are several modifications of the above pattern that can be achieved<br>by shifting the pattern one pixel left and&#x2F;or one pixel up. The two letters \f$C_1\f$ and \f$C_2\f$ in<br>the conversion constants CV_Bayer \f$C_1 C_2\f$ 2BGR and CV_Bayer \f$C_1 C_2\f$ 2RGB indicate the<br>particular pattern type. These are components from the second row, second and third columns,<br>respectively. For example, the above pattern has a very popular “BG” type.</p>
<p>@see cv::COLOR_BayerBG2BGR, cv::COLOR_BayerGB2BGR, cv::COLOR_BayerRG2BGR, cv::COLOR_BayerGR2BGR, cv::COLOR_BayerBG2RGB, cv::COLOR_BayerGB2RGB, cv::COLOR_BayerRG2RGB, cv::COLOR_BayerGR2RGB</p>
