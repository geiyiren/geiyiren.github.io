<h1 id="Detection-of-ArUco-Boards-tutorial-aruco-board-detection"><a href="#Detection-of-ArUco-Boards-tutorial-aruco-board-detection" class="headerlink" title="Detection of ArUco Boards {#tutorial_aruco_board_detection}"></a>Detection of ArUco Boards {#tutorial_aruco_board_detection}</h1><p>An ArUco Board is a set of markers that acts like a single marker in the sense that it provides a<br>single pose for the camera.</p>
<p>The most popular board is the one with all the markers in the same plane, since it can be easily printed:</p>
<p><img src="/images/gboriginal.png"></p>
<p>However, boards are not limited to this arrangement and can represent any 2d or 3d layout.</p>
<p>The difference between a Board and a set of independent markers is that the relative position between<br>the markers in the Board is known a priori. This allows that the corners of all the markers can be used for<br>estimating the pose of the camera respect to the whole Board.</p>
<p>When you use a set of independent markers, you can estimate the pose for each marker individually,<br>since you dont know the relative position of the markers in the environment.</p>
<p>The main benefits of using Boards are:</p>
<ul>
<li>The pose estimation is much more versatile. Only some markers are necessary to perform pose estimation.<br>Thus, the pose can be calculated even in the presence of occlusions or partial views.</li>
<li>The obtained pose is usually more accurate since a higher amount of point correspondences (marker<br>corners) are employed.</li>
</ul>
<p>The aruco module allows the use of Boards. The main class is the <code>cv::aruco::Board</code> class which defines the Board layout:</p>
<p>@code{.cpp}<br>    class  Board {<br>    public:<br>        std::vector&lt;std::vector<a href="cv::Point3f">cv::Point3f</a> &gt; objPoints;<br>        cv::Ptr<a href="cv::aruco::Dictionary">cv::aruco::Dictionary</a> dictionary;<br>        std::vector<int> ids;<br>    };<br>@endcode</p>
<p>A object of type <code>Board</code> has three parameters:</p>
<ul>
<li>The <code>objPoints</code> structure is the list of corner positions in the 3d Board reference system, i.e. its layout.<br>For each marker, its four corners are stored in the standard order, i.e. in clockwise order and starting<br>with the top left corner.</li>
<li>The <code>dictionary</code> parameter indicates to which marker dictionary the Board markers belong to.</li>
<li>Finally, the <code>ids</code> structure indicates the identifiers of each of the markers in <code>objPoints</code> respect to the specified  <code>dictionary</code>.</li>
</ul>
<h2 id="Board-Detection"><a href="#Board-Detection" class="headerlink" title="Board Detection"></a>Board Detection</h2><p>A Board detection is similar to the standard marker detection. The only difference is in the pose estimation step.<br>In fact, to use marker boards, a standard marker detection should be done before estimating the Board pose.</p>
<p>The aruco module provides a specific function, <code>estimatePoseBoard()</code>, to perform pose estimation for boards:</p>
<p>@code{.cpp}<br>    cv::Mat inputImage;<br>    &#x2F;&#x2F; camera parameters are read from somewhere<br>    cv::Mat cameraMatrix, distCoeffs;<br>    readCameraParameters(cameraMatrix, distCoeffs);<br>    &#x2F;&#x2F; assume we have a function to create the board object<br>    cv::Ptr<a href="cv::aruco::Board">cv::aruco::Board</a> board &#x3D; cv::aruco::Board::create();<br>    …<br>    std::vector<int> markerIds;<br>    std::vector&lt;std::vector<a href="cv::Point2f">cv::Point2f</a>&gt; markerCorners;<br>    cv::aruco::detectMarkers(inputImage, board.dictionary, markerCorners, markerIds);<br>    &#x2F;&#x2F; if at least one marker detected<br>    if(markerIds.size() &gt; 0) {<br>        cv::Vec3d rvec, tvec;<br>        int valid &#x3D; cv::aruco::estimatePoseBoard(markerCorners, markerIds, board, cameraMatrix, distCoeffs, rvec, tvec);<br>    }<br>@endcode</p>
<p>The parameters of estimatePoseBoard are:</p>
<ul>
<li><code>markerCorners</code> and <code>markerIds</code>: structures of detected markers from <code>detectMarkers()</code> function.</li>
<li><code>board</code>: the <code>Board</code> object that defines the board layout and its ids</li>
<li><code>cameraMatrix</code> and <code>distCoeffs</code>: camera calibration parameters necessary for pose estimation.</li>
<li><code>rvec</code> and <code>tvec</code>: estimated pose of the Board. If not empty then treated as initial guess.</li>
<li>The function returns the total number of markers employed for estimating the board pose. Note that not all the<br> markers provided in <code>markerCorners</code> and <code>markerIds</code> should be used, since only the markers whose ids are<br>listed in the <code>Board::ids</code> structure are considered.</li>
</ul>
<p>The <code>drawAxis()</code> function can be used to check the obtained pose. For instance:</p>
<p><img src="/images/gbmarkersaxis.png" alt="Board with axis"></p>
<p>And this is another example with the board partially occluded:</p>
<p><img src="/images/gbocclusion.png" alt="Board with occlusions"></p>
<p>As it can be observed, although some markers have not been detected, the Board pose can still be estimated from the rest of markers.</p>
<h2 id="Grid-Board"><a href="#Grid-Board" class="headerlink" title="Grid Board"></a>Grid Board</h2><p>Creating the <code>Board</code> object requires specifying the corner positions for each marker in the environment.<br>However, in many cases, the board will be just a set of markers in the same plane and in a grid layout,<br>so it can be easily printed and used.</p>
<p>Fortunately, the aruco module provides the basic functionality to create and print these types of markers<br>easily.</p>
<p>The <code>GridBoard</code> class is a specialized class that inherits from the <code>Board</code> class and which represents a Board<br>with all the markers in the same plane and in a grid layout, as in the following image:</p>
<p><img src="/images/gboriginal.png" alt="Image with aruco board"></p>
<p>Concretely, the coordinate system in a Grid Board is positioned in the board plane, centered in the bottom left<br>corner of the board and with the Z pointing out, like in the following image (X:red, Y:green, Z:blue):</p>
<p><img src="/images/gbaxis.png" alt="Board with axis"></p>
<p>A <code>GridBoard</code> object can be defined using the following parameters:</p>
<ul>
<li>Number of markers in the X direction.</li>
<li>Number of markers in the Y direction.</li>
<li>Length of the marker side.</li>
<li>Length of the marker separation.</li>
<li>The dictionary of the markers.</li>
<li>Ids of all the markers (X*Y markers).</li>
</ul>
<p>This object can be easily created from these parameters using the <code>cv::aruco::GridBoard::create()</code> static function:</p>
<p>@code{.cpp}<br>    cv::aruco::GridBoard board &#x3D; cv::aruco::GridBoard::create(5, 7, 0.04, 0.01, dictionary);<br>@endcode</p>
<ul>
<li>The first and second parameters are the number of markers in the X and Y direction respectively.</li>
<li>The third and fourth parameters are the marker length and the marker separation respectively. They can be provided<br>in any unit, having in mind that the estimated pose for this board will be measured in the same units (in general, meters are used).</li>
<li>Finally, the dictionary of the markers is provided.</li>
</ul>
<p>So, this board will be composed by 5x7&#x3D;35 markers. The ids of each of the markers are assigned, by default, in ascending<br>order starting on 0, so they will be 0, 1, 2, …, 34. This can be easily customized by accessing to the ids vector<br>through <code>board.ids</code>, like in the <code>Board</code> parent class.</p>
<p>After creating a Grid Board, we probably want to print it and use it. A function to generate the image<br>of a <code>GridBoard</code> is provided in <code>cv::aruco::GridBoard::draw()</code>. For example:</p>
<p>@code{.cpp}<br>    cv::Ptr<a href="cv::aruco::GridBoard">cv::aruco::GridBoard</a> board &#x3D; cv::aruco::GridBoard::create(5, 7, 0.04, 0.01, dictionary);<br>    cv::Mat boardImage;<br>    board-&gt;draw( cv::Size(600, 500), boardImage, 10, 1 );<br>@endcode</p>
<ul>
<li>The first parameter is the size of the output image in pixels. In this case 600x500 pixels. If this is not proportional<br>to the board dimensions, it will be centered on the image.</li>
<li><code>boardImage</code>: the output image with the board.</li>
<li>The third parameter is the (optional) margin in pixels, so none of the markers are touching the image border.<br>In this case the margin is 10.</li>
<li>Finally, the size of the marker border, similarly to <code>drawMarker()</code> function. The default value is 1.</li>
</ul>
<p>The output image will be something like this:</p>
<p><img src="/images/board.jpg"></p>
<p>A full working example of board creation is included in the <code>create_board.cpp</code> inside the module samples folder.</p>
<p>Note: The samples now take input via commandline via the <a href="http://docs.opencv.org/trunk/d0/d2e/classcv_1_1CommandLineParser.html#gsc.tab=0">OpenCV Commandline Parser</a>. For this file the example parameters will look like<br>@code{.cpp}<br>    “<em>output path</em>&#x2F;aboard.png” -w&#x3D;5 -h&#x3D;7 -l&#x3D;100 -s&#x3D;10 -d&#x3D;10<br>@endcode</p>
<p>Finally, a full example of board detection:</p>
<p>@code{.cpp}<br>    cv::VideoCapture inputVideo;<br>    inputVideo.open(0);</p>
<pre><code>cv::Mat cameraMatrix, distCoeffs;
// camera parameters are read from somewhere
readCameraParameters(cameraMatrix, distCoeffs);

cv::Ptr&lt;cv::aruco::Dictionary&gt; dictionary = cv::aruco::getPredefinedDictionary(cv::aruco::DICT_6X6_250);
cv::Ptr&lt;cv::aruco::GridBoard&gt; board = cv::aruco::GridBoard::create(5, 7, 0.04, 0.01, dictionary);

while (inputVideo.grab()) {
    cv::Mat image, imageCopy;
    inputVideo.retrieve(image);
    image.copyTo(imageCopy);

    std::vector&lt;int&gt; ids;
    std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; corners;
    cv::aruco::detectMarkers(image, dictionary, corners, ids);

    // if at least one marker detected
    if (ids.size() &gt; 0) {
        cv::aruco::drawDetectedMarkers(imageCopy, corners, ids);

        cv::Vec3d rvec, tvec;
        int valid = estimatePoseBoard(corners, ids, board, cameraMatrix, distCoeffs, rvec, tvec);

        // if at least one board marker detected
        if(valid &gt; 0)
            cv::aruco::drawAxis(imageCopy, cameraMatrix, distCoeffs, rvec, tvec, 0.1);
    }

    cv::imshow(&quot;out&quot;, imageCopy);
    char key = (char) cv::waitKey(waitTime);
    if (key == 27)
        break;
}
</code></pre>
<p>@endcode</p>
<p>Sample video:</p>
<p>@htmlonly</p>
<iframe width="420" height="315" src="https://www.youtube.com/embed/Q1HlJEjW_j0" frameborder="0" allowfullscreen></iframe>
@endhtmlonly

<p>A full working example is included in the <code>detect_board.cpp</code> inside the module samples folder.</p>
<p>Note: The samples now take input via commandline via the <a href="http://docs.opencv.org/trunk/d0/d2e/classcv_1_1CommandLineParser.html#gsc.tab=0">OpenCV Commandline Parser</a>. For this file the example parameters will look like<br>@code{.cpp}<br>    -c&#x3D;”<em>path</em>“&#x2F;calib.txt” “<em>path</em>&#x2F;aboard.png” -w&#x3D;5 -h&#x3D;7 -l&#x3D;100 -s&#x3D;10 -d&#x3D;10<br>@endcode</p>
<h2 id="Refine-marker-detection"><a href="#Refine-marker-detection" class="headerlink" title="Refine marker detection"></a>Refine marker detection</h2><p>ArUco boards can also be used to improve the detection of markers. If we have detected a subset of the markers<br>that belongs to the board, we can use these markers and the board layout information to try to find the<br>markers that have not been previously detected.</p>
<p>This can be done using the <code>refineDetectedMarkers()</code> function, which should be called<br>after calling <code>detectMarkers()</code>.</p>
<p>The main parameters of this function are the original image where markers were detected, the Board object,<br>the detected marker corners, the detected marker ids and the rejected marker corners.</p>
<p>The rejected corners can be obtained from the <code>detectMarkers()</code> function and are also known as marker<br>candidates. This candidates are square shapes that have been found in the original image but have failed<br>to pass the identification step (i.e. their inner codification presents too many errors) and thus they<br>have not been recognized as markers.</p>
<p>However, these candidates are sometimes actual markers that have not been correctly identified due to high<br>noise in the image, very low resolution or other related problems that affect to the binary code extraction.<br>The <code>refineDetectedMarkers()</code> function finds correspondences between these candidates and the missing<br>markers of the board. This search is based on two parameters:</p>
<ul>
<li><p>Distance between the candidate and the projection of the missing marker. To obtain these projections,<br>it is necessary to have detected at least one marker of the board. The projections are obtained using the<br>camera parameters (camera matrix and distortion coefficients) if they are provided. If not, the projections<br>are obtained from local homography and only planar board are allowed (i.e. the Z coordinate of all the<br>marker corners should be the same). The <code>minRepDistance</code> parameter in <code>refineDetectedMarkers()</code><br>determines the minimum euclidean distance between the candidate corners and the projected marker corners<br>(default value 10).</p>
</li>
<li><p>Binary codification. If a candidate surpasses the minimum distance condition, its internal bits<br>are analyzed again to determine if it is actually the projected marker or not. However, in this case,<br>the condition is not so strong and the number of allowed erroneous bits can be higher. This is indicated<br>in the <code>errorCorrectionRate</code> parameter (default value 3.0). If a negative value is provided, the<br>internal bits are not analyzed at all and only the corner distances are evaluated.</p>
</li>
</ul>
<p>This is an example of using the  <code>refineDetectedMarkers()</code> function:</p>
<p>@code{.cpp}<br>    cv::Ptr<a href="cv::aruco::Dictionary">cv::aruco::Dictionary</a> dictionary &#x3D; cv::aruco::getPredefinedDictionary(cv::aruco::DICT_6X6_250);<br>    cv::Ptr<a href="cv::aruco::GridBoard">cv::aruco::GridBoard</a> board &#x3D; cv::aruco::GridBoard::create(5, 7, 0.04, 0.01, dictionary);<br>    std::vector<int> markerIds;<br>    std::vector&lt;std::vector<a href="cv::Point2f">cv::Point2f</a>&gt; markerCorners, rejectedCandidates;<br>    cv::aruco::detectMarkers(inputImage, dictionary, markerCorners, markerIds, cv::aruco::DetectorParameters(), rejectedCandidates);</p>
<pre><code>cv::aruco::refineDetectedMarkersinputImage, board, markerCorners, markerIds, rejectedCandidates);
// After calling this function, if any new marker has been detected it will be removed from rejectedCandidates and included
// at the end of markerCorners and markerIds
</code></pre>
<p>@endcode</p>
<p>It must also be noted that, in some cases, if the number of detected markers in the first place is too low (for instance only<br>1 or 2 markers), the projections of the missing markers can be of bad quality, producing erroneous correspondences.</p>
<p>See module samples for a more detailed implementation.</p>
