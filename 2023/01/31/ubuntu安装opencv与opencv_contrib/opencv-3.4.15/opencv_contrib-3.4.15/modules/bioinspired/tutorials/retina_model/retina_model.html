<h1 id="Retina-and-real-world-vision-tutorial-bioinspired-retina-model"><a href="#Retina-and-real-world-vision-tutorial-bioinspired-retina-model" class="headerlink" title="Retina and real-world vision {#tutorial_bioinspired_retina_model}"></a>Retina and real-world vision {#tutorial_bioinspired_retina_model}</h1><h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal"></a>Goal</h2><p>I present here a model of human retina that shows some interesting properties for image<br>preprocessing and enhancement. In this tutorial you will learn how to:</p>
<ul>
<li>discover the main two channels outing from your retina</li>
<li>see the basics to use the retina model</li>
<li>discover some parameters tweaks</li>
</ul>
<h2 id="General-overview"><a href="#General-overview" class="headerlink" title="General overview"></a>General overview</h2><p>The proposed model originates from Jeanny Herault’s research @cite Herault2010 at<br><a href="http://www.gipsa-lab.inpg.fr/">Gipsa</a>. It is involved in image processing applications with<br><a href="http://www.listic.univ-savoie.fr/">Listic</a> (code maintainer and user) lab. This is not a complete<br>model but it already present interesting properties that can be involved for enhanced image<br>processing experience. The model allows the following human retina properties to be used :</p>
<ul>
<li>spectral whitening that has 3 important effects: high spatio-temporal frequency signals<br>canceling (noise), mid-frequencies details enhancement and low frequencies luminance energy<br>reduction. This <em>all in one</em> property directly allows visual signals cleaning of classical<br>undesired distortions introduced by image sensors and input luminance range.</li>
<li>local logarithmic luminance compression allows details to be enhanced even in low light<br>conditions.</li>
<li>decorrelation of the details information (Parvocellular output channel) and transient<br>information (events, motion made available at the Magnocellular output channel).</li>
</ul>
<p>The first two points are illustrated below :</p>
<p>In the figure below, the OpenEXR image sample <em>CrissyField.exr</em>, a High Dynamic Range image is<br>shown. In order to make it visible on this web-page, the original input image is linearly rescaled<br>to the classical image luminance range [0-255] and is converted to 8bit&#x2F;channel format. Such strong<br>conversion hides many details because of too strong local contrasts. Furthermore, noise energy is<br>also strong and pollutes visual information.</p>
<p><img src="/images/retina_TreeHdr_small.jpg" alt="image"></p>
<p>In the following image, applying the ideas proposed in @cite Benoit2010, as your retina does, local<br>luminance adaptation, spatial noise removal and spectral whitening work together and transmit<br>accurate information on lower range 8bit data channels. On this picture, noise in significantly<br>removed, local details hidden by strong luminance contrasts are enhanced. Output image keeps its<br>naturalness and visual content is enhanced. Color processing is based on the color<br>multiplexing&#x2F;demultiplexing method proposed in @cite Chaix2007 .</p>
<p><img src="/images/retina_TreeHdr_retina.jpg" alt="image"></p>
<p><em>Note :</em> image sample can be downloaded from the <a href="http://www.openexr.com/">OpenEXR website</a>.<br>Regarding this demonstration, before retina processing, input image has been linearly rescaled<br>within 0-255 keeping its channels float format. 5% of its histogram ends has been cut (mostly<br>removes wrong HDR pixels). Check out the sample<br><em>opencv&#x2F;samples&#x2F;cpp&#x2F;OpenEXRimages_HighDynamicRange_Retina_toneMapping.cpp</em> for similar<br>processing. The following demonstration will only consider classical 8bit&#x2F;channel images.</p>
<h2 id="The-retina-model-output-channels"><a href="#The-retina-model-output-channels" class="headerlink" title="The retina model output channels"></a>The retina model output channels</h2><p>The retina model presents two outputs that benefit from the above cited behaviors.</p>
<ul>
<li>The first one is called the Parvocellular channel. It is mainly active in the foveal retina area<br>(high resolution central vision with color sensitive photo-receptors), its aim is to provide<br>accurate color vision for visual details remaining static on the retina. On the other hand<br>objects moving on the retina projection are blurred.</li>
<li>The second well known channel is the Magnocellular channel. It is mainly active in the retina<br>peripheral vision and send signals related to change events (motion, transient events, etc.).<br>These outing signals also help visual system to focus&#x2F;center retina on ‘transient’&#x2F;moving areas<br>for more detailed analysis thus improving visual scene context and object classification.</li>
</ul>
<p><strong>NOTE :</strong> regarding the proposed model, contrary to the real retina, we apply these two channels on<br>the entire input images using the same resolution. This allows enhanced visual details and motion<br>information to be extracted on all the considered images… but remember, that these two channels<br>are complementary. For example, if Magnocellular channel gives strong energy in an area, then, the<br>Parvocellular channel is certainly blurred there since there is a transient event.</p>
<p>As an illustration, we apply in the following the retina model on a webcam video stream of a dark<br>visual scene. In this visual scene, captured in an amphitheater of the university, some students are<br>moving while talking to the teacher.</p>
<p>In this video sequence, because of the dark ambiance, signal to noise ratio is low and color<br>artifacts are present on visual features edges because of the low quality image capture tool-chain.</p>
<p><img src="/images/studentsSample_input.jpg" alt="image"></p>
<p>Below is shown the retina foveal vision applied on the entire image. In the used retina<br>configuration, global luminance is preserved and local contrasts are enhanced. Also, signal to noise<br>ratio is improved : since high frequency spatio-temporal noise is reduced, enhanced details are not<br>corrupted by any enhanced noise.</p>
<p><img src="/images/studentsSample_parvo.jpg" alt="image"></p>
<p>Below is the output of the Magnocellular output of the retina model. Its signals are strong where<br>transient events occur. Here, a student is moving at the bottom of the image thus generating high<br>energy. The remaining of the image is static however, it is corrupted by a strong noise. Here, the<br>retina filters out most of the noise thus generating low false motion area ‘alarms’. This channel<br>can be used as a transient&#x2F;moving areas detector : it would provide relevant information for a low<br>cost segmentation tool that would highlight areas in which an event is occurring.</p>
<p><img src="/images/studentsSample_magno.jpg" alt="image"></p>
<h2 id="Retina-use-case"><a href="#Retina-use-case" class="headerlink" title="Retina use case"></a>Retina use case</h2><p>This model can be used basically for spatio-temporal video effects but also in the aim of :</p>
<ul>
<li>performing texture analysis with enhanced signal to noise ratio and enhanced details robust<br>against input images luminance ranges (check out the Parvocellular retina channel output)</li>
<li>performing motion analysis also taking benefit of the previously cited properties.</li>
</ul>
<h2 id="Literature"><a href="#Literature" class="headerlink" title="Literature"></a>Literature</h2><p>For more information, refer to the following papers : @cite Benoit2010</p>
<ul>
<li>Please have a look at the reference work of Jeanny Herault that you can read in his book @cite Herault2010</li>
</ul>
<p>This retina filter code includes the research contributions of phd&#x2F;research colleagues from which<br>code has been redrawn by the author :</p>
<ul>
<li><p>take a look at the <em>retinacolor.hpp</em> module to discover Brice Chaix de Lavarene phD color<br>mosaicing&#x2F;demosaicing and his reference paper @cite Chaix2007</p>
</li>
<li><p>take a look at <em>imagelogpolprojection.hpp</em> to discover retina spatial log sampling which<br>originates from Barthelemy Durette phd with Jeanny Herault. A Retina &#x2F; V1 cortex projection is<br>also proposed and originates from Jeanny’s discussions. More informations in the above cited<br>Jeanny Heraults’s book.</p>
</li>
</ul>
<h2 id="Code-tutorial"><a href="#Code-tutorial" class="headerlink" title="Code tutorial"></a>Code tutorial</h2><p>Please refer to the original tutorial source code in file<br><em>opencv_folder&#x2F;samples&#x2F;cpp&#x2F;tutorial_code&#x2F;bioinspired&#x2F;retina_tutorial.cpp</em>.</p>
<p>@note do not forget that the retina model is included in the following namespace: cv::bioinspired</p>
<p>To compile it, assuming OpenCV is correctly installed, use the following command. It requires the<br>opencv_core <em>(cv::Mat and friends objects management)</em>, opencv_highgui <em>(display and image&#x2F;video<br>read)</em> and opencv_bioinspired <em>(Retina description)</em> libraries to compile.</p>
<p>@code{.sh}<br>&#x2F;&#x2F; compile<br>gcc retina_tutorial.cpp -o Retina_tuto -lopencv_core -lopencv_highgui -lopencv_bioinspired -lopencv_videoio -lopencv_imgcodecs</p>
<p>&#x2F;&#x2F; Run commands : add ‘log’ as a last parameter to apply a spatial log sampling (simulates retina sampling)<br>&#x2F;&#x2F; run on webcam<br>.&#x2F;Retina_tuto -video<br>&#x2F;&#x2F; run on video file<br>.&#x2F;Retina_tuto -video myVideo.avi<br>&#x2F;&#x2F; run on an image<br>.&#x2F;Retina_tuto -image myPicture.jpg<br>&#x2F;&#x2F; run on an image with log sampling<br>.&#x2F;Retina_tuto -image myPicture.jpg log<br>@endcode</p>
<p>Here is a code explanation :</p>
<p>Retina definition is present in the bioinspired package and a simple include allows to use it. You<br>can rather use the specific header : <em>opencv2&#x2F;bioinspired.hpp</em> if you prefer but then include the<br>other required openv modules : <em>opencv2&#x2F;core.hpp</em> and <em>opencv2&#x2F;highgui.hpp</em><br>@code{.cpp}<br>#include “opencv2&#x2F;opencv.hpp”<br>@endcode<br>Provide user some hints to run the program with a help function<br>@code{.cpp}<br>&#x2F;&#x2F; the help procedure<br>static void help(std::string errorMessage)<br>{<br> std::cout&lt;&lt;”Program init error : “&lt;&lt;errorMessage&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\nProgram call procedure : retinaDemo [processing mode] [Optional : media target] [Optional LAST parameter: &quot;log&quot; to activate retina log sampling]”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t[processing mode] :”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t -image : for still image processing”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t -video : for video stream processing”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t[Optional : media target] :”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t if processing an image or video file, then, specify the path and filename of the target to process”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t leave empty if processing video stream coming from a connected video device”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t[Optional : activate retina log sampling] : an optional last parameter can be specified for retina spatial log sampling”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t set &quot;log&quot; without quotes to activate this sampling, output frame size will be divided by 4”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\nExamples:”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t-Image processing : .&#x2F;retinaDemo -image lena.jpg”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t-Image processing with log sampling : .&#x2F;retinaDemo -image lena.jpg log”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t-Video processing : .&#x2F;retinaDemo -video myMovie.mp4”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\t-Live video processing : .&#x2F;retinaDemo -video”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”\nPlease start again with new parameters”&lt;&lt;std::endl;<br> std::cout&lt;&lt;”<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>“&lt;&lt;std::endl;<br> std::cout&lt;&lt;” NOTE : this program generates the default retina parameters file ‘RetinaDefaultParameters.xml’”&lt;&lt;std::endl;<br> std::cout&lt;&lt;” &#x3D;&gt; you can use this to fine tune parameters and load them if you save to file ‘RetinaSpecificParameters.xml’”&lt;&lt;std::endl;<br>}<br>@endcode<br>Then, start the main program and first declare a <em>cv::Mat</em> matrix in which input images will be<br>loaded. Also allocate a <em>cv::VideoCapture</em> object ready to load video streams (if necessary)<br>@code{.cpp}<br>int main(int argc, char</em> argv[]) {<br>  &#x2F;&#x2F; declare the retina input buffer… that will be fed differently in regard of the input media<br>  cv::Mat inputFrame;<br>  cv::VideoCapture videoCapture; &#x2F;&#x2F; in case a video media is used, its manager is declared here<br>@endcode<br>In the main program, before processing, first check input command parameters. Here it loads a first<br>input image coming from a single loaded image (if user chose command <em>-image</em>) or from a video<br>stream (if user chose command <em>-video</em>). Also, if the user added <em>log</em> command at the end of its<br>program call, the spatial logarithmic image sampling performed by the retina is taken into account<br>by the Boolean flag <em>useLogSampling</em>.<br>@code{.cpp}<br>&#x2F;&#x2F; welcome message<br>  std::cout&lt;&lt;”</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em><em>“&lt;&lt;std::endl;<br>  std::cout&lt;&lt;”</em> Retina demonstration : demonstrates the use of is a wrapper class of the Gipsa&#x2F;Listic Labs retina model.”&lt;&lt;std::endl;<br>  std::cout&lt;&lt;”* This demo will try to load the file ‘RetinaSpecificParameters.xml’ (if exists).\nTo create it, copy the autogenerated template ‘RetinaDefaultParameters.xml’.\nThen tweak it with your own retina parameters.”&lt;&lt;std::endl;<br>  &#x2F;&#x2F; basic input arguments checking<br>  if (argc&lt;2)<br>  {<br>      help(“bad number of parameter”);<br>      return -1;<br>  }</p>
<p>  bool useLogSampling &#x3D; !strcmp(argv[argc-1], “log”); &#x2F;&#x2F; check if user wants retina log sampling processing</p>
<p>  std::string inputMediaType&#x3D;argv[1];</p>
<p>  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;<br>  &#x2F;&#x2F; checking input media type (still image, video file, live video acquisition)<br>  if (!strcmp(inputMediaType.c_str(), “-image”) &amp;&amp; argc &gt;&#x3D; 3)<br>  {<br>      std::cout&lt;&lt;”RetinaDemo: processing image “&lt;&lt;argv[2]&lt;&lt;std::endl;<br>      &#x2F;&#x2F; image processing case<br>      inputFrame &#x3D; cv::imread(std::string(argv[2]), 1); &#x2F;&#x2F; load image in RGB mode<br>  }else<br>      if (!strcmp(inputMediaType.c_str(), “-video”))<br>      {<br>          if (argc &#x3D;&#x3D; 2 || (argc &#x3D;&#x3D; 3 &amp;&amp; useLogSampling)) &#x2F;&#x2F; attempt to grab images from a video capture device<br>          {<br>              videoCapture.open(0);<br>          }else&#x2F;&#x2F; attempt to grab images from a video filestream<br>          {<br>              std::cout&lt;&lt;”RetinaDemo: processing video stream “&lt;&lt;argv[2]&lt;&lt;std::endl;<br>              videoCapture.open(argv[2]);<br>          }</p>
<pre><code>      // grab a first frame to check if everything is ok
      videoCapture&gt;&gt;inputFrame;
  }else
  {
      // bad command parameter
      help(&quot;bad command parameter&quot;);
      return -1;
  }
</code></pre>
<p>@endcode<br>Once all input parameters are processed, a first image should have been loaded, if not, display<br>error and stop program :<br>@code{.cpp}<br>if (inputFrame.empty())<br>{<br>    help(“Input media could not be loaded, aborting”);<br>    return -1;<br>}<br>@endcode<br>Now, everything is ready to run the retina model. I propose here to allocate a retina instance and<br>to manage the eventual log sampling option. The Retina constructor expects at least a cv::Size<br>object that shows the input data size that will have to be managed. One can activate other options<br>such as color and its related color multiplexing strategy (here Bayer multiplexing is chosen using<br><em>enum cv::bioinspired::RETINA_COLOR_BAYER</em>). If using log sampling, the image reduction factor<br>(smaller output images) and log sampling strength can be adjusted.<br>@code{.cpp}<br>&#x2F;&#x2F; pointer to a retina object<br>cv::Ptr<a href="cv::bioinspired::Retina">cv::bioinspired::Retina</a> myRetina;</p>
<p>&#x2F;&#x2F; if the last parameter is ‘log’, then activate log sampling (favour foveal vision and subsamples peripheral vision)<br>if (useLogSampling)<br>{<br>    myRetina &#x3D; cv::bioinspired::createRetina(inputFrame.size(), true, cv::bioinspired::RETINA_COLOR_BAYER, true, 2.0, 10.0);<br>}<br>else&#x2F;&#x2F; -&gt; else allocate “classical” retina :<br>    myRetina &#x3D; cv::bioinspired::createRetina(inputFrame.size());<br>@endcode<br>Once done, the proposed code writes a default xml file that contains the default parameters of the<br>retina. This is useful to make your own config using this template. Here generated template xml file<br>is called <em>RetinaDefaultParameters.xml</em>.<br>@code{.cpp}<br>&#x2F;&#x2F; save default retina parameters file in order to let you see this and maybe modify it and reload using method “setup”<br>myRetina-&gt;write(“RetinaDefaultParameters.xml”);<br>@endcode<br>In the following line, the retina attempts to load another xml file called<br><em>RetinaSpecificParameters.xml</em>. If you created it and introduced your own setup, it will be loaded,<br>in the other case, default retina parameters are used.<br>@code{.cpp}<br>&#x2F;&#x2F; load parameters if file exists<br>myRetina-&gt;setup(“RetinaSpecificParameters.xml”);<br>@endcode<br>It is not required here but just to show it is possible, you can reset the retina buffers to zero to<br>force it to forget past events.<br>@code{.cpp}<br>&#x2F;&#x2F; reset all retina buffers (imagine you close your eyes for a long time)<br>myRetina-&gt;clearBuffers();<br>@endcode<br>Now, it is time to run the retina ! First create some output buffers ready to receive the two retina<br>channels outputs<br>@code{.cpp}<br>&#x2F;&#x2F; declare retina output buffers<br>cv::Mat retinaOutput_parvo;<br>cv::Mat retinaOutput_magno;<br>@endcode<br>Then, run retina in a loop, load new frames from video sequence if necessary and get retina outputs<br>back to dedicated buffers.<br>@code{.cpp}<br>&#x2F;&#x2F; processing loop with no stop condition<br>while(true)<br>{<br>    &#x2F;&#x2F; if using video stream, then, grabbing a new frame, else, input remains the same<br>    if (videoCapture.isOpened())<br>        videoCapture&gt;&gt;inputFrame;</p>
<pre><code>// run retina filter on the loaded input frame
myRetina-&gt;run(inputFrame);
// Retrieve and display retina output
myRetina-&gt;getParvo(retinaOutput_parvo);
myRetina-&gt;getMagno(retinaOutput_magno);
cv::imshow(&quot;retina input&quot;, inputFrame);
cv::imshow(&quot;Retina Parvo&quot;, retinaOutput_parvo);
cv::imshow(&quot;Retina Magno&quot;, retinaOutput_magno);
cv::waitKey(10);
</code></pre>
<p>}<br>@endcode<br>That’s done ! But if you want to secure the system, take care and manage Exceptions. The retina can<br>throw some when it sees irrelevant data (no input frame, wrong setup, etc.). Then, i recommend to<br>surround all the retina code by a try&#x2F;catch system like this :<br>@code{.cpp}<br>try{<br>     &#x2F;&#x2F; pointer to a retina object<br>     cv::Ptr<a href="cv::Retina">cv::Retina</a> myRetina;<br>     [—]<br>     &#x2F;&#x2F; processing loop with no stop condition<br>     while(true)<br>     {<br>         [—]<br>     }</p>
<p>}catch(cv::Exception e)<br>{<br>    std::cerr&lt;&lt;”Error using Retina : “&lt;&lt;e.what()&lt;&lt;std::endl;<br>}<br>@endcode</p>
<h2 id="Retina-parameters-what-to-do"><a href="#Retina-parameters-what-to-do" class="headerlink" title="Retina parameters, what to do ?"></a>Retina parameters, what to do ?</h2><p>First, it is recommended to read the reference paper @cite Benoit2010</p>
<p>Once done open the configuration file <em>RetinaDefaultParameters.xml</em> generated by the demo and let’s<br>have a look at it.<br>@code{.cpp}<br><?xml version="1.0"?><br><opencv_storage><br><OPLandIPLparvo><br>    <colorMode>1</colorMode><br>    <normaliseOutput>1</normaliseOutput><br>    <photoreceptorsLocalAdaptationSensitivity>7.5e-01</photoreceptorsLocalAdaptationSensitivity><br>    <photoreceptorsTemporalConstant>9.0e-01</photoreceptorsTemporalConstant><br>    <photoreceptorsSpatialConstant>5.7e-01</photoreceptorsSpatialConstant><br>    <horizontalCellsGain>0.01</horizontalCellsGain><br>    <hcellsTemporalConstant>0.5</hcellsTemporalConstant><br>    <hcellsSpatialConstant>7.</hcellsSpatialConstant><br>    <ganglionCellsSensitivity>7.5e-01</ganglionCellsSensitivity></OPLandIPLparvo><br><IPLmagno><br>    <normaliseOutput>1</normaliseOutput><br>    <parasolCells_beta>0.</parasolCells_beta><br>    <parasolCells_tau>0.</parasolCells_tau><br>    <parasolCells_k>7.</parasolCells_k><br>    <amacrinCellsTemporalCutFrequency>2.0e+00</amacrinCellsTemporalCutFrequency><br>    <V0CompressionParameter>9.5e-01</V0CompressionParameter><br>    <localAdaptintegration_tau>0.</localAdaptintegration_tau><br>    <localAdaptintegration_k>7.</localAdaptintegration_k></IPLmagno><br></opencv_storage><br>@endcode<br>Here are some hints but actually, the best parameter setup depends more on what you want to do with<br>the retina rather than the images input that you give to retina. Apart from the more specific case<br>of High Dynamic Range images (HDR) that require more specific setup for specific luminance<br>compression objective, the retina behaviors should be rather stable from content to content. Note<br>that OpenCV is able to manage such HDR format thanks to the OpenEXR images compatibility.</p>
<p>Then, if the application target requires details enhancement prior to specific image processing, you<br>need to know if mean luminance information is required or not. If not, the the retina can cancel or<br>significantly reduce its energy thus giving more visibility to higher spatial frequency details.</p>
<h4 id="Basic-parameters"><a href="#Basic-parameters" class="headerlink" title="Basic parameters"></a>Basic parameters</h4><p>The simplest parameters are as follows :</p>
<ul>
<li><strong>colorMode</strong> : let the retina process color information (if 1) or gray scale images (if 0). In<br>that last case, only the first channels of the input will be processed.</li>
<li><strong>normaliseOutput</strong> : each channel has such parameter: if the value is set to 1, then the considered<br>channel’s output is rescaled between 0 and 255. Be aware at this case of the Magnocellular output<br>level (motion&#x2F;transient channel detection). Residual noise will also be rescaled !</li>
</ul>
<p><strong>Note :</strong> using color requires color channels multiplexing&#x2F;demultipexing which also demands more<br>processing. You can expect much faster processing using gray levels : it would require around 30<br>product per pixel for all of the retina processes and it has recently been parallelized for multicore<br>architectures.</p>
<h4 id="Photo-receptors-parameters"><a href="#Photo-receptors-parameters" class="headerlink" title="Photo-receptors parameters"></a>Photo-receptors parameters</h4><p>The following parameters act on the entry point of the retina - photo-receptors - and has impact on all<br> of the following processes. These sensors are low pass spatio-temporal filters that smooth temporal and<br>spatial data and also adjust their sensitivity to local luminance,thus, leads to improving details extraction<br>and high frequency noise canceling.</p>
<ul>
<li><strong>photoreceptorsLocalAdaptationSensitivity</strong> between 0 and 1. Values close to 1 allow high<br>luminance log compression’s effect at the photo-receptors level. Values closer to 0 provide a more<br>linear sensitivity. Increased alone, it can burn the <em>Parvo (details channel)</em> output image. If<br>adjusted in collaboration with <strong>ganglionCellsSensitivity</strong>,images can be very contrasted<br>whatever the local luminance there is… at the cost of a naturalness decrease.</li>
<li><strong>photoreceptorsTemporalConstant</strong> this setups the temporal constant of the low pass filter<br>effect at the entry of the retina. High value leads to strong temporal smoothing effect : moving<br>objects are blurred and can disappear while static object are favored. But when starting the<br>retina processing, stable state is reached later.</li>
<li><strong>photoreceptorsSpatialConstant</strong> specifies the spatial constant related to photo-receptors’ low<br>pass filter’s effect. Those parameters specify the minimum value of the spatial signal period allowed<br>in what follows. Typically, this filter should cut high frequency noise. On the other hand, a 0 value<br>cuts none of the noise while higher values start to cut high spatial frequencies, and progressively<br>lower frequencies… Be aware to not go to high levels if you want to see some details of the input images !<br>A good compromise for color images is a 0.53 value since such choice won’t affect too much the color spectrum.<br>Higher values would lead to gray and blurred output images.</li>
</ul>
<h4 id="Horizontal-cells-parameters"><a href="#Horizontal-cells-parameters" class="headerlink" title="Horizontal cells parameters"></a>Horizontal cells parameters</h4><p>This parameter set tunes the neural network connected to the photo-receptors, the horizontal cells.<br>It modulates photo-receptors sensitivity and completes the processing for final spectral whitening<br>(part of the spatial band pass effect thus favoring visual details enhancement).</p>
<ul>
<li><strong>horizontalCellsGain</strong> here is a critical parameter ! If you are not interested with the mean<br>luminance and want just to focus on details enhancement, then, set this parameterto zero. However, if<br>you want to keep some environment luminance’s data, let some low spatial frequencies pass into the system and set a<br>higher value (&lt;1).</li>
<li><strong>hcellsTemporalConstant</strong> similar to photo-receptors, this parameter acts on the temporal constant of a<br>low pass temporal filter that smoothes input data. Here, a high value generates a high retina<br>after effect while a lower value makes the retina more reactive. This value should be lower than<br><strong>photoreceptorsTemporalConstant</strong> to limit strong retina after effects.</li>
<li><strong>hcellsSpatialConstant</strong> is the spatial constant of these cells filter’s low pass one.<br>It specifies the lowest spatial frequency allowed in what follows. Visually, a high value leads<br>to very low spatial frequencies processing and leads to salient halo effects. Lower values<br>reduce this effect but has the limit of not go lower than the value of<br><strong>photoreceptorsSpatialConstant</strong>. Those 2 parameters actually specify the spatial band-pass of<br>the retina.</li>
</ul>
<p><strong>NOTE</strong> Once the processing managed by the previous parameters is done, input data is cleaned from noise<br>and luminance is already partly enhanced. The following parameters act on the last processing stages<br>of the two outing retina signals.</p>
<h4 id="Parvo-details-channel-dedicated-parameter"><a href="#Parvo-details-channel-dedicated-parameter" class="headerlink" title="Parvo (details channel) dedicated parameter"></a>Parvo (details channel) dedicated parameter</h4><ul>
<li><strong>ganglionCellsSensitivity</strong> specifies the strength of the final local adaptation occurring at<br>the output of this details’ dedicated channel. Parameter values remain between 0 and 1. Low value<br>tend to give a linear response while higher values enforce the remaining low contrasted areas.</li>
</ul>
<p><strong>Note :</strong> this parameter can correct eventual burned images by favoring low energetic details of<br>the visual scene, even in bright areas.</p>
<h4 id="IPL-Magno-motion-x2F-transient-channel-parameters"><a href="#IPL-Magno-motion-x2F-transient-channel-parameters" class="headerlink" title="IPL Magno (motion&#x2F;transient channel) parameters"></a>IPL Magno (motion&#x2F;transient channel) parameters</h4><p>Once image’s information are cleaned, this channel acts as a high pass temporal filter that<br>selects only the signals related to transient signals (events, motion, etc.). A low pass spatial filter<br>smoothes extracted transient data while a final logarithmic compression enhances low transient events<br>thus enhancing event sensitivity.</p>
<ul>
<li><strong>parasolCells_beta</strong> generally set to zero, can be considered as an amplifier gain at the<br>entry point of this processing stage. Generally set to 0.</li>
<li><strong>parasolCells_tau</strong> the temporal smoothing effect that can be added</li>
<li><strong>parasolCells_k</strong> the spatial constant of the spatial filtering effect, set it at a high value<br>to favor low spatial frequency signals that are lower subject for residual noise.</li>
<li><strong>amacrinCellsTemporalCutFrequency</strong> specifies the temporal constant of the high pass filter.<br>High values let slow transient events to be selected.</li>
<li><strong>V0CompressionParameter</strong> specifies the strength of the log compression. Similar behaviors to<br>previous description but here  enforces sensitivity of transient events.</li>
<li><strong>localAdaptintegration_tau</strong> generally set to 0, has no real use actually in here.</li>
<li><strong>localAdaptintegration_k</strong> specifies the size of the area on which local adaptation is<br>performed. Low values lead to short range local adaptation (higher sensitivity to noise), high<br>values secure log compression.</li>
</ul>
