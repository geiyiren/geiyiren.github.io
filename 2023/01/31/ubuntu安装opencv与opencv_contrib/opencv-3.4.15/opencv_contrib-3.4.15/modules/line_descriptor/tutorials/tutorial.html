<h1 id="Line-Features-Tutorial-tutorial-line-descriptor-main"><a href="#Line-Features-Tutorial-tutorial-line-descriptor-main" class="headerlink" title="Line Features Tutorial {#tutorial_line_descriptor_main}"></a>Line Features Tutorial {#tutorial_line_descriptor_main}</h1><p>In this tutorial it will be shown how to:</p>
<ul>
<li>use the <em>BinaryDescriptor</em> interface to extract lines and store them in <em>KeyLine</em> objects</li>
<li>use the same interface to compute descriptors for every extracted line</li>
<li>use the <em>BynaryDescriptorMatcher</em> to determine matches among descriptors obtained from different<br>images</li>
</ul>
<h2 id="Lines-extraction-and-descriptors-computation"><a href="#Lines-extraction-and-descriptors-computation" class="headerlink" title="Lines extraction and descriptors computation"></a>Lines extraction and descriptors computation</h2><p>In the following snippet of code, it is shown how to detect lines from an image. The LSD extractor<br>is initialized with <em>LSD_REFINE_ADV</em> option; remaining parameters are left to their default<br>values. A mask of ones is used in order to accept all extracted lines, which, at the end, are<br>displayed using random colors for octave 0.</p>
<p>@includelineno line_descriptor&#x2F;samples&#x2F;lsd_lines_extraction.cpp</p>
<p>This is the result obtained for famous cameraman image:</p>
<p><img src="/pics/lines_cameraman_edl.png" alt="alternate text"></p>
<p>Another way to extract lines is using <em>LSDDetector</em> class; such class uses the LSD extractor to<br>compute lines. To obtain this result, it is sufficient to use the snippet code seen above, just<br>modifying it by the rows</p>
<p>@code{.cpp}<br>&#x2F;&#x2F; create a pointer to an LSDDetector object<br>Ptr<LSDDetector> lsd &#x3D; LSDDetector::createLSDDetector();</p>
<p>&#x2F;&#x2F; compute lines<br>std::vector<KeyLine> keylines;<br>lsd-&gt;detect( imageMat, keylines, mask );<br>@endcode</p>
<p>Here’s the result returned by LSD detector again on cameraman picture:</p>
<p><img src="/pics/cameraman_lines2.png" alt="alternate text"></p>
<p>Once keylines have been detected, it is possible to compute their descriptors as shown in the<br>following:</p>
<p>@includelineno line_descriptor&#x2F;samples&#x2F;compute_descriptors.cpp</p>
<h2 id="Matching-among-descriptors"><a href="#Matching-among-descriptors" class="headerlink" title="Matching among descriptors"></a>Matching among descriptors</h2><p>If we have extracted descriptors from two different images, it is possible to search for matches<br>among them. One way of doing it is matching exactly a descriptor to each input query descriptor,<br>choosing the one at closest distance:</p>
<p>@includelineno line_descriptor&#x2F;samples&#x2F;matching.cpp</p>
<p>Sometimes, we could be interested in searching for the closest <em>k</em> descriptors, given an input one.<br>This requires to modify slightly previous code:</p>
<p>@code{.cpp}<br>&#x2F;&#x2F; prepare a structure to host matches<br>std::vector&lt;std::vector<DMatch> &gt; matches;</p>
<p>&#x2F;&#x2F; require knn match<br>bdm-&gt;knnMatch( descr1, descr2, matches, 6 );<br>@endcode</p>
<p>In the above example, the closest 6 descriptors are returned for every query. In some cases, we<br>could have a search radius and look for all descriptors distant at the most <em>r</em> from input query.<br>Previous code must me modified:</p>
<p>@code{.cpp}<br>&#x2F;&#x2F; prepare a structure to host matches<br>std::vector&lt;std::vector<DMatch> &gt; matches;</p>
<p>&#x2F;&#x2F; compute matches<br>bdm-&gt;radiusMatch( queries, matches, 30 );<br>@endcode</p>
<p>Here’s an example om matching among descriptors extratced from original cameraman image and its<br>downsampled (and blurred) version:</p>
<p><img src="/pics/matching2.png" alt="alternate text"></p>
<h2 id="Querying-internal-database"><a href="#Querying-internal-database" class="headerlink" title="Querying internal database"></a>Querying internal database</h2><p>The <em>BynaryDescriptorMatcher</em> class, owns an internal database that can be populated with<br>descriptors extracted from different images and queried using one of the modalities described in<br>previous section. Population of internal dataset can be done using the <em>add</em> function; such function<br>doesn’t directly add new data to database, but it just stores it them locally. The real update<br>happens when function <em>train</em> is invoked or when any querying function is executed, since each of<br>them invokes <em>train</em> before querying. When queried, internal database not only returns required<br>descriptors, but, for every returned match, it is able to tell which image matched descriptor was<br>extracted from. An example of internal dataset usage is described in the following code; after<br>adding locally new descriptors, a radius search is invoked. This provokes local data to be<br>transferred to dataset, which, in turn, is then queried.</p>
<p>@includelineno line_descriptor&#x2F;samples&#x2F;radius_matching.cpp</p>
