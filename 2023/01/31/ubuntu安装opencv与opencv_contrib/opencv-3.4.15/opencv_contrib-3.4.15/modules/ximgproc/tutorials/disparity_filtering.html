<h1 id="Disparity-map-post-filtering-tutorial-ximgproc-disparity-filtering"><a href="#Disparity-map-post-filtering-tutorial-ximgproc-disparity-filtering" class="headerlink" title="Disparity map post-filtering {#tutorial_ximgproc_disparity_filtering}"></a>Disparity map post-filtering {#tutorial_ximgproc_disparity_filtering}</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Stereo matching algorithms, especially highly-optimized ones that are intended for real-time processing<br>on CPU, tend to make quite a few errors on challenging sequences. These errors are usually concentrated<br>in uniform texture-less areas, half-occlusions and regions near depth discontinuities. One way of dealing<br>with stereo-matching errors is to use various techniques of detecting potentially inaccurate disparity<br>values and invalidate them, therefore making the disparity map semi-sparse. Several such techniques are<br>already implemented in the StereoBM and StereoSGBM algorithms. Another way would be to use some kind of<br>filtering procedure to align the disparity map edges with those of the source image and to propagate<br>the disparity values from high- to low-confidence regions like half-occlusions. Recent advances in<br>edge-aware filtering have enabled performing such post-filtering under the constraints of real-time<br>processing on CPU.</p>
<p>In this tutorial you will learn how to use the disparity map post-filtering to improve the results<br>of StereoBM and StereoSGBM algorithms.</p>
<h2 id="Source-Stereoscopic-Image"><a href="#Source-Stereoscopic-Image" class="headerlink" title="Source Stereoscopic Image"></a>Source Stereoscopic Image</h2><p><img src="/images/ambush_5_left.jpg" alt="Left view"><br><img src="/images/ambush_5_right.jpg" alt="Right view"></p>
<h2 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h2><p>We will be using snippets from the example application, that can be downloaded <a href="https://github.com/opencv/opencv_contrib/blob/master/modules/ximgproc/samples/disparity_filtering.cpp">here </a>.</p>
<h2 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h2><p>The provided example has several options that yield different trade-offs between the speed and<br>the quality of the resulting disparity map. Both the speed and the quality are measured if the user<br>has provided the ground-truth disparity map. In this tutorial we will take a detailed look at the<br>default pipeline, that was designed to provide the best possible quality under the constraints of<br>real-time processing on CPU.</p>
<p>-#  <strong>Load left and right views</strong><br>    @snippet ximgproc&#x2F;samples&#x2F;disparity_filtering.cpp load_views<br>    We start by loading the source stereopair. For this tutorial we will take a somewhat challenging<br>    example from the MPI-Sintel dataset with a lot of texture-less regions.</p>
<p>-#  <strong>Prepare the views for matching</strong><br>    @snippet ximgproc&#x2F;samples&#x2F;disparity_filtering.cpp downscale<br>    We perform downscaling of the views to speed-up the matching stage at the cost of minor<br>    quality degradation. To get the best possible quality downscaling should be avoided.</p>
<p>-#  <strong>Perform matching and create the filter instance</strong><br>    @snippet ximgproc&#x2F;samples&#x2F;disparity_filtering.cpp matching<br>    We are using StereoBM for faster processing. If speed is not critical, though,<br>    StereoSGBM would provide better quality. The filter instance is created by providing<br>    the StereoMatcher instance that we intend to use. Another matcher instance is<br>    returned by the createRightMatcher function. These two matcher instances are then<br>    used to compute disparity maps both for the left and right views, that are required<br>    by the filter.</p>
<p>-#  <strong>Perform filtering</strong><br>    @snippet ximgproc&#x2F;samples&#x2F;disparity_filtering.cpp filtering<br>    Disparity maps computed by the respective matcher instances, as well as the source left view<br>    are passed to the filter. Note that we are using the original non-downscaled view to guide the<br>    filtering process. The disparity map is automatically upscaled in an edge-aware fashion to match<br>    the original view resolution. The result is stored in filtered_disp.</p>
<p>-#  <strong>Visualize the disparity maps</strong><br>    @snippet ximgproc&#x2F;samples&#x2F;disparity_filtering.cpp visualization<br>    We use a convenience function getDisparityVis to visualize the disparity maps. The second parameter<br>    defines the contrast (all disparity values are scaled by this value in the visualization).</p>
<h2 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h2><p><img src="/images/ambush_5_bm.png" alt="Result of the StereoBM"><br><img src="/images/ambush_5_bm_with_filter.png" alt="Result of the demonstrated pipeline (StereoBM on downscaled views with post-filtering)"></p>
