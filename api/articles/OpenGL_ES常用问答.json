{"title":"OpenGL_ES常用问答","slug":"OpenGL_ES常用问答","date":"2023-06-21T10:10:00.000Z","updated":"2023-11-24T15:10:46.420Z","comments":true,"path":"api/articles/OpenGL_ES常用问答.json","excerpt":null,"covers":null,"content":"<h1 id=\"glUseProgram什么时候使用\"><a href=\"#glUseProgram什么时候使用\" class=\"headerlink\" title=\"glUseProgram什么时候使用?\"></a>glUseProgram什么时候使用?</h1><p>glUseProgram是OpenGL中的一个函数，用于指定当前使用的着色器程序对象。着色器程序对象是由顶点着色器和片段着色器组成的，用于描述渲染管线中的图形处理和光栅化阶段。</p>\n<p>glUseProgram函数的调用时机通常是在绘制场景之前。当你创建并编译好顶点着色器和片段着色器，并将它们链接为一个着色器程序对象后，你需要使用glUseProgram来告诉OpenGL在绘制时要使用这个着色器程序。</p>\n<p>具体的步骤通常是这样的：</p>\n<blockquote>\n<ol>\n<li>创建顶点着色器和片段着色器，并编译它们。</li>\n<li>创建一个着色器程序对象，并将顶点着色器和片段着色器附加到该对象上。</li>\n<li>链接着色器程序对象。</li>\n<li>在每次绘制场景之前，调用glUseProgram函数，将着色器程序对象作为参数传递进去，以指定当前使用的着色器程序。</li>\n<li>执行绘制操作，OpenGL将使用当前指定的着色器程序进行渲染。</li>\n</ol>\n</blockquote>\n<p>通过glUseProgram函数，你可以在渲染过程中灵活地切换不同的着色器程序，以实现不同的渲染效果或实现特定的图形处理算法。</p>\n<h1 id=\"glActiveTexture什么时候使用\"><a href=\"#glActiveTexture什么时候使用\" class=\"headerlink\" title=\"glActiveTexture什么时候使用?\"></a>glActiveTexture什么时候使用?</h1><p>glActiveTexture是OpenGL中的一个函数，用于指定当前活动的纹理单元。纹理单元是用于存储和处理纹理数据的硬件单元。</p>\n<p>glActiveTexture函数的调用时机通常是在设置纹理之前。在渲染过程中，你可能会使用多个纹理，例如一张用于漫反射贴图，一张用于法线贴图等。glActiveTexture函数允许你指定当前要操作的纹理单元，以便后续的纹理相关函数能够作用于指定的单元。</p>\n<p>具体的步骤通常是这样的：</p>\n<ol>\n<li>在绑定纹理之前，调用glActiveTexture函数，传递一个纹理单元的索引作为参数。常用的索引值为GL_TEXTURE0、GL_TEXTURE1等，表示不同的纹理单元。</li>\n<li>绑定纹理对象到指定的纹理单元。使用glBindTexture函数将纹理对象与当前活动的纹理单元关联起来。例如，使用glBindTexture(GL_TEXTURE_2D, textureID)将纹理对象绑定到当前活动的纹理单元上。</li>\n<li>设置纹理参数和上传纹理数据等操作。在glActiveTexture函数和glBindTexture函数之后，你可以执行一系列与纹理相关的操作，如设置纹理过滤方式、纹理环绕方式、上传纹理数据等。</li>\n</ol>\n<p>通过glActiveTexture函数，你可以在渲染过程中使用多个纹理单元，并对每个纹理单元进行独立的设置和绑定。这样可以实现更复杂的纹理映射效果，如多重纹理、立方体贴图等。</p>\n<h1 id=\"怎么从缓冲区读取像素数据？\"><a href=\"#怎么从缓冲区读取像素数据？\" class=\"headerlink\" title=\"怎么从缓冲区读取像素数据？\"></a>怎么从缓冲区读取像素数据？</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取颜色缓冲区的像素数据</span></span><br><span class=\"line\">       <span class=\"function\">std::vector&lt;<span class=\"type\">unsigned</span> <span class=\"type\">char</span>&gt; <span class=\"title\">pixelData</span><span class=\"params\">(<span class=\"number\">10</span> * <span class=\"number\">10</span> * <span class=\"number\">4</span>)</span></span>; <span class=\"comment\">// RGBA格式，每个像素4个字节</span></span><br><span class=\"line\">       <span class=\"built_in\">glReadPixels</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, GL_RGBA, GL_UNSIGNED_BYTE, pixelData.<span class=\"built_in\">data</span>());</span><br><span class=\"line\">       <span class=\"comment\">// 检查像素数据</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; ++j)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               <span class=\"type\">int</span> pixelIndex = (i * <span class=\"number\">10</span> + j) * <span class=\"number\">4</span>; <span class=\"comment\">// 每个像素4个字节</span></span><br><span class=\"line\">               <span class=\"type\">unsigned</span> <span class=\"type\">char</span> red = pixelData[pixelIndex];</span><br><span class=\"line\">               <span class=\"type\">unsigned</span> <span class=\"type\">char</span> green = pixelData[pixelIndex + <span class=\"number\">1</span>];</span><br><span class=\"line\">               <span class=\"type\">unsigned</span> <span class=\"type\">char</span> blue = pixelData[pixelIndex + <span class=\"number\">2</span>];</span><br><span class=\"line\">               <span class=\"type\">unsigned</span> <span class=\"type\">char</span> alpha = pixelData[pixelIndex + <span class=\"number\">3</span>];</span><br><span class=\"line\">               <span class=\"comment\">// 打印像素值</span></span><br><span class=\"line\">               <span class=\"built_in\">LOGI</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;像素(%d, %d): R=%d, G=%d, B=%d, A=%d\\n&quot;</span>, i, j, red, green, blue, alpha);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"怎么获取opengl-es的错误代码？\"><a href=\"#怎么获取opengl-es的错误代码？\" class=\"headerlink\" title=\"怎么获取opengl es的错误代码？\"></a>怎么获取opengl es的错误代码？</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EGLint status2 = <span class=\"built_in\">eglGetError</span>();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (status2 != EGL_SUCCESS)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">           <span class=\"built_in\">LOGI</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;eglSwapBuffers failed!!!, status= %d\\n&quot;</span>, status2); <span class=\"comment\">// 帧缓冲不完整，eglSwapBuffers 执行失败&#125;</span></span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"VAO绑定怎么使用？\"><a href=\"#VAO绑定怎么使用？\" class=\"headerlink\" title=\"VAO绑定怎么使用？\"></a>VAO绑定怎么使用？</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glBindVertexArray</span>(VAO);</span><br></pre></td></tr></table></figure>\n<p>绑定顶点数组对象,执行VAO绑定之后其后的所有VBO配置都是这个VAO对象的一部分。具体来说，glBindVertexArray的作用是将VAO与当前上下文相关的顶点状态绑定在一起。顶点状态包括顶点属性指针、顶点缓冲对象等。当我们需要绘制时，只需绑定相应的VAO，OpenGL会自动应用之前设置的顶点状态。</p>\n<h1 id=\"glDrawElements函数有什么作用？\"><a href=\"#glDrawElements函数有什么作用？\" class=\"headerlink\" title=\"glDrawElements函数有什么作用？\"></a>glDrawElements函数有什么作用？</h1><p>glDrawElements函数用于绘制索引化的图元，它并不会将绘制结果保存在任何地方。它的作用是根据索引数据来指定绘制顶点的顺序，并将这些顶点渲染到当前帧缓冲对象中。<br>绘制结果的保存通常发生在帧缓冲对象（Framebuffer Object, FBO）中。帧缓冲对象是一个特殊的OpenGL对象，它可以作为渲染目标来保存绘制结果。可以将帧缓冲对象与纹理或渲染缓冲对象关联，以便将绘制结果保存在纹理或渲染缓冲对象中。<br>在使用glDrawElements之前，需要先创建并绑定顶点数组对象（VAO），并将索引数据存储在索引缓冲对象（Index Buffer Object, IBO）中。然后，通过glBindVertexArray绑定VAO，使用glBindBuffer将IBO绑定到GL_ELEMENT_ARRAY_BUFFER目标，以告诉OpenGL使用IBO中的索引来绘制顶点。</p>\n<h1 id=\"怎么设置纹理采样方式和纹理拉伸方式？\"><a href=\"#怎么设置纹理采样方式和纹理拉伸方式？\" class=\"headerlink\" title=\"怎么设置纹理采样方式和纹理拉伸方式？\"></a>怎么设置纹理采样方式和纹理拉伸方式？</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ## 设置纹理拉伸方式</span></span><br><span class=\"line\"><span class=\"built_in\">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); <span class=\"comment\">// 设置纹理 S 横轴）的拉伸方式为截取</span></span><br><span class=\"line\"><span class=\"built_in\">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); <span class=\"comment\">// 设置纹理 T 纵轴）的拉伸方式为截取</span></span><br><span class=\"line\"><span class=\"comment\">// ## 设置纹理采样方式</span></span><br><span class=\"line\"><span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); <span class=\"comment\">// 将纹理缩小时(GL_TEXTURE_MIN_FILTER)，会进行线性插值(GL_LINEAR)来计算新的纹理像素值。</span></span><br><span class=\"line\"><span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); <span class=\"comment\">// 将纹理放大时(GL_TEXTURE_MAG_FILTER)，会进行线性插值(GL_LINEAR)来计算新的纹理像素值。</span></span><br></pre></td></tr></table></figure>\n<p>在OpenGL中，纹理参数是与当前绑定的纹理对象相关联的。当你调用glTexParameterf函数设置纹理参数时，它会作用于当前绑定的纹理对象。<br>要确定glTexParameterf设置的是哪个纹理的参数，需要在调用该函数之前通过glBindTexture函数将相应的纹理对象绑定到当前纹理目标。</p>\n<h1 id=\"Surfaceview和GLSurfaceview有什么区别\"><a href=\"#Surfaceview和GLSurfaceview有什么区别\" class=\"headerlink\" title=\"Surfaceview和GLSurfaceview有什么区别\"></a>Surfaceview和GLSurfaceview有什么区别</h1><p>SurfaceView和GLSurfaceView是Android中用于图形渲染的两个重要视图类，它们之间有以下区别：</p>\n<ol>\n<li><p>功能和用途：SurfaceView是用于显示普通2D图形和视频的视图，而GLSurfaceView则是专门用于显示OpenGL ES图形的视图。GLSurfaceView提供了与OpenGL ES渲染相关的功能和接口，可以更方便地进行OpenGL ES的初始化、渲染和交互操作。</p>\n</li>\n<li><p>渲染机制：SurfaceView使用双缓冲机制进行绘制，即在后台线程中渲染图形，并将渲染结果通过SurfaceHolder进行显示。这种机制使得SurfaceView能够在主UI线程之外进行绘制，适用于需要频繁更新的图形或视频场景。GLSurfaceView也采用了双缓冲机制，但它使用了专门的渲染线程，并提供了OpenGL ES渲染上下文的管理和控制。</p>\n</li>\n<li><p>对性能的要求：由于SurfaceView在单独的线程中进行渲染，因此它更适合于需要高性能渲染的场景，如视频播放、游戏等。GLSurfaceView在底层使用了OpenGL ES，因此可以更高效地进行图形渲染，并提供了更多与OpenGL ES相关的功能和特性。</p>\n</li>\n<li><p>交互处理：SurfaceView的UI事件处理是在主UI线程中进行的，而GLSurfaceView可以通过设置Renderer来处理与OpenGL ES相关的交互事件，如触摸事件、按键事件等。</p>\n</li>\n<li><p>使用SurfaceView时候需要单独开启线程进行循环渲染，而GLSurfaceView在每帧渲染之前会自动调用onDrawFrame函数，因此我们可以将渲染程序写在onDrawFrame中，无线单独开启线程。</p>\n</li>\n<li><p>使用SurfaceView时候需要绑定窗口并设置窗口属性，而GLSurfaceView默认绑定当前窗口，无需额外绑定。</p>\n</li>\n</ol>\n<p>综上所述，SurfaceView适用于普通的2D图形和视频显示，而GLSurfaceView则专注于OpenGL ES图形渲染，并提供更高性能和更多的OpenGL ES功能。选择使用哪个类取决于你的具体需求和场景。</p>\n<script type=\"text&#x2F;javascript\" src=\"https://unpkg.com/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css\">","more":"<h1 id=\"glUseProgram什么时候使用\"><a href=\"#glUseProgram什么时候使用\" class=\"headerlink\" title=\"glUseProgram什么时候使用?\"></a>glUseProgram什么时候使用?</h1><p>glUseProgram是OpenGL中的一个函数，用于指定当前使用的着色器程序对象。着色器程序对象是由顶点着色器和片段着色器组成的，用于描述渲染管线中的图形处理和光栅化阶段。</p>\n<p>glUseProgram函数的调用时机通常是在绘制场景之前。当你创建并编译好顶点着色器和片段着色器，并将它们链接为一个着色器程序对象后，你需要使用glUseProgram来告诉OpenGL在绘制时要使用这个着色器程序。</p>\n<p>具体的步骤通常是这样的：</p>\n<blockquote>\n<ol>\n<li>创建顶点着色器和片段着色器，并编译它们。</li>\n<li>创建一个着色器程序对象，并将顶点着色器和片段着色器附加到该对象上。</li>\n<li>链接着色器程序对象。</li>\n<li>在每次绘制场景之前，调用glUseProgram函数，将着色器程序对象作为参数传递进去，以指定当前使用的着色器程序。</li>\n<li>执行绘制操作，OpenGL将使用当前指定的着色器程序进行渲染。</li>\n</ol>\n</blockquote>\n<p>通过glUseProgram函数，你可以在渲染过程中灵活地切换不同的着色器程序，以实现不同的渲染效果或实现特定的图形处理算法。</p>\n<h1 id=\"glActiveTexture什么时候使用\"><a href=\"#glActiveTexture什么时候使用\" class=\"headerlink\" title=\"glActiveTexture什么时候使用?\"></a>glActiveTexture什么时候使用?</h1><p>glActiveTexture是OpenGL中的一个函数，用于指定当前活动的纹理单元。纹理单元是用于存储和处理纹理数据的硬件单元。</p>\n<p>glActiveTexture函数的调用时机通常是在设置纹理之前。在渲染过程中，你可能会使用多个纹理，例如一张用于漫反射贴图，一张用于法线贴图等。glActiveTexture函数允许你指定当前要操作的纹理单元，以便后续的纹理相关函数能够作用于指定的单元。</p>\n<p>具体的步骤通常是这样的：</p>\n<ol>\n<li>在绑定纹理之前，调用glActiveTexture函数，传递一个纹理单元的索引作为参数。常用的索引值为GL_TEXTURE0、GL_TEXTURE1等，表示不同的纹理单元。</li>\n<li>绑定纹理对象到指定的纹理单元。使用glBindTexture函数将纹理对象与当前活动的纹理单元关联起来。例如，使用glBindTexture(GL_TEXTURE_2D, textureID)将纹理对象绑定到当前活动的纹理单元上。</li>\n<li>设置纹理参数和上传纹理数据等操作。在glActiveTexture函数和glBindTexture函数之后，你可以执行一系列与纹理相关的操作，如设置纹理过滤方式、纹理环绕方式、上传纹理数据等。</li>\n</ol>\n<p>通过glActiveTexture函数，你可以在渲染过程中使用多个纹理单元，并对每个纹理单元进行独立的设置和绑定。这样可以实现更复杂的纹理映射效果，如多重纹理、立方体贴图等。</p>\n<h1 id=\"怎么从缓冲区读取像素数据？\"><a href=\"#怎么从缓冲区读取像素数据？\" class=\"headerlink\" title=\"怎么从缓冲区读取像素数据？\"></a>怎么从缓冲区读取像素数据？</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取颜色缓冲区的像素数据</span></span><br><span class=\"line\">       <span class=\"function\">std::vector&lt;<span class=\"type\">unsigned</span> <span class=\"type\">char</span>&gt; <span class=\"title\">pixelData</span><span class=\"params\">(<span class=\"number\">10</span> * <span class=\"number\">10</span> * <span class=\"number\">4</span>)</span></span>; <span class=\"comment\">// RGBA格式，每个像素4个字节</span></span><br><span class=\"line\">       <span class=\"built_in\">glReadPixels</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>, <span class=\"number\">10</span>, GL_RGBA, GL_UNSIGNED_BYTE, pixelData.<span class=\"built_in\">data</span>());</span><br><span class=\"line\">       <span class=\"comment\">// 检查像素数据</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">10</span>; ++j)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               <span class=\"type\">int</span> pixelIndex = (i * <span class=\"number\">10</span> + j) * <span class=\"number\">4</span>; <span class=\"comment\">// 每个像素4个字节</span></span><br><span class=\"line\">               <span class=\"type\">unsigned</span> <span class=\"type\">char</span> red = pixelData[pixelIndex];</span><br><span class=\"line\">               <span class=\"type\">unsigned</span> <span class=\"type\">char</span> green = pixelData[pixelIndex + <span class=\"number\">1</span>];</span><br><span class=\"line\">               <span class=\"type\">unsigned</span> <span class=\"type\">char</span> blue = pixelData[pixelIndex + <span class=\"number\">2</span>];</span><br><span class=\"line\">               <span class=\"type\">unsigned</span> <span class=\"type\">char</span> alpha = pixelData[pixelIndex + <span class=\"number\">3</span>];</span><br><span class=\"line\">               <span class=\"comment\">// 打印像素值</span></span><br><span class=\"line\">               <span class=\"built_in\">LOGI</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;像素(%d, %d): R=%d, G=%d, B=%d, A=%d\\n&quot;</span>, i, j, red, green, blue, alpha);</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"怎么获取opengl-es的错误代码？\"><a href=\"#怎么获取opengl-es的错误代码？\" class=\"headerlink\" title=\"怎么获取opengl es的错误代码？\"></a>怎么获取opengl es的错误代码？</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EGLint status2 = <span class=\"built_in\">eglGetError</span>();</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (status2 != EGL_SUCCESS)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">           <span class=\"built_in\">LOGI</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;eglSwapBuffers failed!!!, status= %d\\n&quot;</span>, status2); <span class=\"comment\">// 帧缓冲不完整，eglSwapBuffers 执行失败&#125;</span></span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"VAO绑定怎么使用？\"><a href=\"#VAO绑定怎么使用？\" class=\"headerlink\" title=\"VAO绑定怎么使用？\"></a>VAO绑定怎么使用？</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">glBindVertexArray</span>(VAO);</span><br></pre></td></tr></table></figure>\n<p>绑定顶点数组对象,执行VAO绑定之后其后的所有VBO配置都是这个VAO对象的一部分。具体来说，glBindVertexArray的作用是将VAO与当前上下文相关的顶点状态绑定在一起。顶点状态包括顶点属性指针、顶点缓冲对象等。当我们需要绘制时，只需绑定相应的VAO，OpenGL会自动应用之前设置的顶点状态。</p>\n<h1 id=\"glDrawElements函数有什么作用？\"><a href=\"#glDrawElements函数有什么作用？\" class=\"headerlink\" title=\"glDrawElements函数有什么作用？\"></a>glDrawElements函数有什么作用？</h1><p>glDrawElements函数用于绘制索引化的图元，它并不会将绘制结果保存在任何地方。它的作用是根据索引数据来指定绘制顶点的顺序，并将这些顶点渲染到当前帧缓冲对象中。<br>绘制结果的保存通常发生在帧缓冲对象（Framebuffer Object, FBO）中。帧缓冲对象是一个特殊的OpenGL对象，它可以作为渲染目标来保存绘制结果。可以将帧缓冲对象与纹理或渲染缓冲对象关联，以便将绘制结果保存在纹理或渲染缓冲对象中。<br>在使用glDrawElements之前，需要先创建并绑定顶点数组对象（VAO），并将索引数据存储在索引缓冲对象（Index Buffer Object, IBO）中。然后，通过glBindVertexArray绑定VAO，使用glBindBuffer将IBO绑定到GL_ELEMENT_ARRAY_BUFFER目标，以告诉OpenGL使用IBO中的索引来绘制顶点。</p>\n<h1 id=\"怎么设置纹理采样方式和纹理拉伸方式？\"><a href=\"#怎么设置纹理采样方式和纹理拉伸方式？\" class=\"headerlink\" title=\"怎么设置纹理采样方式和纹理拉伸方式？\"></a>怎么设置纹理采样方式和纹理拉伸方式？</h1><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ## 设置纹理拉伸方式</span></span><br><span class=\"line\"><span class=\"built_in\">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); <span class=\"comment\">// 设置纹理 S 横轴）的拉伸方式为截取</span></span><br><span class=\"line\"><span class=\"built_in\">glTexParameterf</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); <span class=\"comment\">// 设置纹理 T 纵轴）的拉伸方式为截取</span></span><br><span class=\"line\"><span class=\"comment\">// ## 设置纹理采样方式</span></span><br><span class=\"line\"><span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); <span class=\"comment\">// 将纹理缩小时(GL_TEXTURE_MIN_FILTER)，会进行线性插值(GL_LINEAR)来计算新的纹理像素值。</span></span><br><span class=\"line\"><span class=\"built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); <span class=\"comment\">// 将纹理放大时(GL_TEXTURE_MAG_FILTER)，会进行线性插值(GL_LINEAR)来计算新的纹理像素值。</span></span><br></pre></td></tr></table></figure>\n<p>在OpenGL中，纹理参数是与当前绑定的纹理对象相关联的。当你调用glTexParameterf函数设置纹理参数时，它会作用于当前绑定的纹理对象。<br>要确定glTexParameterf设置的是哪个纹理的参数，需要在调用该函数之前通过glBindTexture函数将相应的纹理对象绑定到当前纹理目标。</p>\n<h1 id=\"Surfaceview和GLSurfaceview有什么区别\"><a href=\"#Surfaceview和GLSurfaceview有什么区别\" class=\"headerlink\" title=\"Surfaceview和GLSurfaceview有什么区别\"></a>Surfaceview和GLSurfaceview有什么区别</h1><p>SurfaceView和GLSurfaceView是Android中用于图形渲染的两个重要视图类，它们之间有以下区别：</p>\n<ol>\n<li><p>功能和用途：SurfaceView是用于显示普通2D图形和视频的视图，而GLSurfaceView则是专门用于显示OpenGL ES图形的视图。GLSurfaceView提供了与OpenGL ES渲染相关的功能和接口，可以更方便地进行OpenGL ES的初始化、渲染和交互操作。</p>\n</li>\n<li><p>渲染机制：SurfaceView使用双缓冲机制进行绘制，即在后台线程中渲染图形，并将渲染结果通过SurfaceHolder进行显示。这种机制使得SurfaceView能够在主UI线程之外进行绘制，适用于需要频繁更新的图形或视频场景。GLSurfaceView也采用了双缓冲机制，但它使用了专门的渲染线程，并提供了OpenGL ES渲染上下文的管理和控制。</p>\n</li>\n<li><p>对性能的要求：由于SurfaceView在单独的线程中进行渲染，因此它更适合于需要高性能渲染的场景，如视频播放、游戏等。GLSurfaceView在底层使用了OpenGL ES，因此可以更高效地进行图形渲染，并提供了更多与OpenGL ES相关的功能和特性。</p>\n</li>\n<li><p>交互处理：SurfaceView的UI事件处理是在主UI线程中进行的，而GLSurfaceView可以通过设置Renderer来处理与OpenGL ES相关的交互事件，如触摸事件、按键事件等。</p>\n</li>\n<li><p>使用SurfaceView时候需要单独开启线程进行循环渲染，而GLSurfaceView在每帧渲染之前会自动调用onDrawFrame函数，因此我们可以将渲染程序写在onDrawFrame中，无线单独开启线程。</p>\n</li>\n<li><p>使用SurfaceView时候需要绑定窗口并设置窗口属性，而GLSurfaceView默认绑定当前窗口，无需额外绑定。</p>\n</li>\n</ol>\n<p>综上所述，SurfaceView适用于普通的2D图形和视频显示，而GLSurfaceView则专注于OpenGL ES图形渲染，并提供更高性能和更多的OpenGL ES功能。选择使用哪个类取决于你的具体需求和场景。</p>\n","categories":[{"name":"OpenGL ES","path":"api/categories/OpenGL ES.json"}],"tags":[{"name":"OpenGL ES","path":"api/tags/OpenGL ES.json"}]}