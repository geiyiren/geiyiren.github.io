{"title":"malloc申请内存访问时容易出现的访问越界问题","slug":"malloc申请内存访问时容易出现的访问越界问题","date":"2022-12-15T18:59:07.000Z","updated":"2023-11-24T15:10:46.424Z","comments":true,"path":"api/articles/malloc申请内存访问时容易出现的访问越界问题.json","excerpt":null,"covers":null,"content":"<h1 id=\"malloc相关\"><a href=\"#malloc相关\" class=\"headerlink\" title=\"malloc相关\"></a>malloc相关</h1><h2 id=\"malloc申请内存访问bug\"><a href=\"#malloc申请内存访问bug\" class=\"headerlink\" title=\"malloc申请内存访问bug\"></a>malloc申请内存访问bug</h2><ul>\n<li>在访问malloc申请的内存时，如果访问越界时不会提示错误，而是继续操作错误的内存块，这一类的错误较为隐秘。</li>\n<li>例如：在构建图像变换的map映射表时，申请存放map映射关系的内存块的大小并不是输出图像对应的大小，而是输出图像大小的2倍，因此此时存储的是像素位置(x,y)的映射关系。  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构建4路YUV鱼眼图像去畸变映射关系</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dist2undist</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> point_u_tmp[<span class=\"number\">2</span>], point_d_tmp[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">float</span> sf = <span class=\"number\">1.5</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> img_out_height = <span class=\"number\">720</span> * img_out_h_scale;</span><br><span class=\"line\">    <span class=\"type\">int</span> img_out_width = <span class=\"number\">1280</span> * img_out_w_scale;</span><br><span class=\"line\">    <span class=\"built_in\">LOGI</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;dist2undist begin !,img_out size(%d,%d)&quot;</span>, img_out_height, img_out_width);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; NUM_CAMERAS; index++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里就是bug所在</span></span><br><span class=\"line\">        undist_map[index] = (<span class=\"type\">float</span> *)<span class=\"built_in\">malloc</span>(undistView_width * undistView_height * <span class=\"number\">3</span> / <span class=\"number\">2</span> * <span class=\"number\">2</span> * <span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (undist_map[index] == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOGI</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;undist_map malloc failed!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; img_out_height; i += <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; img_out_width; j += <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                point_u_tmp[<span class=\"number\">0</span>] = j / img_out_w_scale;</span><br><span class=\"line\">                point_u_tmp[<span class=\"number\">1</span>] = i / img_out_h_scale;</span><br><span class=\"line\">                <span class=\"built_in\">LDC_UndistToDistExt</span>(&amp;ldc[<span class=\"number\">0</span>], point_u_tmp, point_d_tmp, sf);</span><br><span class=\"line\"></span><br><span class=\"line\">                undist_map[index][(i * img_out_width + j) * <span class=\"number\">2</span>] = point_d_tmp[<span class=\"number\">0</span>] * img_in_w_scale;</span><br><span class=\"line\">                undist_map[index][(i * img_out_width + j) * <span class=\"number\">2</span> + <span class=\"number\">1</span>] = point_d_tmp[<span class=\"number\">1</span>] * img_in_h_scale;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!<span class=\"built_in\">int</span>(j % <span class=\"number\">2</span>))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    undist_map[index][(i / <span class=\"number\">2</span> * img_out_width + j + img_out_width * img_out_height) * <span class=\"number\">2</span>] = <span class=\"built_in\">int</span>(point_d_tmp[<span class=\"number\">0</span>] * img_in_w_scale / <span class=\"number\">2</span>) * <span class=\"number\">2</span>;</span><br><span class=\"line\">                    undist_map[index][(i / <span class=\"number\">2</span> * img_out_width + j + img_out_width * img_out_height) * <span class=\"number\">2</span> + <span class=\"number\">1</span>] = <span class=\"built_in\">int</span>(point_d_tmp[<span class=\"number\">1</span>] * img_in_h_scale / <span class=\"number\">2</span>) + <span class=\"number\">720</span> * img_in_h_scale;</span><br><span class=\"line\">                    undist_map[index][(i / <span class=\"number\">2</span> * img_out_width + j + img_out_width * img_out_height + <span class=\"number\">1</span>) * <span class=\"number\">2</span>] = <span class=\"built_in\">int</span>(point_d_tmp[<span class=\"number\">0</span>] * img_in_w_scale / <span class=\"number\">2</span>) * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    undist_map[index][(i / <span class=\"number\">2</span> * img_out_width + j + img_out_width * img_out_height + <span class=\"number\">1</span>) * <span class=\"number\">2</span> + <span class=\"number\">1</span>] = <span class=\"built_in\">int</span>(point_d_tmp[<span class=\"number\">1</span>] * img_in_h_scale / <span class=\"number\">2</span>) + <span class=\"number\">720</span> * img_in_h_scale;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n如果 #18 行中申请内存为:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undist_map[index] = (<span class=\"type\">float</span> *)<span class=\"built_in\">malloc</span>(undistView_width * undistView_height * <span class=\"number\">3</span> / <span class=\"number\">2</span> * <span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>));</span><br></pre></td></tr></table></figure>\n<p>那么，后面构建map映射关系时并不会出现越界访问提示，甚至后面如果不再申请内存块的情况下，继续越界访问undist_map中的内容也不会报错；但是，如果后面继续申请内存块来使用的时候，后续的内存块可能就会和undist_map内存冲突。  </p>\n<hr>\n<p><font color=Red><strong>总结</strong></font><br>使用malloc申请内存并访问时，注意访问是否越界，且访问越界不报错。</p>\n<script type=\"text&#x2F;javascript\" src=\"https://unpkg.com/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css\">","more":"<h1 id=\"malloc相关\"><a href=\"#malloc相关\" class=\"headerlink\" title=\"malloc相关\"></a>malloc相关</h1><h2 id=\"malloc申请内存访问bug\"><a href=\"#malloc申请内存访问bug\" class=\"headerlink\" title=\"malloc申请内存访问bug\"></a>malloc申请内存访问bug</h2><ul>\n<li>在访问malloc申请的内存时，如果访问越界时不会提示错误，而是继续操作错误的内存块，这一类的错误较为隐秘。</li>\n<li>例如：在构建图像变换的map映射表时，申请存放map映射关系的内存块的大小并不是输出图像对应的大小，而是输出图像大小的2倍，因此此时存储的是像素位置(x,y)的映射关系。  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构建4路YUV鱼眼图像去畸变映射关系</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">dist2undist</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">float</span> point_u_tmp[<span class=\"number\">2</span>], point_d_tmp[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"type\">float</span> sf = <span class=\"number\">1.5</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> img_out_height = <span class=\"number\">720</span> * img_out_h_scale;</span><br><span class=\"line\">    <span class=\"type\">int</span> img_out_width = <span class=\"number\">1280</span> * img_out_w_scale;</span><br><span class=\"line\">    <span class=\"built_in\">LOGI</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;dist2undist begin !,img_out size(%d,%d)&quot;</span>, img_out_height, img_out_width);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> index = <span class=\"number\">0</span>; index &lt; NUM_CAMERAS; index++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这里就是bug所在</span></span><br><span class=\"line\">        undist_map[index] = (<span class=\"type\">float</span> *)<span class=\"built_in\">malloc</span>(undistView_width * undistView_height * <span class=\"number\">3</span> / <span class=\"number\">2</span> * <span class=\"number\">2</span> * <span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (undist_map[index] == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">LOGI</span>(<span class=\"number\">1</span>, <span class=\"string\">&quot;undist_map malloc failed!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; img_out_height; i += <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">0</span>; j &lt; img_out_width; j += <span class=\"number\">1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                point_u_tmp[<span class=\"number\">0</span>] = j / img_out_w_scale;</span><br><span class=\"line\">                point_u_tmp[<span class=\"number\">1</span>] = i / img_out_h_scale;</span><br><span class=\"line\">                <span class=\"built_in\">LDC_UndistToDistExt</span>(&amp;ldc[<span class=\"number\">0</span>], point_u_tmp, point_d_tmp, sf);</span><br><span class=\"line\"></span><br><span class=\"line\">                undist_map[index][(i * img_out_width + j) * <span class=\"number\">2</span>] = point_d_tmp[<span class=\"number\">0</span>] * img_in_w_scale;</span><br><span class=\"line\">                undist_map[index][(i * img_out_width + j) * <span class=\"number\">2</span> + <span class=\"number\">1</span>] = point_d_tmp[<span class=\"number\">1</span>] * img_in_h_scale;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!<span class=\"built_in\">int</span>(j % <span class=\"number\">2</span>))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    undist_map[index][(i / <span class=\"number\">2</span> * img_out_width + j + img_out_width * img_out_height) * <span class=\"number\">2</span>] = <span class=\"built_in\">int</span>(point_d_tmp[<span class=\"number\">0</span>] * img_in_w_scale / <span class=\"number\">2</span>) * <span class=\"number\">2</span>;</span><br><span class=\"line\">                    undist_map[index][(i / <span class=\"number\">2</span> * img_out_width + j + img_out_width * img_out_height) * <span class=\"number\">2</span> + <span class=\"number\">1</span>] = <span class=\"built_in\">int</span>(point_d_tmp[<span class=\"number\">1</span>] * img_in_h_scale / <span class=\"number\">2</span>) + <span class=\"number\">720</span> * img_in_h_scale;</span><br><span class=\"line\">                    undist_map[index][(i / <span class=\"number\">2</span> * img_out_width + j + img_out_width * img_out_height + <span class=\"number\">1</span>) * <span class=\"number\">2</span>] = <span class=\"built_in\">int</span>(point_d_tmp[<span class=\"number\">0</span>] * img_in_w_scale / <span class=\"number\">2</span>) * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    undist_map[index][(i / <span class=\"number\">2</span> * img_out_width + j + img_out_width * img_out_height + <span class=\"number\">1</span>) * <span class=\"number\">2</span> + <span class=\"number\">1</span>] = <span class=\"built_in\">int</span>(point_d_tmp[<span class=\"number\">1</span>] * img_in_h_scale / <span class=\"number\">2</span>) + <span class=\"number\">720</span> * img_in_h_scale;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n如果 #18 行中申请内存为:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">undist_map[index] = (<span class=\"type\">float</span> *)<span class=\"built_in\">malloc</span>(undistView_width * undistView_height * <span class=\"number\">3</span> / <span class=\"number\">2</span> * <span class=\"built_in\">sizeof</span>(<span class=\"type\">float</span>));</span><br></pre></td></tr></table></figure>\n<p>那么，后面构建map映射关系时并不会出现越界访问提示，甚至后面如果不再申请内存块的情况下，继续越界访问undist_map中的内容也不会报错；但是，如果后面继续申请内存块来使用的时候，后续的内存块可能就会和undist_map内存冲突。  </p>\n<hr>\n<p><font color=Red><strong>总结</strong></font><br>使用malloc申请内存并访问时，注意访问是否越界，且访问越界不报错。</p>\n","categories":[{"name":"C++","path":"api/categories/C++.json"},{"name":"linux","path":"api/categories/linux.json"}],"tags":[{"name":"C++","path":"api/tags/C++.json"},{"name":"malloc","path":"api/tags/malloc.json"},{"name":"内存访问","path":"api/tags/内存访问.json"}]}