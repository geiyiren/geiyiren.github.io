{"title":"智能指针的使用","slug":"智能指针的使用","date":"2023-05-10T14:00:00.000Z","updated":"2023-11-26T08:56:20.898Z","comments":true,"path":"api/articles/智能指针的使用.json","excerpt":null,"covers":null,"content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>在 C++ 中，智能指针是一种对象，它处理内存管理的问题，使程序员更加专注于业务逻辑而不是内存管理。C++ 标准库中提供了几种类型的智能指针，包括：</p>\n<ul>\n<li><p><code>std::unique_ptr</code>: 它代表独占所有权的概念。一个 <code>std::unique_ptr</code> 对象在任何时间都拥有它所指向的对象。当 <code>std::unique_ptr</code> 被销毁（例如，当离开其作用域时），它所指向的对象也会被销毁（即调用其析构函数）。</p>\n</li>\n<li><p><code>std::shared_ptr</code>: 它代表共享所有权的概念。多个 <code>std::shared_ptr</code> 对象可以拥有同一个对象。当最后一个拥有该对象的 <code>std::shared_ptr</code> 被销毁时，它所指向的对象也会被销毁。</p>\n</li>\n<li><p><code>std::weak_ptr</code>: 它是为了配合 <code>std::shared_ptr</code> 而存在的，它提供了一种方式访问 <code>std::shared_ptr</code> 所管理的对象，但是不增加引用计数。这对于解决 <code>std::shared_ptr</code> 循环引用的问题（即，两个 <code>std::shared_ptr</code> 相互引用，导致它们都不会被销毁）是很有用的。</p>\n</li>\n</ul>\n<p>智能指针的使用可以极大地简化内存管理，避免内存泄漏和其他与生命周期管理相关的错误。然而，它们并不能解决所有的内存管理问题，仍然需要程序员小心谨慎地设计他们的代码。</p>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><h2 id=\"std-unique-ptr示例\"><a href=\"#std-unique-ptr示例\" class=\"headerlink\" title=\"std::unique_ptr示例\"></a><code>std::unique_ptr</code>示例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::~Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::bar\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">const</span> Foo &amp;)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;f(const Foo&amp;)\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::unique_ptr&lt;Foo&gt; <span class=\"title\">p1</span><span class=\"params\">(<span class=\"keyword\">new</span> Foo)</span></span>;  <span class=\"comment\">// p1 独占 Foo</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p1-&gt;<span class=\"built_in\">bar</span>();  <span class=\"comment\">// 输出 &quot;Foo::bar&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_ptr&lt;Foo&gt; <span class=\"title\">p2</span><span class=\"params\">(std::move(p1))</span></span>;  <span class=\"comment\">// 现在 p2 独占 Foo</span></span><br><span class=\"line\">        <span class=\"built_in\">f</span>(*p2);</span><br><span class=\"line\">        p1 = std::<span class=\"built_in\">move</span>(p2);  <span class=\"comment\">// 现在 p1 独占 Foo</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    p1-&gt;<span class=\"built_in\">bar</span>();  <span class=\"comment\">// 输出 &quot;Foo::bar&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Foo 的析构器在这里被调用，因为 p1 被销毁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"std-shared-ptr示例\"><a href=\"#std-shared-ptr示例\" class=\"headerlink\" title=\"std::shared_ptr示例\"></a><code>std::shared_ptr</code>示例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::~Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::bar\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;Foo&gt; p1 = std::<span class=\"built_in\">make_shared</span>&lt;Foo&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 这里，我们不再需要使用 new。std::make_shared 是一个更安全，更高效的方式来分配共享对象。</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    p1-&gt;<span class=\"built_in\">bar</span>();  <span class=\"comment\">// 输出 &quot;Foo::bar&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::shared_ptr&lt;Foo&gt; p2 = p1;</span><br><span class=\"line\">        p2-&gt;<span class=\"built_in\">bar</span>();  <span class=\"comment\">// 输出 &quot;Foo::bar&quot;</span></span><br><span class=\"line\">        <span class=\"comment\">// Foo 的实例仍未被删除，因为 p1 和 p2 都还在作用域内</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    p1-&gt;<span class=\"built_in\">bar</span>();  <span class=\"comment\">// 输出 &quot;Foo::bar&quot;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Foo 的析构器在这里被调用，因为 p1 离开了作用域</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"std-weak-ptr示例\"><a href=\"#std-weak-ptr示例\" class=\"headerlink\" title=\"std::weak_ptr示例\"></a><code>std::weak_ptr</code>示例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::~Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::weak_ptr&lt;Foo&gt; weak;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::shared_ptr&lt;Foo&gt; shared = std::<span class=\"built_in\">make_shared</span>&lt;Foo&gt;();</span><br><span class=\"line\">        weak = shared;</span><br><span class=\"line\">        <span class=\"comment\">// 在 shared 存在的时候，我们可以使用 weak 来获取一个新的 shared_ptr 实例</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> p = weak.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p) &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;Object has not been deleted\\n&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里，shared 被销毁，因此 Foo 被删除</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因为 Foo 已经被删除，所以我们不能再从 weak 中获取一个 shared_ptr</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> p = weak.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!p) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Object has been deleted\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h2><p>智能指针的 reset 方法是用于释放智能指针当前拥有的对象，并可能接管新的对象。</p>\n<p>以下是 std::unique_ptr 和 std::shared_ptr 的 reset 方法的使用：</p>\n<ul>\n<li><code>std::unique_ptr</code> 的 <code>reset</code> 方法</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"type\">int</span> val) : <span class=\"built_in\">value</span>(val) &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo &quot;</span> &lt;&lt; value &lt;&lt; <span class=\"string\">&quot; constructed.\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo &quot;</span> &lt;&lt; value &lt;&lt; <span class=\"string\">&quot; destructed.\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::unique_ptr&lt;Foo&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> Foo(<span class=\"number\">1</span>))</span></span>;  <span class=\"comment\">// p 现在指向一个新的 Foo 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Foo</span>(<span class=\"number\">2</span>));  <span class=\"comment\">// p 释放旧的 Foo 对象并指向一个新的 Foo 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这一步，&quot;Foo 1 destructed.&quot; 被打印到控制台</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>std::shared_ptr</code> 的 <code>reset</code> 方法</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"type\">int</span> val) : <span class=\"built_in\">value</span>(val) &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo &quot;</span> &lt;&lt; value &lt;&lt; <span class=\"string\">&quot; constructed.\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo &quot;</span> &lt;&lt; value &lt;&lt; <span class=\"string\">&quot; destructed.\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;Foo&gt; p1 = std::<span class=\"built_in\">make_shared</span>&lt;Foo&gt;(<span class=\"number\">1</span>);  <span class=\"comment\">// p1 现在指向一个新的 Foo 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::shared_ptr&lt;Foo&gt; p2 = p1;  <span class=\"comment\">// p2 也指向同一个 Foo 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p1.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Foo</span>(<span class=\"number\">2</span>));  <span class=\"comment\">// p1 释放旧的 Foo 对象并指向一个新的 Foo 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是，&quot;Foo 1 destructed.&quot; 并未被打印到控制台，因为 p2 仍然拥有它</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p2.<span class=\"built_in\">reset</span>();  <span class=\"comment\">// p2 释放它的 Foo 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这一步，&quot;Foo 1 destructed.&quot; 被打印到控制台</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><script type=\"text&#x2F;javascript\" src=\"https://unpkg.com/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css\">","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>在 C++ 中，智能指针是一种对象，它处理内存管理的问题，使程序员更加专注于业务逻辑而不是内存管理。C++ 标准库中提供了几种类型的智能指针，包括：</p>\n<ul>\n<li><p><code>std::unique_ptr</code>: 它代表独占所有权的概念。一个 <code>std::unique_ptr</code> 对象在任何时间都拥有它所指向的对象。当 <code>std::unique_ptr</code> 被销毁（例如，当离开其作用域时），它所指向的对象也会被销毁（即调用其析构函数）。</p>\n</li>\n<li><p><code>std::shared_ptr</code>: 它代表共享所有权的概念。多个 <code>std::shared_ptr</code> 对象可以拥有同一个对象。当最后一个拥有该对象的 <code>std::shared_ptr</code> 被销毁时，它所指向的对象也会被销毁。</p>\n</li>\n<li><p><code>std::weak_ptr</code>: 它是为了配合 <code>std::shared_ptr</code> 而存在的，它提供了一种方式访问 <code>std::shared_ptr</code> 所管理的对象，但是不增加引用计数。这对于解决 <code>std::shared_ptr</code> 循环引用的问题（即，两个 <code>std::shared_ptr</code> 相互引用，导致它们都不会被销毁）是很有用的。</p>\n</li>\n</ul>\n<p>智能指针的使用可以极大地简化内存管理，避免内存泄漏和其他与生命周期管理相关的错误。然而，它们并不能解决所有的内存管理问题，仍然需要程序员小心谨慎地设计他们的代码。</p>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><h2 id=\"std-unique-ptr示例\"><a href=\"#std-unique-ptr示例\" class=\"headerlink\" title=\"std::unique_ptr示例\"></a><code>std::unique_ptr</code>示例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::~Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::bar\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">const</span> Foo &amp;)</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;f(const Foo&amp;)\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::unique_ptr&lt;Foo&gt; <span class=\"title\">p1</span><span class=\"params\">(<span class=\"keyword\">new</span> Foo)</span></span>;  <span class=\"comment\">// p1 独占 Foo</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p1-&gt;<span class=\"built_in\">bar</span>();  <span class=\"comment\">// 输出 &quot;Foo::bar&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">std::unique_ptr&lt;Foo&gt; <span class=\"title\">p2</span><span class=\"params\">(std::move(p1))</span></span>;  <span class=\"comment\">// 现在 p2 独占 Foo</span></span><br><span class=\"line\">        <span class=\"built_in\">f</span>(*p2);</span><br><span class=\"line\">        p1 = std::<span class=\"built_in\">move</span>(p2);  <span class=\"comment\">// 现在 p1 独占 Foo</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    p1-&gt;<span class=\"built_in\">bar</span>();  <span class=\"comment\">// 输出 &quot;Foo::bar&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Foo 的析构器在这里被调用，因为 p1 被销毁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"std-shared-ptr示例\"><a href=\"#std-shared-ptr示例\" class=\"headerlink\" title=\"std::shared_ptr示例\"></a><code>std::shared_ptr</code>示例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::~Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">bar</span><span class=\"params\">()</span> </span>&#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::bar\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;Foo&gt; p1 = std::<span class=\"built_in\">make_shared</span>&lt;Foo&gt;();</span><br><span class=\"line\">    <span class=\"comment\">// 这里，我们不再需要使用 new。std::make_shared 是一个更安全，更高效的方式来分配共享对象。</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    p1-&gt;<span class=\"built_in\">bar</span>();  <span class=\"comment\">// 输出 &quot;Foo::bar&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::shared_ptr&lt;Foo&gt; p2 = p1;</span><br><span class=\"line\">        p2-&gt;<span class=\"built_in\">bar</span>();  <span class=\"comment\">// 输出 &quot;Foo::bar&quot;</span></span><br><span class=\"line\">        <span class=\"comment\">// Foo 的实例仍未被删除，因为 p1 和 p2 都还在作用域内</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    p1-&gt;<span class=\"built_in\">bar</span>();  <span class=\"comment\">// 输出 &quot;Foo::bar&quot;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// Foo 的析构器在这里被调用，因为 p1 离开了作用域</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"std-weak-ptr示例\"><a href=\"#std-weak-ptr示例\" class=\"headerlink\" title=\"std::weak_ptr示例\"></a><code>std::weak_ptr</code>示例</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo::~Foo\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::weak_ptr&lt;Foo&gt; weak;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::shared_ptr&lt;Foo&gt; shared = std::<span class=\"built_in\">make_shared</span>&lt;Foo&gt;();</span><br><span class=\"line\">        weak = shared;</span><br><span class=\"line\">        <span class=\"comment\">// 在 shared 存在的时候，我们可以使用 weak 来获取一个新的 shared_ptr 实例</span></span><br><span class=\"line\">        <span class=\"keyword\">auto</span> p = weak.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p) &#123;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">&quot;Object has not been deleted\\n&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这里，shared 被销毁，因此 Foo 被删除</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 因为 Foo 已经被删除，所以我们不能再从 weak 中获取一个 shared_ptr</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> p = weak.<span class=\"built_in\">lock</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!p) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;Object has been deleted\\n&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h1><h2 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h2><p>智能指针的 reset 方法是用于释放智能指针当前拥有的对象，并可能接管新的对象。</p>\n<p>以下是 std::unique_ptr 和 std::shared_ptr 的 reset 方法的使用：</p>\n<ul>\n<li><code>std::unique_ptr</code> 的 <code>reset</code> 方法</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"type\">int</span> val) : <span class=\"built_in\">value</span>(val) &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo &quot;</span> &lt;&lt; value &lt;&lt; <span class=\"string\">&quot; constructed.\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo &quot;</span> &lt;&lt; value &lt;&lt; <span class=\"string\">&quot; destructed.\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::unique_ptr&lt;Foo&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> Foo(<span class=\"number\">1</span>))</span></span>;  <span class=\"comment\">// p 现在指向一个新的 Foo 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Foo</span>(<span class=\"number\">2</span>));  <span class=\"comment\">// p 释放旧的 Foo 对象并指向一个新的 Foo 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这一步，&quot;Foo 1 destructed.&quot; 被打印到控制台</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>std::shared_ptr</code> 的 <code>reset</code> 方法</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Foo</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Foo</span>(<span class=\"type\">int</span> val) : <span class=\"built_in\">value</span>(val) &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo &quot;</span> &lt;&lt; value &lt;&lt; <span class=\"string\">&quot; constructed.\\n&quot;</span>; &#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">Foo</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Foo &quot;</span> &lt;&lt; value &lt;&lt; <span class=\"string\">&quot; destructed.\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::shared_ptr&lt;Foo&gt; p1 = std::<span class=\"built_in\">make_shared</span>&lt;Foo&gt;(<span class=\"number\">1</span>);  <span class=\"comment\">// p1 现在指向一个新的 Foo 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::shared_ptr&lt;Foo&gt; p2 = p1;  <span class=\"comment\">// p2 也指向同一个 Foo 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p1.<span class=\"built_in\">reset</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">Foo</span>(<span class=\"number\">2</span>));  <span class=\"comment\">// p1 释放旧的 Foo 对象并指向一个新的 Foo 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 但是，&quot;Foo 1 destructed.&quot; 并未被打印到控制台，因为 p2 仍然拥有它</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p2.<span class=\"built_in\">reset</span>();  <span class=\"comment\">// p2 释放它的 Foo 对象</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这一步，&quot;Foo 1 destructed.&quot; 被打印到控制台</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","categories":[{"name":"C++","path":"api/categories/C++.json"}],"tags":[{"name":"C++","path":"api/tags/C++.json"},{"name":"智能指针","path":"api/tags/智能指针.json"}]}