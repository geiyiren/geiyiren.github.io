{"title":"零基础学习g2o","slug":"零基础学习g2o","date":"2023-10-17T10:00:00.000Z","updated":"2023-11-24T15:18:59.913Z","comments":true,"path":"api/articles/零基础学习g2o.json","excerpt":null,"covers":["https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/g2o%E6%A1%86%E6%9E%B6%E5%9B%BE.png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi1jMjdkNWI0NzcwNjM5NDZiNmFiZmQxNWI1YTYzNTExNV9oZC5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi1kMGRkYzFiM2EzNGRiOTE5Yzk0OGViOTAyZWQwMzEyOF9oZC5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0zMWQ5OWY5YmIxZjViMDE0MDcyMTBhYTRiYmIzM2IwY19oZC5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi04NWRlYTEzMTU4OTgyMzgxZDViMjcxMmM2YmY3MjI2MV9oZC5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi05MzljOTExODY2N2VlMzgxNzI1NTQ3ZmE2MDUwNDFkY19oZC5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi05NjgwODUzMTY5YmNhMGRjY2M2OTY3OGM4MzM4NzQ2MV9oZC5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi05ZDlmZDA4MGM1YmZiOTAxMTc0NjM5YTVmMjM3Y2M2OV9oZC5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi00ZTQ1OWRkNDQ1N2Q5ZDM1YTk3ZDU1NWUyMGJiYmU3OF9oZC5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi1mMDMwYTk0Y2M4YjcwYjgzYjk4MDUxMDg0MTkyMTM5ZF9oZC5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0xYmM3ZTQ5OTYyY2EyMTI1NGI3YWU5N2M3OTNlNWYwY19oZC5qcGc?x-oss-process=image/format,png","https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi00ZTJhNzVmMWJkMmM0NzZmOTFlNmYzMDMwMzFiNzcyYl9oZC5qcGc?x-oss-process=image/format,png","https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/BA1.jpg","https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/BA2.png","https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/%E4%B8%89%E8%A7%92%E5%8C%96.png","https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png"],"content":"<h1 id=\"正篇\"><a href=\"#正篇\" class=\"headerlink\" title=\"正篇\"></a>正篇</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>g2o（General Graphic Optimization）是一个基于图优化的库，将非线性优化与图论结合起来的理论，我们可以<strong>利用g2o求解任何可以表示为图优化的最小二乘问题</strong>。图优化就是把优化问题表现成图的方式。图由顶点和边组成，其中<em>顶点表示优化变量</em>，<em>边表示误差项</em>，对任意一个非线性最小二乘问题，我们都可以构建与之对应的图。</p>\n<p>g2o的核里带有各种各样的求解器，而它的顶点、边的类型则多种多样。通过自定义顶点和边，事实上，只要一个优化问题能够表达成图，那么就可以用g2o去求解它。常见的，比如bundle adjustment，ICP，数据拟合，都可以用g2o来做。</p>\n<p>从代码层面来说，g2o是一个c++编写的项目，用cmake构建。它的github地址在：<a href=\"https://github.com/RainerKuemmerle/g2o\">https://github.com/RainerKuemmerle/g2o</a> </p>\n<p>g2o的源代码文件夹的内容：</p>\n<ul>\n<li><code>apps</code>　　　　 一些应用程序。好用的g2o_viewer就在这里。其他还有一些不常用的命令行工具等。</li>\n<li><code>core</code>　　　　 核心组件，很重要！基本的顶点、边、图结构的定义，算法的定义，求解器接口的定义在这里。</li>\n<li><code>examples</code>　  一些例程，可以参照着这里的东西来写。不过注释不太多。</li>\n<li><code>solvers</code>　　  求解器的实现。主要来自choldmod, csparse。在使用g2o时要先选择其中一种。</li>\n<li><code>stuff</code>　　　  对用户来讲可有可无的一些工具函数。</li>\n<li><code>types</code>　　　  各种顶点和边，很重要！我们用户在构建图优化问题时，先要想好自己的顶点和边是否已经提供了定义。如果没有，要自己实现。如果有，就用g2o提供的即可。</li>\n</ul>\n<p>就经验而言，<code>solvers</code>给人的感觉是大同小异(不同的求解器可能有针对性的求解场景，但是对于一般的优化问题，一般都适用)，而 <code>types</code> 的选取(关键就是顶点和边的定义)，则是 g2o 用户主要关心的内容。然后 <code>core</code> 下面的内容，我们要争取弄的比较熟悉，才能确保使用中出现错误可以正确地应对。</p>\n<p>g2o的结构图如下所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/g2o%E6%A1%86%E6%9E%B6%E5%9B%BE.png\"></p>\n<p>先看上半部分。<code>SparseOptimizer</code>(稀疏优化器) 是我们最终要维护的东东。它是一个OptimizableGraph(优化图)，从而也是一个HyperGraph(超图)。一个 <code>SparseOptimizer</code> 含有很多个顶点 （都继承自 <code>Base Vertex</code>）和很多个边（继承自 <code>BaseUnaryEdge</code>(一元边), <code>BaseBinaryEdge</code>(二元边)或<code>BaseMultiEdge</code>(多元边)）。这些 <code>Base Vertex</code> 和 <code>Base Edge</code>都是抽象的基类，而实际用的顶点和边，都是它们的派生类。我们用 <code>SparseOptimizer.addVertex</code> 和 <code>SparseOptimizer.addEdge</code> 向一个图中添加顶点和边，最后调用 <code>SparseOptimizer.optimize</code> 完成优化。</p>\n<p>在优化之前，需要指定我们用的求解器和迭代算法。从图中下半部分可以看到，一个 <code>SparseOptimizer</code> 拥有一个 <code>Optimization Algorithm</code>继承自<code>Gauss-Newton</code>, <code>Levernberg-Marquardt</code>, <code>Powell&#39;s dogleg</code> 三者之一（我们常用的是GN或LM）。同时，这个 <code>Optimization Algorithm</code> 拥有一个<code>Solver</code>它含有两个部分。一个是 <code>SparseBlockMatrix</code> ，用于计算稀疏的雅可比矩阵和海塞矩阵； 一个是 <code>linearsolver</code> ，用于计算迭代过程中最关键的一步：</p>\n<p>$$H\\Delta x&#x3D;-b$$</p>\n<p>这就需要一个线性方程的求解器。而这个求解器，可以从 PCG, CSparse, Choldmod 三者选一。</p>\n<p><strong>综上所述，在g2o中选择优化方法一共需要三个步骤：</strong></p>\n<ul>\n<li>选择一个线性方程求解器，从 PCG, CSparse, Choldmod中选，实际则来自 g2o&#x2F;solvers 文件夹中定义的东东。</li>\n<li>选择一个 BlockSolver 。</li>\n<li>选择一个迭代策略，从GN, LM, Doglog中选。</li>\n</ul>\n<h1 id=\"扫盲篇\"><a href=\"#扫盲篇\" class=\"headerlink\" title=\"扫盲篇\"></a>扫盲篇</h1><h2 id=\"最小二乘\"><a href=\"#最小二乘\" class=\"headerlink\" title=\"最小二乘\"></a>最小二乘</h2><blockquote>\n<p>参考网站：<a href=\"https://blog.csdn.net/qq_41598072/article/details/83984299\">https://blog.csdn.net/qq_41598072/article/details/83984299</a><br>大家可以随意搜索一下，相关的文章很多。长篇大论的不少，刚入门的朋友一看到那些公式可能就看不下去了。比如下面的解释：</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi1jMjdkNWI0NzcwNjM5NDZiNmFiZmQxNWI1YTYzNTExNV9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>毫无疑问，这样的解释是专业的，严谨的。事实上，这是深度学习圣经里的解释。我并没有诋毁大师的意思，只是觉得用一个具体的例子来说明，可能会让读者更加容易理解：</p>\n<p>小明是跑运输的，跑1公里需要6块，跑2公里需要5块（那段时间刚好油价跌了），跑3公里需要7块，跑4公里需要10块，请问跑5公里需要多少块？</p>\n<p>如果我们有初中数学基础，应该会自然而然地想到用线性方程组来做，对吧。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi1kMGRkYzFiM2EzNGRiOTE5Yzk0OGViOTAyZWQwMzEyOF9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>这里假定x是公里数，y是运输成本（β1和β2是要求的系数）。我们把上面的一组数据代入得到这么几个方程：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0zMWQ5OWY5YmIxZjViMDE0MDcyMTBhYTRiYmIzM2IwY19oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>如果存在这样的β1和β2，让所有的数据$（x，y）&#x3D;（1,6），（2,5），（3,7），（4，10）$ 都能满足的话，那么解答就很简单了，β1+5β2就是5公里的成本，对吧。</p>\n<p>但遗憾的是，这样的β1和β2是不存在的，上面的方程组很容易，你可以把前面两个解出来得到一组β1和β2，后面两个也解出来同样得到一组β1和β2。这两组β1和β2是不一样的。</p>\n<p>形象地说，就是你找不到一条直线，穿过所有的点，因为他们不在一条直线上。如下图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi04NWRlYTEzMTU4OTgyMzgxZDViMjcxMmM2YmY3MjI2MV9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>可是现实生活中，我们就希望能找到一条直线，虽然不能满足所有条件，但能<strong>近似</strong>地表示这个趋势，或者说，能近似地知道5公里的运输成本，这也是有意义的。</p>\n<p>现实生活当中，有很多这样的例子，想起以前在某公司上班的时候，CEO说我们研发部做事有个问题：一个研发任务，要求三个月做完，因为周期太短，完成不了，就干脆不做，这显然是不对的，要尽全力，哪怕三个月完成了80%，或者最终4个月完成，总比不作为的好。</p>\n<p>其实最小二乘法也是这样，要尽全力让这条直线最接近这些点，那么问题来了，怎么才叫做最接近呢？直觉告诉我们，这条直线在所有数据点中间穿过，让这些点到这条直线的误差之和越小越好。这里我们用方差来算更客观。也就是说，把每个点到直线的误差平方加起来：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi05MzljOTExODY2N2VlMzgxNzI1NTQ3ZmE2MDUwNDFkY19oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>（如果上面的四个方程都能满足，那么S的值显然为0，这是最完美的，但如果做不到完美，我们就让这个S越小越好）</p>\n<p>接下来的问题就是，如何让这个S变得最小。这里有一个概念，就是求偏导数。这里我想提一下，在培训的过程中，我发现机器学习的数学基础课程当中，微积分是大家印象最深刻的，而且也最容易理解：比如导数就是求变化率，而偏导数则是当变量超过一个的时候，对其中一个变量求变化率。如果这个概念也忘了，可以参考我在深度学习回答里那个王小二卖猪的例子。这里就不细讲了：</p>\n<p>要让S取得最小值（或最大值，但显然这个函数没有最大值，自己琢磨一下），那么S对于β1和β2分别求偏导结果为0，用一个直观的图来表示：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi05NjgwODUzMTY5YmNhMGRjY2M2OTY3OGM4MzM4NzQ2MV9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>我们看到这条曲线，前半部分是呈下降的趋势，也就是变化率（导数）为负的，后半部分呈上升的趋势，也就是变化率（导数）为正，那么分界点的导数为0，也就是取得最小值的地方。这是一个变量的情况，对于多个变量的情况，要让S取得最小值，那最好是对β1和β2分别求导（对β1求导的时候，把β2当常量所以叫求偏导），值为0：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi05ZDlmZDA4MGM1YmZiOTAxMTc0NjM5YTVmMjM3Y2M2OV9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi00ZTQ1OWRkNDQ1N2Q5ZDM1YTk3ZDU1NWUyMGJiYmU3OF9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>看到这个我们就熟悉了，两个变量，刚好有两个方程式，初中学过，那么很容易得出：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi1mMDMwYTk0Y2M4YjcwYjgzYjk4MDUxMDg0MTkyMTM5ZF9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0xYmM3ZTQ5OTYyY2EyMTI1NGI3YWU5N2M3OTNlNWYwY19oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>其实也就意味着</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi00ZTJhNzVmMWJkMmM0NzZmOTFlNmYzMDMwMzFiNzcyYl9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>这个函数也就是我们要的直线，这条直线虽然不能把那些点串起来，但它能最大程度上接近这些点。也就是说5公里的时候，成本为3.5+1.4x5&#x3D;10.5块，虽然不完美，但是很接近实际情况。</p>\n<h2 id=\"BA优化\"><a href=\"#BA优化\" class=\"headerlink\" title=\"BA优化\"></a>BA优化</h2><blockquote>\n<p>参考网站: <a href=\"https://optsolution.github.io/archives/58892.html\">https://optsolution.github.io/archives/58892.html</a></p>\n</blockquote>\n<h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Bundle Adjustment中文译为<strong>光束法平差</strong>，大概大家看到更多的翻译可能为束调整、捆集调整或者捆绑调整等等.所谓bundle，来源于bundle of light，其本意就是指的光束，这些光束指的是三维空间中的点投影到像平面上的光束，而重投影误差正是利用这些光束来构建的，因此称为光束法强调光束也正是描述其优化模型是如何建立的。</p>\n<p>剩下的就是平差，那什么是平差呢？由于测量仪器的精度不完善和人为因素及外界条件的影响，测量误差总是不可避免的。为了提高成果的质量，处理好这些测量中存在的误差问题，观测值的个数往往要多于确定未知量所必须观测的个数，也就是要进行<em>多余观测</em>。有了多余观测，势必在观测结果之间产生矛盾，测量平差的目的就在于消除这些矛盾而求得观测量的最可靠结果并评定测量成果的精度。测量平差采用的原理就是“最小二乘法”。平差也就正好表述了为什么需要BA以及BA这个优化过程到底是怎么进行的。<strong>BA的本质是一个优化模型，其目的是最小化重投影误差</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/BA1.jpg\"></p>\n<p>这些五颜六色的线就是我们讲的光束啦！那现在就该说下什么叫重投影误差了，重投影也就是指的第二次投影，那到底是怎么投影的呢？我们来整理一下吧。</p>\n<ul>\n<li>第一次投影指的就是相机在拍照的时候三维空间点投影到图像上</li>\n<li>第二次投影指的是利用几何信息构建三角形来确定三维空间点的位置，利用相机矩阵将得到的三维点的坐标投影到图像上，进行第二次投影，也就是重投影.重投影使用的三维点的位置是根据三角化得到的。<blockquote>\n<p>第二次投影利用到了三角化的原理，那么什么是三角化呢？参加后文三角化介绍。</p>\n</blockquote>\n</li>\n</ul>\n<p>现在我们知道什么是重投影了，那重投影误差到底是什么样的误差呢？这个误差是指的真实三维空间点在图像平面上的投影（也就是图像上的像素点）和重投影（其实是用我们的计算值得到的虚拟的像素点）的差值，因为种种原因计算得到的值和实际情况不会完全相符，也就是这个差值不可能恰好为0，此时也就需要将这些差值的和最小化获取最优的相机参数及三维空间点的坐标。</p>\n<p>BA是一个图优化模型，那首先肯定要构造一个图模型了（没学过图论也没事，后面还是会回到一般的优化模型）。既然是图模型那自然就有节点和边了，这个图模型的节点由相机$P_i$和三维空间点$X_j$构成，如果点$X_j$投影到相机$P_i$的图像上则将这两个节点连接起来。还是来张图吧。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/BA2.png\"></p>\n<p>这样就一目了然了。那么我们现在就可以通过这个图来构造优化模型了。</p>\n<p>令点$X_j$在相机$P_i$拍摄到的图像归一化坐标系上的坐标为$k(u_{i j}^{T},1)^{T}&#x3D;K_{i}^{-1}x_{i j}$，其重投影后的图像归一化坐标系下坐标为$k^{\\prime}(v_{i j}^{T},1)^{T}&#x3D;K_{i}^{-1}P_{i}X_{j}$，其中$K_{i}^{-1}$是为了在计算时能不受相机内参影响,$k$和$k^{\\prime}$是将齐次坐标转换为非齐次坐标的常数项，可以得到该重投影误差为:<br>$$e_{i j}&#x3D;u_{i j}-v_{i j}$$<br>BA是要将所有重投影误差的和最小化，那么这里自然就要开始求和了。<br>$$\\operatorname*{min}<em>{R</em>{i},t_{i},X_{j}}\\sum_{i,j}\\sigma_{i j}||u_{i j}-v_{i j}||<em>{2}$$<br>其中当点$X_j$在相机$P_i$中有投影时$\\sigma</em>{i j}&#x3D;1$，否则为$\\sigma_{i j}&#x3D;0$。到此我们就得到了BA优化模型的数学形式了。</p>\n<p>既然是优化模型，那自然就应该用各种优化算法来进行计算了。常用的方法有最速下降法，牛顿方法，高斯牛顿方法，LM方法。具体细节<a href=\"https://optsolution.github.io/archives/58892.html\">点我查看</a></p>\n<blockquote>\n<p>具体细节预览<a href=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/BA%E7%AE%80%E8%BF%B0.png\">点我查看</a></p>\n</blockquote>\n<h2 id=\"三角化\"><a href=\"#三角化\" class=\"headerlink\" title=\"三角化\"></a>三角化</h2><p>在单目SLAM中，仅通过单张图像无法获得像素的深度信息，我们需要通过三角测量(Triangulation)(或三角化)的方法来估计地图点的深度。即通过某个特征点P在不同帧图像中像素点的位置，来计算出该特征点在三维空间中的坐标，也即获得特征点P的深度信息。特征点在某个相机中被观测到，根据相机位姿和观测向量可以得到3D空间中的一条从相机中心出发的观测“射线”，多个相机位姿观测会产生多条观测射线，理想情况下这些观测射线相交于空间中一点，求所有观测射线的交点就是特征点在3D空间的位置，这就是三角化最朴素的思想。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/%E4%B8%89%E8%A7%92%E5%8C%96.png\"></p>\n<p>以两视图的三角化为例，考虑$I_1$,$I_2$两帧图像，$R,t$是第二帧相对于第一帧的旋转矩阵和平移向量（对应的变换矩阵是$T_{12}$）。在$I_1$中有特征点$p_1$，对应于$I_2$中的匹配点$p_2$。根据相机的内参数矩阵$K$，我们便可以获得$p_1$在帧归一化图像平面中的点$x_1&#x3D;K^{-1}p_{1}$；$p_2$在$I_2$帧归一化平面中的点$x_2&#x3D;K^{-1}p_2$。</p>\n<p>根据对极约束，他们满足如下的关系：<br>$$s_{1}x_{1}&#x3D;s_{2}Rx_{2}+t$$</p>\n<p>先对公式左右两端左乘反对称矩阵$x^{\\wedge}$，得到：</p>\n<p>$$s_{1}x_{1}^{\\wedge}x_{1}&#x3D;0&#x3D;s_{2}x_{1}^{\\wedge}R x_{2}+x_{1}^{\\wedge}t$$</p>\n<p>根据上述公式的右端，可以计算出$s_2$，进而计算出$s_1$，我们便可得到路标点$P$在这两帧中的深度。然而，在实际的位姿估计中，我们估计的值往往存在误差，上述公式不严格为0。这时候我们可以计算最小二乘解。</p>\n<blockquote>\n<p>多视图三角化<a href=\"https://gutsgwh1997.github.io/2020/03/31/%E5%A4%9A%E8%A7%86%E5%9B%BE%E4%B8%89%E8%A7%92%E5%8C%96/\">点我查看</a><br>具体细节预览<a href=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/%E5%A4%9A%E8%A7%86%E5%9B%BE%E4%B8%89%E8%A7%92%E5%8C%96.png\">点我查看</a></p>\n</blockquote>\n<h2 id=\"对极约束\"><a href=\"#对极约束\" class=\"headerlink\" title=\"对极约束\"></a>对极约束</h2><p>对极几何（Epipolar geometry）又叫对极约束，是根据图像二维平面信息来估计单目相机帧间运动或双目相机相对位姿关系的一种算法。直观来讲，当相机在两个不同视角对同一物体进行拍摄时，物体在两幅图像中的成像肯定会有不同，那么，根据这两幅不同的图像，我们如何判断出相机的位姿发生了怎样的变化，这正是对极几何要解决的问题。直观来说就是利用$n$对匹配点对的图像坐标求解相机位姿变换关系。</p>\n<p>需要明确的是，在对极几何中，我们的已知条件仅仅是每幅图像中特征点的像素坐标，当然，计算对极约束的前提是我们必须知道两幅图像中特征点之间准确的匹配关系。<br><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png\"><br><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95%E6%8E%A8%E5%AF%BC.png\"></p>\n<script type=\"text&#x2F;javascript\" src=\"https://unpkg.com/kity@2.0.4/dist/kity.min.js\"></script><script type=\"text&#x2F;javascript\" src=\"https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js\"></script><script defer=\"true\" type=\"text&#x2F;javascript\" src=\"https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js\"></script><link rel=\"stylesheet\" type=\"text&#x2F;css\" href=\"https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css\">","more":"<h1 id=\"正篇\"><a href=\"#正篇\" class=\"headerlink\" title=\"正篇\"></a>正篇</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>g2o（General Graphic Optimization）是一个基于图优化的库，将非线性优化与图论结合起来的理论，我们可以<strong>利用g2o求解任何可以表示为图优化的最小二乘问题</strong>。图优化就是把优化问题表现成图的方式。图由顶点和边组成，其中<em>顶点表示优化变量</em>，<em>边表示误差项</em>，对任意一个非线性最小二乘问题，我们都可以构建与之对应的图。</p>\n<p>g2o的核里带有各种各样的求解器，而它的顶点、边的类型则多种多样。通过自定义顶点和边，事实上，只要一个优化问题能够表达成图，那么就可以用g2o去求解它。常见的，比如bundle adjustment，ICP，数据拟合，都可以用g2o来做。</p>\n<p>从代码层面来说，g2o是一个c++编写的项目，用cmake构建。它的github地址在：<a href=\"https://github.com/RainerKuemmerle/g2o\">https://github.com/RainerKuemmerle/g2o</a> </p>\n<p>g2o的源代码文件夹的内容：</p>\n<ul>\n<li><code>apps</code>　　　　 一些应用程序。好用的g2o_viewer就在这里。其他还有一些不常用的命令行工具等。</li>\n<li><code>core</code>　　　　 核心组件，很重要！基本的顶点、边、图结构的定义，算法的定义，求解器接口的定义在这里。</li>\n<li><code>examples</code>　  一些例程，可以参照着这里的东西来写。不过注释不太多。</li>\n<li><code>solvers</code>　　  求解器的实现。主要来自choldmod, csparse。在使用g2o时要先选择其中一种。</li>\n<li><code>stuff</code>　　　  对用户来讲可有可无的一些工具函数。</li>\n<li><code>types</code>　　　  各种顶点和边，很重要！我们用户在构建图优化问题时，先要想好自己的顶点和边是否已经提供了定义。如果没有，要自己实现。如果有，就用g2o提供的即可。</li>\n</ul>\n<p>就经验而言，<code>solvers</code>给人的感觉是大同小异(不同的求解器可能有针对性的求解场景，但是对于一般的优化问题，一般都适用)，而 <code>types</code> 的选取(关键就是顶点和边的定义)，则是 g2o 用户主要关心的内容。然后 <code>core</code> 下面的内容，我们要争取弄的比较熟悉，才能确保使用中出现错误可以正确地应对。</p>\n<p>g2o的结构图如下所示：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/g2o%E6%A1%86%E6%9E%B6%E5%9B%BE.png\"></p>\n<p>先看上半部分。<code>SparseOptimizer</code>(稀疏优化器) 是我们最终要维护的东东。它是一个OptimizableGraph(优化图)，从而也是一个HyperGraph(超图)。一个 <code>SparseOptimizer</code> 含有很多个顶点 （都继承自 <code>Base Vertex</code>）和很多个边（继承自 <code>BaseUnaryEdge</code>(一元边), <code>BaseBinaryEdge</code>(二元边)或<code>BaseMultiEdge</code>(多元边)）。这些 <code>Base Vertex</code> 和 <code>Base Edge</code>都是抽象的基类，而实际用的顶点和边，都是它们的派生类。我们用 <code>SparseOptimizer.addVertex</code> 和 <code>SparseOptimizer.addEdge</code> 向一个图中添加顶点和边，最后调用 <code>SparseOptimizer.optimize</code> 完成优化。</p>\n<p>在优化之前，需要指定我们用的求解器和迭代算法。从图中下半部分可以看到，一个 <code>SparseOptimizer</code> 拥有一个 <code>Optimization Algorithm</code>继承自<code>Gauss-Newton</code>, <code>Levernberg-Marquardt</code>, <code>Powell&#39;s dogleg</code> 三者之一（我们常用的是GN或LM）。同时，这个 <code>Optimization Algorithm</code> 拥有一个<code>Solver</code>它含有两个部分。一个是 <code>SparseBlockMatrix</code> ，用于计算稀疏的雅可比矩阵和海塞矩阵； 一个是 <code>linearsolver</code> ，用于计算迭代过程中最关键的一步：</p>\n<p>$$H\\Delta x&#x3D;-b$$</p>\n<p>这就需要一个线性方程的求解器。而这个求解器，可以从 PCG, CSparse, Choldmod 三者选一。</p>\n<p><strong>综上所述，在g2o中选择优化方法一共需要三个步骤：</strong></p>\n<ul>\n<li>选择一个线性方程求解器，从 PCG, CSparse, Choldmod中选，实际则来自 g2o&#x2F;solvers 文件夹中定义的东东。</li>\n<li>选择一个 BlockSolver 。</li>\n<li>选择一个迭代策略，从GN, LM, Doglog中选。</li>\n</ul>\n<h1 id=\"扫盲篇\"><a href=\"#扫盲篇\" class=\"headerlink\" title=\"扫盲篇\"></a>扫盲篇</h1><h2 id=\"最小二乘\"><a href=\"#最小二乘\" class=\"headerlink\" title=\"最小二乘\"></a>最小二乘</h2><blockquote>\n<p>参考网站：<a href=\"https://blog.csdn.net/qq_41598072/article/details/83984299\">https://blog.csdn.net/qq_41598072/article/details/83984299</a><br>大家可以随意搜索一下，相关的文章很多。长篇大论的不少，刚入门的朋友一看到那些公式可能就看不下去了。比如下面的解释：</p>\n</blockquote>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi1jMjdkNWI0NzcwNjM5NDZiNmFiZmQxNWI1YTYzNTExNV9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>毫无疑问，这样的解释是专业的，严谨的。事实上，这是深度学习圣经里的解释。我并没有诋毁大师的意思，只是觉得用一个具体的例子来说明，可能会让读者更加容易理解：</p>\n<p>小明是跑运输的，跑1公里需要6块，跑2公里需要5块（那段时间刚好油价跌了），跑3公里需要7块，跑4公里需要10块，请问跑5公里需要多少块？</p>\n<p>如果我们有初中数学基础，应该会自然而然地想到用线性方程组来做，对吧。</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi1kMGRkYzFiM2EzNGRiOTE5Yzk0OGViOTAyZWQwMzEyOF9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>这里假定x是公里数，y是运输成本（β1和β2是要求的系数）。我们把上面的一组数据代入得到这么几个方程：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0zMWQ5OWY5YmIxZjViMDE0MDcyMTBhYTRiYmIzM2IwY19oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>如果存在这样的β1和β2，让所有的数据$（x，y）&#x3D;（1,6），（2,5），（3,7），（4，10）$ 都能满足的话，那么解答就很简单了，β1+5β2就是5公里的成本，对吧。</p>\n<p>但遗憾的是，这样的β1和β2是不存在的，上面的方程组很容易，你可以把前面两个解出来得到一组β1和β2，后面两个也解出来同样得到一组β1和β2。这两组β1和β2是不一样的。</p>\n<p>形象地说，就是你找不到一条直线，穿过所有的点，因为他们不在一条直线上。如下图：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi04NWRlYTEzMTU4OTgyMzgxZDViMjcxMmM2YmY3MjI2MV9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>可是现实生活中，我们就希望能找到一条直线，虽然不能满足所有条件，但能<strong>近似</strong>地表示这个趋势，或者说，能近似地知道5公里的运输成本，这也是有意义的。</p>\n<p>现实生活当中，有很多这样的例子，想起以前在某公司上班的时候，CEO说我们研发部做事有个问题：一个研发任务，要求三个月做完，因为周期太短，完成不了，就干脆不做，这显然是不对的，要尽全力，哪怕三个月完成了80%，或者最终4个月完成，总比不作为的好。</p>\n<p>其实最小二乘法也是这样，要尽全力让这条直线最接近这些点，那么问题来了，怎么才叫做最接近呢？直觉告诉我们，这条直线在所有数据点中间穿过，让这些点到这条直线的误差之和越小越好。这里我们用方差来算更客观。也就是说，把每个点到直线的误差平方加起来：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi05MzljOTExODY2N2VlMzgxNzI1NTQ3ZmE2MDUwNDFkY19oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>（如果上面的四个方程都能满足，那么S的值显然为0，这是最完美的，但如果做不到完美，我们就让这个S越小越好）</p>\n<p>接下来的问题就是，如何让这个S变得最小。这里有一个概念，就是求偏导数。这里我想提一下，在培训的过程中，我发现机器学习的数学基础课程当中，微积分是大家印象最深刻的，而且也最容易理解：比如导数就是求变化率，而偏导数则是当变量超过一个的时候，对其中一个变量求变化率。如果这个概念也忘了，可以参考我在深度学习回答里那个王小二卖猪的例子。这里就不细讲了：</p>\n<p>要让S取得最小值（或最大值，但显然这个函数没有最大值，自己琢磨一下），那么S对于β1和β2分别求偏导结果为0，用一个直观的图来表示：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi05NjgwODUzMTY5YmNhMGRjY2M2OTY3OGM4MzM4NzQ2MV9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>我们看到这条曲线，前半部分是呈下降的趋势，也就是变化率（导数）为负的，后半部分呈上升的趋势，也就是变化率（导数）为正，那么分界点的导数为0，也就是取得最小值的地方。这是一个变量的情况，对于多个变量的情况，要让S取得最小值，那最好是对β1和β2分别求导（对β1求导的时候，把β2当常量所以叫求偏导），值为0：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi05ZDlmZDA4MGM1YmZiOTAxMTc0NjM5YTVmMjM3Y2M2OV9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi00ZTQ1OWRkNDQ1N2Q5ZDM1YTk3ZDU1NWUyMGJiYmU3OF9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>看到这个我们就熟悉了，两个变量，刚好有两个方程式，初中学过，那么很容易得出：</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMyLnpoaW1nLmNvbS84MC92Mi1mMDMwYTk0Y2M4YjcwYjgzYjk4MDUxMDg0MTkyMTM5ZF9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0xYmM3ZTQ5OTYyY2EyMTI1NGI3YWU5N2M3OTNlNWYwY19oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>其实也就意味着</p>\n<p><img src=\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi00ZTJhNzVmMWJkMmM0NzZmOTFlNmYzMDMwMzFiNzcyYl9oZC5qcGc?x-oss-process=image/format,png\"></p>\n<p>这个函数也就是我们要的直线，这条直线虽然不能把那些点串起来，但它能最大程度上接近这些点。也就是说5公里的时候，成本为3.5+1.4x5&#x3D;10.5块，虽然不完美，但是很接近实际情况。</p>\n<h2 id=\"BA优化\"><a href=\"#BA优化\" class=\"headerlink\" title=\"BA优化\"></a>BA优化</h2><blockquote>\n<p>参考网站: <a href=\"https://optsolution.github.io/archives/58892.html\">https://optsolution.github.io/archives/58892.html</a></p>\n</blockquote>\n<h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>Bundle Adjustment中文译为<strong>光束法平差</strong>，大概大家看到更多的翻译可能为束调整、捆集调整或者捆绑调整等等.所谓bundle，来源于bundle of light，其本意就是指的光束，这些光束指的是三维空间中的点投影到像平面上的光束，而重投影误差正是利用这些光束来构建的，因此称为光束法强调光束也正是描述其优化模型是如何建立的。</p>\n<p>剩下的就是平差，那什么是平差呢？由于测量仪器的精度不完善和人为因素及外界条件的影响，测量误差总是不可避免的。为了提高成果的质量，处理好这些测量中存在的误差问题，观测值的个数往往要多于确定未知量所必须观测的个数，也就是要进行<em>多余观测</em>。有了多余观测，势必在观测结果之间产生矛盾，测量平差的目的就在于消除这些矛盾而求得观测量的最可靠结果并评定测量成果的精度。测量平差采用的原理就是“最小二乘法”。平差也就正好表述了为什么需要BA以及BA这个优化过程到底是怎么进行的。<strong>BA的本质是一个优化模型，其目的是最小化重投影误差</strong>。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/BA1.jpg\"></p>\n<p>这些五颜六色的线就是我们讲的光束啦！那现在就该说下什么叫重投影误差了，重投影也就是指的第二次投影，那到底是怎么投影的呢？我们来整理一下吧。</p>\n<ul>\n<li>第一次投影指的就是相机在拍照的时候三维空间点投影到图像上</li>\n<li>第二次投影指的是利用几何信息构建三角形来确定三维空间点的位置，利用相机矩阵将得到的三维点的坐标投影到图像上，进行第二次投影，也就是重投影.重投影使用的三维点的位置是根据三角化得到的。<blockquote>\n<p>第二次投影利用到了三角化的原理，那么什么是三角化呢？参加后文三角化介绍。</p>\n</blockquote>\n</li>\n</ul>\n<p>现在我们知道什么是重投影了，那重投影误差到底是什么样的误差呢？这个误差是指的真实三维空间点在图像平面上的投影（也就是图像上的像素点）和重投影（其实是用我们的计算值得到的虚拟的像素点）的差值，因为种种原因计算得到的值和实际情况不会完全相符，也就是这个差值不可能恰好为0，此时也就需要将这些差值的和最小化获取最优的相机参数及三维空间点的坐标。</p>\n<p>BA是一个图优化模型，那首先肯定要构造一个图模型了（没学过图论也没事，后面还是会回到一般的优化模型）。既然是图模型那自然就有节点和边了，这个图模型的节点由相机$P_i$和三维空间点$X_j$构成，如果点$X_j$投影到相机$P_i$的图像上则将这两个节点连接起来。还是来张图吧。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/BA2.png\"></p>\n<p>这样就一目了然了。那么我们现在就可以通过这个图来构造优化模型了。</p>\n<p>令点$X_j$在相机$P_i$拍摄到的图像归一化坐标系上的坐标为$k(u_{i j}^{T},1)^{T}&#x3D;K_{i}^{-1}x_{i j}$，其重投影后的图像归一化坐标系下坐标为$k^{\\prime}(v_{i j}^{T},1)^{T}&#x3D;K_{i}^{-1}P_{i}X_{j}$，其中$K_{i}^{-1}$是为了在计算时能不受相机内参影响,$k$和$k^{\\prime}$是将齐次坐标转换为非齐次坐标的常数项，可以得到该重投影误差为:<br>$$e_{i j}&#x3D;u_{i j}-v_{i j}$$<br>BA是要将所有重投影误差的和最小化，那么这里自然就要开始求和了。<br>$$\\operatorname*{min}<em>{R</em>{i},t_{i},X_{j}}\\sum_{i,j}\\sigma_{i j}||u_{i j}-v_{i j}||<em>{2}$$<br>其中当点$X_j$在相机$P_i$中有投影时$\\sigma</em>{i j}&#x3D;1$，否则为$\\sigma_{i j}&#x3D;0$。到此我们就得到了BA优化模型的数学形式了。</p>\n<p>既然是优化模型，那自然就应该用各种优化算法来进行计算了。常用的方法有最速下降法，牛顿方法，高斯牛顿方法，LM方法。具体细节<a href=\"https://optsolution.github.io/archives/58892.html\">点我查看</a></p>\n<blockquote>\n<p>具体细节预览<a href=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/BA%E7%AE%80%E8%BF%B0.png\">点我查看</a></p>\n</blockquote>\n<h2 id=\"三角化\"><a href=\"#三角化\" class=\"headerlink\" title=\"三角化\"></a>三角化</h2><p>在单目SLAM中，仅通过单张图像无法获得像素的深度信息，我们需要通过三角测量(Triangulation)(或三角化)的方法来估计地图点的深度。即通过某个特征点P在不同帧图像中像素点的位置，来计算出该特征点在三维空间中的坐标，也即获得特征点P的深度信息。特征点在某个相机中被观测到，根据相机位姿和观测向量可以得到3D空间中的一条从相机中心出发的观测“射线”，多个相机位姿观测会产生多条观测射线，理想情况下这些观测射线相交于空间中一点，求所有观测射线的交点就是特征点在3D空间的位置，这就是三角化最朴素的思想。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/%E4%B8%89%E8%A7%92%E5%8C%96.png\"></p>\n<p>以两视图的三角化为例，考虑$I_1$,$I_2$两帧图像，$R,t$是第二帧相对于第一帧的旋转矩阵和平移向量（对应的变换矩阵是$T_{12}$）。在$I_1$中有特征点$p_1$，对应于$I_2$中的匹配点$p_2$。根据相机的内参数矩阵$K$，我们便可以获得$p_1$在帧归一化图像平面中的点$x_1&#x3D;K^{-1}p_{1}$；$p_2$在$I_2$帧归一化平面中的点$x_2&#x3D;K^{-1}p_2$。</p>\n<p>根据对极约束，他们满足如下的关系：<br>$$s_{1}x_{1}&#x3D;s_{2}Rx_{2}+t$$</p>\n<p>先对公式左右两端左乘反对称矩阵$x^{\\wedge}$，得到：</p>\n<p>$$s_{1}x_{1}^{\\wedge}x_{1}&#x3D;0&#x3D;s_{2}x_{1}^{\\wedge}R x_{2}+x_{1}^{\\wedge}t$$</p>\n<p>根据上述公式的右端，可以计算出$s_2$，进而计算出$s_1$，我们便可得到路标点$P$在这两帧中的深度。然而，在实际的位姿估计中，我们估计的值往往存在误差，上述公式不严格为0。这时候我们可以计算最小二乘解。</p>\n<blockquote>\n<p>多视图三角化<a href=\"https://gutsgwh1997.github.io/2020/03/31/%E5%A4%9A%E8%A7%86%E5%9B%BE%E4%B8%89%E8%A7%92%E5%8C%96/\">点我查看</a><br>具体细节预览<a href=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/%E5%A4%9A%E8%A7%86%E5%9B%BE%E4%B8%89%E8%A7%92%E5%8C%96.png\">点我查看</a></p>\n</blockquote>\n<h2 id=\"对极约束\"><a href=\"#对极约束\" class=\"headerlink\" title=\"对极约束\"></a>对极约束</h2><p>对极几何（Epipolar geometry）又叫对极约束，是根据图像二维平面信息来估计单目相机帧间运动或双目相机相对位姿关系的一种算法。直观来讲，当相机在两个不同视角对同一物体进行拍摄时，物体在两幅图像中的成像肯定会有不同，那么，根据这两幅不同的图像，我们如何判断出相机的位姿发生了怎样的变化，这正是对极几何要解决的问题。直观来说就是利用$n$对匹配点对的图像坐标求解相机位姿变换关系。</p>\n<p>需要明确的是，在对极几何中，我们的已知条件仅仅是每幅图像中特征点的像素坐标，当然，计算对极约束的前提是我们必须知道两幅图像中特征点之间准确的匹配关系。<br><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png\"><br><img src=\"https://cdn.jsdelivr.net/gh/geiyiren/MyBlogImage1/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0g2o/%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95%E6%8E%A8%E5%AF%BC.png\"></p>\n","categories":[{"name":"g2o","path":"api/categories/g2o.json"}],"tags":[{"name":"g2o","path":"api/tags/g2o.json"}]}